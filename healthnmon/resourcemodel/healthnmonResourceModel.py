#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Thu Mar 28 15:51:26 2013 by generateDS.py version 2.7b.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Entity(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:string', 0),
        'name': MemberSpec_('name', 'xs:string', 0),
        'note': MemberSpec_('note', 'xs:string', 0),
        'createEpoch': MemberSpec_('createEpoch', 'xs:long', 0),
        'lastModifiedEpoch': MemberSpec_('lastModifiedEpoch', 'xs:long', 0),
        'deletedEpoch': MemberSpec_('deletedEpoch', 'xs:long', 0),
        'deleted': MemberSpec_('deleted', 'xs:boolean', 0),
        'cost': MemberSpec_('cost', 'Cost', 0),
        'properties': MemberSpec_('properties', 'Property', 1),
        }
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, note=None, createEpoch=None, lastModifiedEpoch=None, deletedEpoch=None, deleted=None, cost=None, properties=None):
        self.id = id
        self.name = name
        self.note = note
        self.createEpoch = createEpoch
        self.lastModifiedEpoch = lastModifiedEpoch
        self.deletedEpoch = deletedEpoch
        self.deleted = deleted
        self.cost = cost
        if properties is None:
            self.properties = []
        else:
            self.properties = properties
    def factory(*args_, **kwargs_):
        if Entity.subclass:
            return Entity.subclass(*args_, **kwargs_)
        else:
            return Entity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    idProp = property(get_id, set_id)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    noteProp = property(get_note, set_note)
    def get_createEpoch(self): return self.createEpoch
    def set_createEpoch(self, createEpoch): self.createEpoch = createEpoch
    createEpochProp = property(get_createEpoch, set_createEpoch)
    def get_lastModifiedEpoch(self): return self.lastModifiedEpoch
    def set_lastModifiedEpoch(self, lastModifiedEpoch): self.lastModifiedEpoch = lastModifiedEpoch
    lastModifiedEpochProp = property(get_lastModifiedEpoch, set_lastModifiedEpoch)
    def get_deletedEpoch(self): return self.deletedEpoch
    def set_deletedEpoch(self, deletedEpoch): self.deletedEpoch = deletedEpoch
    deletedEpochProp = property(get_deletedEpoch, set_deletedEpoch)
    def get_deleted(self): return self.deleted
    def set_deleted(self, deleted): self.deleted = deleted
    deletedProp = property(get_deleted, set_deleted)
    def get_cost(self): return self.cost
    def set_cost(self, cost): self.cost = cost
    costProp = property(get_cost, set_cost)
    def get_properties(self): return self.properties
    def set_properties(self, properties): self.properties = properties
    def add_properties(self, value): self.properties.append(value)
    def insert_properties(self, index, value): self.properties[index] = value
    propertiesProp = property(get_properties, set_properties)
    def export(self, outfile, level, namespace_='', name_='Entity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Entity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Entity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Entity', fromsubclass_=False):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('<%sid>%s</%sid>\n' % (namespace_, self.gds_format_string(quote_xml(self.id).encode(ExternalEncoding), input_name='id'), namespace_))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.note is not None:
            showIndent(outfile, level)
            outfile.write('<%snote>%s</%snote>\n' % (namespace_, self.gds_format_string(quote_xml(self.note).encode(ExternalEncoding), input_name='note'), namespace_))
        if self.createEpoch is not None:
            showIndent(outfile, level)
            outfile.write('<%screateEpoch>%s</%screateEpoch>\n' % (namespace_, self.gds_format_integer(self.createEpoch, input_name='createEpoch'), namespace_))
        if self.lastModifiedEpoch is not None:
            showIndent(outfile, level)
            outfile.write('<%slastModifiedEpoch>%s</%slastModifiedEpoch>\n' % (namespace_, self.gds_format_integer(self.lastModifiedEpoch, input_name='lastModifiedEpoch'), namespace_))
        if self.deletedEpoch is not None:
            showIndent(outfile, level)
            outfile.write('<%sdeletedEpoch>%s</%sdeletedEpoch>\n' % (namespace_, self.gds_format_integer(self.deletedEpoch, input_name='deletedEpoch'), namespace_))
        if self.deleted is not None:
            showIndent(outfile, level)
            outfile.write('<%sdeleted>%s</%sdeleted>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.deleted)), input_name='deleted'), namespace_))
        if self.cost is not None:
            self.cost.export(outfile, level, namespace_, name_='cost')
        for properties_ in self.properties:
            properties_.export(outfile, level, namespace_, name_='properties')
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.note is not None or
            self.createEpoch is not None or
            self.lastModifiedEpoch is not None or
            self.deletedEpoch is not None or
            self.deleted is not None or
            self.cost is not None or
            self.properties
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Entity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.note is not None:
            showIndent(outfile, level)
            outfile.write('note=%s,\n' % quote_python(self.note).encode(ExternalEncoding))
        if self.createEpoch is not None:
            showIndent(outfile, level)
            outfile.write('createEpoch=%d,\n' % self.createEpoch)
        if self.lastModifiedEpoch is not None:
            showIndent(outfile, level)
            outfile.write('lastModifiedEpoch=%d,\n' % self.lastModifiedEpoch)
        if self.deletedEpoch is not None:
            showIndent(outfile, level)
            outfile.write('deletedEpoch=%d,\n' % self.deletedEpoch)
        if self.deleted is not None:
            showIndent(outfile, level)
            outfile.write('deleted=%s,\n' % self.deleted)
        if self.cost is not None:
            showIndent(outfile, level)
            outfile.write('cost=model_.Cost(\n')
            self.cost.exportLiteral(outfile, level, name_='cost')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('properties=[\n')
        level += 1
        for properties_ in self.properties:
            showIndent(outfile, level)
            outfile.write('model_.Property(\n')
            properties_.exportLiteral(outfile, level, name_='Property')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'note':
            note_ = child_.text
            note_ = self.gds_validate_string(note_, node, 'note')
            self.note = note_
        elif nodeName_ == 'createEpoch':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'createEpoch')
            self.createEpoch = ival_
        elif nodeName_ == 'lastModifiedEpoch':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lastModifiedEpoch')
            self.lastModifiedEpoch = ival_
        elif nodeName_ == 'deletedEpoch':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'deletedEpoch')
            self.deletedEpoch = ival_
        elif nodeName_ == 'deleted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'deleted')
            self.deleted = ival_
        elif nodeName_ == 'cost':
            obj_ = Cost.factory()
            obj_.build(child_)
            self.set_cost(obj_)
        elif nodeName_ == 'properties':
            obj_ = Property.factory()
            obj_.build(child_)
            self.properties.append(obj_)
    @classmethod
    def get_all_members(cls):
        member_items = Entity.member_data_items_
        if Entity.superclass != None:
            member_items.update(Entity.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Entity._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Entity()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Entity.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Entity.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Entity


class Property(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:integer', 0),
        'name': MemberSpec_('name', 'xs:string', 0),
        'note': MemberSpec_('note', 'xs:string', 0),
        'value': MemberSpec_('value', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, note=None, value=None):
        self.id = id
        self.name = name
        self.note = note
        self.value = value
    def factory(*args_, **kwargs_):
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    idProp = property(get_id, set_id)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    noteProp = property(get_note, set_note)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    valueProp = property(get_value, set_value)
    def export(self, outfile, level, namespace_='', name_='Property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Property')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Property'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Property', fromsubclass_=False):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('<%sid>%s</%sid>\n' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.note is not None:
            showIndent(outfile, level)
            outfile.write('<%snote>%s</%snote>\n' % (namespace_, self.gds_format_string(quote_xml(self.note).encode(ExternalEncoding), input_name='note'), namespace_))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.note is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.note is not None:
            showIndent(outfile, level)
            outfile.write('note=%s,\n' % quote_python(self.note).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'note':
            note_ = child_.text
            note_ = self.gds_validate_string(note_, node, 'note')
            self.note = note_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
    @classmethod
    def get_all_members(cls):
        member_items = Property.member_data_items_
        if Property.superclass != None:
            member_items.update(Property.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Property._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Property()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Property.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Property.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Property


class Cost(GeneratedsSuper):
    member_data_items_ = {
        'value': MemberSpec_('value', 'xs:decimal', 0),
        'units': MemberSpec_('units', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, value=None, units=None):
        self.value = value
        self.units = units
    def factory(*args_, **kwargs_):
        if Cost.subclass:
            return Cost.subclass(*args_, **kwargs_)
        else:
            return Cost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    valueProp = property(get_value, set_value)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    unitsProp = property(get_units, set_units)
    def export(self, outfile, level, namespace_='', name_='Cost', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cost')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cost'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Cost', fromsubclass_=False):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_float(self.value, input_name='value'), namespace_))
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('<%sunits>%s</%sunits>\n' % (namespace_, self.gds_format_string(quote_xml(self.units).encode(ExternalEncoding), input_name='units'), namespace_))
    def hasContent_(self):
        if (
            self.value is not None or
            self.units is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Cost'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%f,\n' % self.value)
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('units=%s,\n' % quote_python(self.units).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'value')
            self.value = fval_
        elif nodeName_ == 'units':
            units_ = child_.text
            units_ = self.gds_validate_string(units_, node, 'units')
            self.units = units_
    @classmethod
    def get_all_members(cls):
        member_items = Cost.member_data_items_
        if Cost.superclass != None:
            member_items.update(Cost.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Cost._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Cost()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Cost.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Cost.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Cost


class ResourceTag(GeneratedsSuper):
    member_data_items_ = {
        'value': MemberSpec_('value', 'xs:string', 0),
        'assertionType': MemberSpec_('assertionType', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, value=None, assertionType=None):
        self.value = value
        self.assertionType = assertionType
    def factory(*args_, **kwargs_):
        if ResourceTag.subclass:
            return ResourceTag.subclass(*args_, **kwargs_)
        else:
            return ResourceTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    valueProp = property(get_value, set_value)
    def get_assertionType(self): return self.assertionType
    def set_assertionType(self, assertionType): self.assertionType = assertionType
    assertionTypeProp = property(get_assertionType, set_assertionType)
    def export(self, outfile, level, namespace_='', name_='ResourceTag', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceTag')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceTag'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceTag', fromsubclass_=False):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
        if self.assertionType is not None:
            showIndent(outfile, level)
            outfile.write('<%sassertionType>%s</%sassertionType>\n' % (namespace_, self.gds_format_string(quote_xml(self.assertionType).encode(ExternalEncoding), input_name='assertionType'), namespace_))
    def hasContent_(self):
        if (
            self.value is not None or
            self.assertionType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResourceTag'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.assertionType is not None:
            showIndent(outfile, level)
            outfile.write('assertionType=%s,\n' % quote_python(self.assertionType).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'assertionType':
            assertionType_ = child_.text
            assertionType_ = self.gds_validate_string(assertionType_, node, 'assertionType')
            self.assertionType = assertionType_
    @classmethod
    def get_all_members(cls):
        member_items = ResourceTag.member_data_items_
        if ResourceTag.superclass != None:
            member_items.update(ResourceTag.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return ResourceTag._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = ResourceTag()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return ResourceTag.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = ResourceTag.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class ResourceTag


class Resource(Entity):
    member_data_items_ = {
        'resourceManagerId': MemberSpec_('resourceManagerId', 'xs:string', 0),
        'utilization': MemberSpec_('utilization', 'ResourceUtilization', 0),
        'limits': MemberSpec_('limits', 'ResourceLimit', 0),
        'vendorProperties': MemberSpec_('vendorProperties', 'VendorProperties', 0),
        }
    subclass = None
    superclass = Entity
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, extensiontype_=None):
        super(Resource, self).__init__(extensiontype_, )
        self.resourceManagerId = resourceManagerId
        self.utilization = utilization
        self.limits = limits
        self.vendorProperties = vendorProperties
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Resource.subclass:
            return Resource.subclass(*args_, **kwargs_)
        else:
            return Resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceManagerId(self): return self.resourceManagerId
    def set_resourceManagerId(self, resourceManagerId): self.resourceManagerId = resourceManagerId
    resourceManagerIdProp = property(get_resourceManagerId, set_resourceManagerId)
    def get_utilization(self): return self.utilization
    def set_utilization(self, utilization): self.utilization = utilization
    utilizationProp = property(get_utilization, set_utilization)
    def get_limits(self): return self.limits
    def set_limits(self, limits): self.limits = limits
    limitsProp = property(get_limits, set_limits)
    def get_vendorProperties(self): return self.vendorProperties
    def set_vendorProperties(self, vendorProperties): self.vendorProperties = vendorProperties
    vendorPropertiesProp = property(get_vendorProperties, set_vendorProperties)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Resource', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Resource')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Resource'):
        super(Resource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Resource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Resource', fromsubclass_=False):
        super(Resource, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.resourceManagerId is not None:
            showIndent(outfile, level)
            outfile.write('<%sresourceManagerId>%s</%sresourceManagerId>\n' % (namespace_, self.gds_format_string(quote_xml(self.resourceManagerId).encode(ExternalEncoding), input_name='resourceManagerId'), namespace_))
        if self.utilization is not None:
            self.utilization.export(outfile, level, namespace_, name_='utilization')
        if self.limits is not None:
            self.limits.export(outfile, level, namespace_, name_='limits')
        if self.vendorProperties is not None:
            self.vendorProperties.export(outfile, level, namespace_, name_='vendorProperties')
    def hasContent_(self):
        if (
            self.resourceManagerId is not None or
            self.utilization is not None or
            self.limits is not None or
            self.vendorProperties is not None or
            super(Resource, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Resource'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Resource, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Resource, self).exportLiteralChildren(outfile, level, name_)
        if self.resourceManagerId is not None:
            showIndent(outfile, level)
            outfile.write('resourceManagerId=%s,\n' % quote_python(self.resourceManagerId).encode(ExternalEncoding))
        if self.utilization is not None:
            showIndent(outfile, level)
            outfile.write('utilization=model_.ResourceUtilization(\n')
            self.utilization.exportLiteral(outfile, level, name_='utilization')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.limits is not None:
            showIndent(outfile, level)
            outfile.write('limits=model_.ResourceLimit(\n')
            self.limits.exportLiteral(outfile, level, name_='limits')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vendorProperties is not None:
            showIndent(outfile, level)
            outfile.write('vendorProperties=model_.VendorProperties(\n')
            self.vendorProperties.exportLiteral(outfile, level, name_='vendorProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(Resource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resourceManagerId':
            resourceManagerId_ = child_.text
            resourceManagerId_ = self.gds_validate_string(resourceManagerId_, node, 'resourceManagerId')
            self.resourceManagerId = resourceManagerId_
        elif nodeName_ == 'utilization':
            obj_ = ResourceUtilization.factory()
            obj_.build(child_)
            self.set_utilization(obj_)
        elif nodeName_ == 'limits':
            obj_ = ResourceLimit.factory()
            obj_.build(child_)
            self.set_limits(obj_)
        elif nodeName_ == 'vendorProperties':
            obj_ = VendorProperties.factory()
            obj_.build(child_)
            self.set_vendorProperties(obj_)
        super(Resource, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = Resource.member_data_items_
        if Resource.superclass != None:
            member_items.update(Resource.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Resource._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Resource()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Resource.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Resource.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Resource


class ResourceUtilization(GeneratedsSuper):
    member_data_items_ = {
        'resourceId': MemberSpec_('resourceId', 'xs:string', 0),
        'timestamp': MemberSpec_('timestamp', 'xs:dateTime', 0),
        'granularity': MemberSpec_('granularity', 'xs:int', 0),
        'cpuUserLoad': MemberSpec_('cpuUserLoad', 'xs:double', 0),
        'cpuSystemLoad': MemberSpec_('cpuSystemLoad', 'xs:double', 0),
        'hostCpuSpeed': MemberSpec_('hostCpuSpeed', 'xs:long', 0),
        'hostMaxCpuSpeed': MemberSpec_('hostMaxCpuSpeed', 'xs:long', 0),
        'ncpus': MemberSpec_('ncpus', 'xs:int', 0),
        'diskRead': MemberSpec_('diskRead', 'xs:double', 0),
        'diskWrite': MemberSpec_('diskWrite', 'xs:double', 0),
        'netRead': MemberSpec_('netRead', 'xs:double', 0),
        'netWrite': MemberSpec_('netWrite', 'xs:double', 0),
        'totalMemory': MemberSpec_('totalMemory', 'xs:long', 0),
        'freeMemory': MemberSpec_('freeMemory', 'xs:long', 0),
        'configuredMemory': MemberSpec_('configuredMemory', 'xs:long', 0),
        'uptimeMinute': MemberSpec_('uptimeMinute', 'xs:long', 0),
        'reservedSystemCapacity': MemberSpec_('reservedSystemCapacity', 'xs:long', 0),
        'maximumSystemCapacity': MemberSpec_('maximumSystemCapacity', 'xs:long', 0),
        'relativeWeight': MemberSpec_('relativeWeight', 'xs:long', 0),
        'reservedSystemMemory': MemberSpec_('reservedSystemMemory', 'xs:long', 0),
        'maximumSystemMemory': MemberSpec_('maximumSystemMemory', 'xs:long', 0),
        'memoryRelativeWeight': MemberSpec_('memoryRelativeWeight', 'xs:long', 0),
        'status': MemberSpec_('status', 'xs:int', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, resourceId=None, timestamp=None, granularity=None, cpuUserLoad=None, cpuSystemLoad=None, hostCpuSpeed=None, hostMaxCpuSpeed=None, ncpus=None, diskRead=None, diskWrite=None, netRead=None, netWrite=None, totalMemory=None, freeMemory=None, configuredMemory=None, uptimeMinute=None, reservedSystemCapacity=None, maximumSystemCapacity=None, relativeWeight=None, reservedSystemMemory=None, maximumSystemMemory=None, memoryRelativeWeight=None, status=None):
        self.resourceId = resourceId
        self.timestamp = timestamp
        self.granularity = granularity
        self.cpuUserLoad = cpuUserLoad
        self.cpuSystemLoad = cpuSystemLoad
        self.hostCpuSpeed = hostCpuSpeed
        self.hostMaxCpuSpeed = hostMaxCpuSpeed
        self.ncpus = ncpus
        self.diskRead = diskRead
        self.diskWrite = diskWrite
        self.netRead = netRead
        self.netWrite = netWrite
        self.totalMemory = totalMemory
        self.freeMemory = freeMemory
        self.configuredMemory = configuredMemory
        self.uptimeMinute = uptimeMinute
        self.reservedSystemCapacity = reservedSystemCapacity
        self.maximumSystemCapacity = maximumSystemCapacity
        self.relativeWeight = relativeWeight
        self.reservedSystemMemory = reservedSystemMemory
        self.maximumSystemMemory = maximumSystemMemory
        self.memoryRelativeWeight = memoryRelativeWeight
        self.status = status
    def factory(*args_, **kwargs_):
        if ResourceUtilization.subclass:
            return ResourceUtilization.subclass(*args_, **kwargs_)
        else:
            return ResourceUtilization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceId(self): return self.resourceId
    def set_resourceId(self, resourceId): self.resourceId = resourceId
    resourceIdProp = property(get_resourceId, set_resourceId)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    timestampProp = property(get_timestamp, set_timestamp)
    def get_granularity(self): return self.granularity
    def set_granularity(self, granularity): self.granularity = granularity
    granularityProp = property(get_granularity, set_granularity)
    def get_cpuUserLoad(self): return self.cpuUserLoad
    def set_cpuUserLoad(self, cpuUserLoad): self.cpuUserLoad = cpuUserLoad
    cpuUserLoadProp = property(get_cpuUserLoad, set_cpuUserLoad)
    def get_cpuSystemLoad(self): return self.cpuSystemLoad
    def set_cpuSystemLoad(self, cpuSystemLoad): self.cpuSystemLoad = cpuSystemLoad
    cpuSystemLoadProp = property(get_cpuSystemLoad, set_cpuSystemLoad)
    def get_hostCpuSpeed(self): return self.hostCpuSpeed
    def set_hostCpuSpeed(self, hostCpuSpeed): self.hostCpuSpeed = hostCpuSpeed
    hostCpuSpeedProp = property(get_hostCpuSpeed, set_hostCpuSpeed)
    def get_hostMaxCpuSpeed(self): return self.hostMaxCpuSpeed
    def set_hostMaxCpuSpeed(self, hostMaxCpuSpeed): self.hostMaxCpuSpeed = hostMaxCpuSpeed
    hostMaxCpuSpeedProp = property(get_hostMaxCpuSpeed, set_hostMaxCpuSpeed)
    def get_ncpus(self): return self.ncpus
    def set_ncpus(self, ncpus): self.ncpus = ncpus
    ncpusProp = property(get_ncpus, set_ncpus)
    def get_diskRead(self): return self.diskRead
    def set_diskRead(self, diskRead): self.diskRead = diskRead
    diskReadProp = property(get_diskRead, set_diskRead)
    def get_diskWrite(self): return self.diskWrite
    def set_diskWrite(self, diskWrite): self.diskWrite = diskWrite
    diskWriteProp = property(get_diskWrite, set_diskWrite)
    def get_netRead(self): return self.netRead
    def set_netRead(self, netRead): self.netRead = netRead
    netReadProp = property(get_netRead, set_netRead)
    def get_netWrite(self): return self.netWrite
    def set_netWrite(self, netWrite): self.netWrite = netWrite
    netWriteProp = property(get_netWrite, set_netWrite)
    def get_totalMemory(self): return self.totalMemory
    def set_totalMemory(self, totalMemory): self.totalMemory = totalMemory
    totalMemoryProp = property(get_totalMemory, set_totalMemory)
    def get_freeMemory(self): return self.freeMemory
    def set_freeMemory(self, freeMemory): self.freeMemory = freeMemory
    freeMemoryProp = property(get_freeMemory, set_freeMemory)
    def get_configuredMemory(self): return self.configuredMemory
    def set_configuredMemory(self, configuredMemory): self.configuredMemory = configuredMemory
    configuredMemoryProp = property(get_configuredMemory, set_configuredMemory)
    def get_uptimeMinute(self): return self.uptimeMinute
    def set_uptimeMinute(self, uptimeMinute): self.uptimeMinute = uptimeMinute
    uptimeMinuteProp = property(get_uptimeMinute, set_uptimeMinute)
    def get_reservedSystemCapacity(self): return self.reservedSystemCapacity
    def set_reservedSystemCapacity(self, reservedSystemCapacity): self.reservedSystemCapacity = reservedSystemCapacity
    reservedSystemCapacityProp = property(get_reservedSystemCapacity, set_reservedSystemCapacity)
    def get_maximumSystemCapacity(self): return self.maximumSystemCapacity
    def set_maximumSystemCapacity(self, maximumSystemCapacity): self.maximumSystemCapacity = maximumSystemCapacity
    maximumSystemCapacityProp = property(get_maximumSystemCapacity, set_maximumSystemCapacity)
    def get_relativeWeight(self): return self.relativeWeight
    def set_relativeWeight(self, relativeWeight): self.relativeWeight = relativeWeight
    relativeWeightProp = property(get_relativeWeight, set_relativeWeight)
    def get_reservedSystemMemory(self): return self.reservedSystemMemory
    def set_reservedSystemMemory(self, reservedSystemMemory): self.reservedSystemMemory = reservedSystemMemory
    reservedSystemMemoryProp = property(get_reservedSystemMemory, set_reservedSystemMemory)
    def get_maximumSystemMemory(self): return self.maximumSystemMemory
    def set_maximumSystemMemory(self, maximumSystemMemory): self.maximumSystemMemory = maximumSystemMemory
    maximumSystemMemoryProp = property(get_maximumSystemMemory, set_maximumSystemMemory)
    def get_memoryRelativeWeight(self): return self.memoryRelativeWeight
    def set_memoryRelativeWeight(self, memoryRelativeWeight): self.memoryRelativeWeight = memoryRelativeWeight
    memoryRelativeWeightProp = property(get_memoryRelativeWeight, set_memoryRelativeWeight)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    statusProp = property(get_status, set_status)
    def export(self, outfile, level, namespace_='', name_='ResourceUtilization', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceUtilization')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceUtilization'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceUtilization', fromsubclass_=False):
        if self.resourceId is not None:
            showIndent(outfile, level)
            outfile.write('<%sresourceId>%s</%sresourceId>\n' % (namespace_, self.gds_format_string(quote_xml(self.resourceId).encode(ExternalEncoding), input_name='resourceId'), namespace_))
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % (namespace_, self.gds_format_string(quote_xml(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), namespace_))
        if self.granularity is not None:
            showIndent(outfile, level)
            outfile.write('<%sgranularity>%s</%sgranularity>\n' % (namespace_, self.gds_format_integer(self.granularity, input_name='granularity'), namespace_))
        if self.cpuUserLoad is not None:
            showIndent(outfile, level)
            outfile.write('<%scpuUserLoad>%s</%scpuUserLoad>\n' % (namespace_, self.gds_format_double(self.cpuUserLoad, input_name='cpuUserLoad'), namespace_))
        if self.cpuSystemLoad is not None:
            showIndent(outfile, level)
            outfile.write('<%scpuSystemLoad>%s</%scpuSystemLoad>\n' % (namespace_, self.gds_format_double(self.cpuSystemLoad, input_name='cpuSystemLoad'), namespace_))
        if self.hostCpuSpeed is not None:
            showIndent(outfile, level)
            outfile.write('<%shostCpuSpeed>%s</%shostCpuSpeed>\n' % (namespace_, self.gds_format_integer(self.hostCpuSpeed, input_name='hostCpuSpeed'), namespace_))
        if self.hostMaxCpuSpeed is not None:
            showIndent(outfile, level)
            outfile.write('<%shostMaxCpuSpeed>%s</%shostMaxCpuSpeed>\n' % (namespace_, self.gds_format_integer(self.hostMaxCpuSpeed, input_name='hostMaxCpuSpeed'), namespace_))
        if self.ncpus is not None:
            showIndent(outfile, level)
            outfile.write('<%sncpus>%s</%sncpus>\n' % (namespace_, self.gds_format_integer(self.ncpus, input_name='ncpus'), namespace_))
        if self.diskRead is not None:
            showIndent(outfile, level)
            outfile.write('<%sdiskRead>%s</%sdiskRead>\n' % (namespace_, self.gds_format_double(self.diskRead, input_name='diskRead'), namespace_))
        if self.diskWrite is not None:
            showIndent(outfile, level)
            outfile.write('<%sdiskWrite>%s</%sdiskWrite>\n' % (namespace_, self.gds_format_double(self.diskWrite, input_name='diskWrite'), namespace_))
        if self.netRead is not None:
            showIndent(outfile, level)
            outfile.write('<%snetRead>%s</%snetRead>\n' % (namespace_, self.gds_format_double(self.netRead, input_name='netRead'), namespace_))
        if self.netWrite is not None:
            showIndent(outfile, level)
            outfile.write('<%snetWrite>%s</%snetWrite>\n' % (namespace_, self.gds_format_double(self.netWrite, input_name='netWrite'), namespace_))
        if self.totalMemory is not None:
            showIndent(outfile, level)
            outfile.write('<%stotalMemory>%s</%stotalMemory>\n' % (namespace_, self.gds_format_integer(self.totalMemory, input_name='totalMemory'), namespace_))
        if self.freeMemory is not None:
            showIndent(outfile, level)
            outfile.write('<%sfreeMemory>%s</%sfreeMemory>\n' % (namespace_, self.gds_format_integer(self.freeMemory, input_name='freeMemory'), namespace_))
        if self.configuredMemory is not None:
            showIndent(outfile, level)
            outfile.write('<%sconfiguredMemory>%s</%sconfiguredMemory>\n' % (namespace_, self.gds_format_integer(self.configuredMemory, input_name='configuredMemory'), namespace_))
        if self.uptimeMinute is not None:
            showIndent(outfile, level)
            outfile.write('<%suptimeMinute>%s</%suptimeMinute>\n' % (namespace_, self.gds_format_integer(self.uptimeMinute, input_name='uptimeMinute'), namespace_))
        if self.reservedSystemCapacity is not None:
            showIndent(outfile, level)
            outfile.write('<%sreservedSystemCapacity>%s</%sreservedSystemCapacity>\n' % (namespace_, self.gds_format_integer(self.reservedSystemCapacity, input_name='reservedSystemCapacity'), namespace_))
        if self.maximumSystemCapacity is not None:
            showIndent(outfile, level)
            outfile.write('<%smaximumSystemCapacity>%s</%smaximumSystemCapacity>\n' % (namespace_, self.gds_format_integer(self.maximumSystemCapacity, input_name='maximumSystemCapacity'), namespace_))
        if self.relativeWeight is not None:
            showIndent(outfile, level)
            outfile.write('<%srelativeWeight>%s</%srelativeWeight>\n' % (namespace_, self.gds_format_integer(self.relativeWeight, input_name='relativeWeight'), namespace_))
        if self.reservedSystemMemory is not None:
            showIndent(outfile, level)
            outfile.write('<%sreservedSystemMemory>%s</%sreservedSystemMemory>\n' % (namespace_, self.gds_format_integer(self.reservedSystemMemory, input_name='reservedSystemMemory'), namespace_))
        if self.maximumSystemMemory is not None:
            showIndent(outfile, level)
            outfile.write('<%smaximumSystemMemory>%s</%smaximumSystemMemory>\n' % (namespace_, self.gds_format_integer(self.maximumSystemMemory, input_name='maximumSystemMemory'), namespace_))
        if self.memoryRelativeWeight is not None:
            showIndent(outfile, level)
            outfile.write('<%smemoryRelativeWeight>%s</%smemoryRelativeWeight>\n' % (namespace_, self.gds_format_integer(self.memoryRelativeWeight, input_name='memoryRelativeWeight'), namespace_))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('<%sstatus>%s</%sstatus>\n' % (namespace_, self.gds_format_integer(self.status, input_name='status'), namespace_))
    def hasContent_(self):
        if (
            self.resourceId is not None or
            self.timestamp is not None or
            self.granularity is not None or
            self.cpuUserLoad is not None or
            self.cpuSystemLoad is not None or
            self.hostCpuSpeed is not None or
            self.hostMaxCpuSpeed is not None or
            self.ncpus is not None or
            self.diskRead is not None or
            self.diskWrite is not None or
            self.netRead is not None or
            self.netWrite is not None or
            self.totalMemory is not None or
            self.freeMemory is not None or
            self.configuredMemory is not None or
            self.uptimeMinute is not None or
            self.reservedSystemCapacity is not None or
            self.maximumSystemCapacity is not None or
            self.relativeWeight is not None or
            self.reservedSystemMemory is not None or
            self.maximumSystemMemory is not None or
            self.memoryRelativeWeight is not None or
            self.status is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResourceUtilization'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resourceId is not None:
            showIndent(outfile, level)
            outfile.write('resourceId=%s,\n' % quote_python(self.resourceId).encode(ExternalEncoding))
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=%s,\n' % quote_python(self.timestamp).encode(ExternalEncoding))
        if self.granularity is not None:
            showIndent(outfile, level)
            outfile.write('granularity=%d,\n' % self.granularity)
        if self.cpuUserLoad is not None:
            showIndent(outfile, level)
            outfile.write('cpuUserLoad=%e,\n' % self.cpuUserLoad)
        if self.cpuSystemLoad is not None:
            showIndent(outfile, level)
            outfile.write('cpuSystemLoad=%e,\n' % self.cpuSystemLoad)
        if self.hostCpuSpeed is not None:
            showIndent(outfile, level)
            outfile.write('hostCpuSpeed=%d,\n' % self.hostCpuSpeed)
        if self.hostMaxCpuSpeed is not None:
            showIndent(outfile, level)
            outfile.write('hostMaxCpuSpeed=%d,\n' % self.hostMaxCpuSpeed)
        if self.ncpus is not None:
            showIndent(outfile, level)
            outfile.write('ncpus=%d,\n' % self.ncpus)
        if self.diskRead is not None:
            showIndent(outfile, level)
            outfile.write('diskRead=%e,\n' % self.diskRead)
        if self.diskWrite is not None:
            showIndent(outfile, level)
            outfile.write('diskWrite=%e,\n' % self.diskWrite)
        if self.netRead is not None:
            showIndent(outfile, level)
            outfile.write('netRead=%e,\n' % self.netRead)
        if self.netWrite is not None:
            showIndent(outfile, level)
            outfile.write('netWrite=%e,\n' % self.netWrite)
        if self.totalMemory is not None:
            showIndent(outfile, level)
            outfile.write('totalMemory=%d,\n' % self.totalMemory)
        if self.freeMemory is not None:
            showIndent(outfile, level)
            outfile.write('freeMemory=%d,\n' % self.freeMemory)
        if self.configuredMemory is not None:
            showIndent(outfile, level)
            outfile.write('configuredMemory=%d,\n' % self.configuredMemory)
        if self.uptimeMinute is not None:
            showIndent(outfile, level)
            outfile.write('uptimeMinute=%d,\n' % self.uptimeMinute)
        if self.reservedSystemCapacity is not None:
            showIndent(outfile, level)
            outfile.write('reservedSystemCapacity=%d,\n' % self.reservedSystemCapacity)
        if self.maximumSystemCapacity is not None:
            showIndent(outfile, level)
            outfile.write('maximumSystemCapacity=%d,\n' % self.maximumSystemCapacity)
        if self.relativeWeight is not None:
            showIndent(outfile, level)
            outfile.write('relativeWeight=%d,\n' % self.relativeWeight)
        if self.reservedSystemMemory is not None:
            showIndent(outfile, level)
            outfile.write('reservedSystemMemory=%d,\n' % self.reservedSystemMemory)
        if self.maximumSystemMemory is not None:
            showIndent(outfile, level)
            outfile.write('maximumSystemMemory=%d,\n' % self.maximumSystemMemory)
        if self.memoryRelativeWeight is not None:
            showIndent(outfile, level)
            outfile.write('memoryRelativeWeight=%d,\n' % self.memoryRelativeWeight)
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % self.status)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resourceId':
            resourceId_ = child_.text
            resourceId_ = self.gds_validate_string(resourceId_, node, 'resourceId')
            self.resourceId = resourceId_
        elif nodeName_ == 'timestamp':
            timestamp_ = child_.text
            timestamp_ = self.gds_validate_string(timestamp_, node, 'timestamp')
            self.timestamp = timestamp_
        elif nodeName_ == 'granularity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'granularity')
            self.granularity = ival_
        elif nodeName_ == 'cpuUserLoad':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'cpuUserLoad')
            self.cpuUserLoad = fval_
        elif nodeName_ == 'cpuSystemLoad':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'cpuSystemLoad')
            self.cpuSystemLoad = fval_
        elif nodeName_ == 'hostCpuSpeed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hostCpuSpeed')
            self.hostCpuSpeed = ival_
        elif nodeName_ == 'hostMaxCpuSpeed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hostMaxCpuSpeed')
            self.hostMaxCpuSpeed = ival_
        elif nodeName_ == 'ncpus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ncpus')
            self.ncpus = ival_
        elif nodeName_ == 'diskRead':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'diskRead')
            self.diskRead = fval_
        elif nodeName_ == 'diskWrite':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'diskWrite')
            self.diskWrite = fval_
        elif nodeName_ == 'netRead':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'netRead')
            self.netRead = fval_
        elif nodeName_ == 'netWrite':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'netWrite')
            self.netWrite = fval_
        elif nodeName_ == 'totalMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalMemory')
            self.totalMemory = ival_
        elif nodeName_ == 'freeMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'freeMemory')
            self.freeMemory = ival_
        elif nodeName_ == 'configuredMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'configuredMemory')
            self.configuredMemory = ival_
        elif nodeName_ == 'uptimeMinute':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'uptimeMinute')
            self.uptimeMinute = ival_
        elif nodeName_ == 'reservedSystemCapacity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reservedSystemCapacity')
            self.reservedSystemCapacity = ival_
        elif nodeName_ == 'maximumSystemCapacity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maximumSystemCapacity')
            self.maximumSystemCapacity = ival_
        elif nodeName_ == 'relativeWeight':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'relativeWeight')
            self.relativeWeight = ival_
        elif nodeName_ == 'reservedSystemMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reservedSystemMemory')
            self.reservedSystemMemory = ival_
        elif nodeName_ == 'maximumSystemMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maximumSystemMemory')
            self.maximumSystemMemory = ival_
        elif nodeName_ == 'memoryRelativeWeight':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memoryRelativeWeight')
            self.memoryRelativeWeight = ival_
        elif nodeName_ == 'status':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
    @classmethod
    def get_all_members(cls):
        member_items = ResourceUtilization.member_data_items_
        if ResourceUtilization.superclass != None:
            member_items.update(ResourceUtilization.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return ResourceUtilization._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = ResourceUtilization()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return ResourceUtilization.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = ResourceUtilization.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class ResourceUtilization


class ResourceLimit(GeneratedsSuper):
    member_data_items_ = {
        'resourceId': MemberSpec_('resourceId', 'xs:string', 0),
        'memoryConsumedLimit': MemberSpec_('memoryConsumedLimit', 'xs:long', 0),
        'memoryPercentLimit': MemberSpec_('memoryPercentLimit', 'xs:long', 0),
        'diskSpaceConsumedLimit': MemberSpec_('diskSpaceConsumedLimit', 'xs:long', 0),
        'diskSpacePercentLimit': MemberSpec_('diskSpacePercentLimit', 'xs:long', 0),
        'cpuPercentLimit': MemberSpec_('cpuPercentLimit', 'xs:long', 0),
        'networkPercentLimit': MemberSpec_('networkPercentLimit', 'xs:long', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, resourceId=None, memoryConsumedLimit=None, memoryPercentLimit=None, diskSpaceConsumedLimit=None, diskSpacePercentLimit=None, cpuPercentLimit=None, networkPercentLimit=None):
        self.resourceId = resourceId
        self.memoryConsumedLimit = memoryConsumedLimit
        self.memoryPercentLimit = memoryPercentLimit
        self.diskSpaceConsumedLimit = diskSpaceConsumedLimit
        self.diskSpacePercentLimit = diskSpacePercentLimit
        self.cpuPercentLimit = cpuPercentLimit
        self.networkPercentLimit = networkPercentLimit
    def factory(*args_, **kwargs_):
        if ResourceLimit.subclass:
            return ResourceLimit.subclass(*args_, **kwargs_)
        else:
            return ResourceLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceId(self): return self.resourceId
    def set_resourceId(self, resourceId): self.resourceId = resourceId
    resourceIdProp = property(get_resourceId, set_resourceId)
    def get_memoryConsumedLimit(self): return self.memoryConsumedLimit
    def set_memoryConsumedLimit(self, memoryConsumedLimit): self.memoryConsumedLimit = memoryConsumedLimit
    memoryConsumedLimitProp = property(get_memoryConsumedLimit, set_memoryConsumedLimit)
    def get_memoryPercentLimit(self): return self.memoryPercentLimit
    def set_memoryPercentLimit(self, memoryPercentLimit): self.memoryPercentLimit = memoryPercentLimit
    memoryPercentLimitProp = property(get_memoryPercentLimit, set_memoryPercentLimit)
    def get_diskSpaceConsumedLimit(self): return self.diskSpaceConsumedLimit
    def set_diskSpaceConsumedLimit(self, diskSpaceConsumedLimit): self.diskSpaceConsumedLimit = diskSpaceConsumedLimit
    diskSpaceConsumedLimitProp = property(get_diskSpaceConsumedLimit, set_diskSpaceConsumedLimit)
    def get_diskSpacePercentLimit(self): return self.diskSpacePercentLimit
    def set_diskSpacePercentLimit(self, diskSpacePercentLimit): self.diskSpacePercentLimit = diskSpacePercentLimit
    diskSpacePercentLimitProp = property(get_diskSpacePercentLimit, set_diskSpacePercentLimit)
    def get_cpuPercentLimit(self): return self.cpuPercentLimit
    def set_cpuPercentLimit(self, cpuPercentLimit): self.cpuPercentLimit = cpuPercentLimit
    cpuPercentLimitProp = property(get_cpuPercentLimit, set_cpuPercentLimit)
    def get_networkPercentLimit(self): return self.networkPercentLimit
    def set_networkPercentLimit(self, networkPercentLimit): self.networkPercentLimit = networkPercentLimit
    networkPercentLimitProp = property(get_networkPercentLimit, set_networkPercentLimit)
    def export(self, outfile, level, namespace_='', name_='ResourceLimit', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceLimit')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceLimit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceLimit', fromsubclass_=False):
        if self.resourceId is not None:
            showIndent(outfile, level)
            outfile.write('<%sresourceId>%s</%sresourceId>\n' % (namespace_, self.gds_format_string(quote_xml(self.resourceId).encode(ExternalEncoding), input_name='resourceId'), namespace_))
        if self.memoryConsumedLimit is not None:
            showIndent(outfile, level)
            outfile.write('<%smemoryConsumedLimit>%s</%smemoryConsumedLimit>\n' % (namespace_, self.gds_format_integer(self.memoryConsumedLimit, input_name='memoryConsumedLimit'), namespace_))
        if self.memoryPercentLimit is not None:
            showIndent(outfile, level)
            outfile.write('<%smemoryPercentLimit>%s</%smemoryPercentLimit>\n' % (namespace_, self.gds_format_integer(self.memoryPercentLimit, input_name='memoryPercentLimit'), namespace_))
        if self.diskSpaceConsumedLimit is not None:
            showIndent(outfile, level)
            outfile.write('<%sdiskSpaceConsumedLimit>%s</%sdiskSpaceConsumedLimit>\n' % (namespace_, self.gds_format_integer(self.diskSpaceConsumedLimit, input_name='diskSpaceConsumedLimit'), namespace_))
        if self.diskSpacePercentLimit is not None:
            showIndent(outfile, level)
            outfile.write('<%sdiskSpacePercentLimit>%s</%sdiskSpacePercentLimit>\n' % (namespace_, self.gds_format_integer(self.diskSpacePercentLimit, input_name='diskSpacePercentLimit'), namespace_))
        if self.cpuPercentLimit is not None:
            showIndent(outfile, level)
            outfile.write('<%scpuPercentLimit>%s</%scpuPercentLimit>\n' % (namespace_, self.gds_format_integer(self.cpuPercentLimit, input_name='cpuPercentLimit'), namespace_))
        if self.networkPercentLimit is not None:
            showIndent(outfile, level)
            outfile.write('<%snetworkPercentLimit>%s</%snetworkPercentLimit>\n' % (namespace_, self.gds_format_integer(self.networkPercentLimit, input_name='networkPercentLimit'), namespace_))
    def hasContent_(self):
        if (
            self.resourceId is not None or
            self.memoryConsumedLimit is not None or
            self.memoryPercentLimit is not None or
            self.diskSpaceConsumedLimit is not None or
            self.diskSpacePercentLimit is not None or
            self.cpuPercentLimit is not None or
            self.networkPercentLimit is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResourceLimit'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resourceId is not None:
            showIndent(outfile, level)
            outfile.write('resourceId=%s,\n' % quote_python(self.resourceId).encode(ExternalEncoding))
        if self.memoryConsumedLimit is not None:
            showIndent(outfile, level)
            outfile.write('memoryConsumedLimit=%d,\n' % self.memoryConsumedLimit)
        if self.memoryPercentLimit is not None:
            showIndent(outfile, level)
            outfile.write('memoryPercentLimit=%d,\n' % self.memoryPercentLimit)
        if self.diskSpaceConsumedLimit is not None:
            showIndent(outfile, level)
            outfile.write('diskSpaceConsumedLimit=%d,\n' % self.diskSpaceConsumedLimit)
        if self.diskSpacePercentLimit is not None:
            showIndent(outfile, level)
            outfile.write('diskSpacePercentLimit=%d,\n' % self.diskSpacePercentLimit)
        if self.cpuPercentLimit is not None:
            showIndent(outfile, level)
            outfile.write('cpuPercentLimit=%d,\n' % self.cpuPercentLimit)
        if self.networkPercentLimit is not None:
            showIndent(outfile, level)
            outfile.write('networkPercentLimit=%d,\n' % self.networkPercentLimit)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resourceId':
            resourceId_ = child_.text
            resourceId_ = self.gds_validate_string(resourceId_, node, 'resourceId')
            self.resourceId = resourceId_
        elif nodeName_ == 'memoryConsumedLimit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memoryConsumedLimit')
            self.memoryConsumedLimit = ival_
        elif nodeName_ == 'memoryPercentLimit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memoryPercentLimit')
            self.memoryPercentLimit = ival_
        elif nodeName_ == 'diskSpaceConsumedLimit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'diskSpaceConsumedLimit')
            self.diskSpaceConsumedLimit = ival_
        elif nodeName_ == 'diskSpacePercentLimit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'diskSpacePercentLimit')
            self.diskSpacePercentLimit = ival_
        elif nodeName_ == 'cpuPercentLimit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cpuPercentLimit')
            self.cpuPercentLimit = ival_
        elif nodeName_ == 'networkPercentLimit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'networkPercentLimit')
            self.networkPercentLimit = ival_
    @classmethod
    def get_all_members(cls):
        member_items = ResourceLimit.member_data_items_
        if ResourceLimit.superclass != None:
            member_items.update(ResourceLimit.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return ResourceLimit._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = ResourceLimit()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return ResourceLimit.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = ResourceLimit.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class ResourceLimit


class VendorProperties(Entity):
    member_data_items_ = {
        }
    subclass = None
    superclass = Entity
    def __init__(self):
        super(VendorProperties, self).__init__()
        pass
    def factory(*args_, **kwargs_):
        if VendorProperties.subclass:
            return VendorProperties.subclass(*args_, **kwargs_)
        else:
            return VendorProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='VendorProperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorProperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorProperties'):
        super(VendorProperties, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VendorProperties')
    def exportChildren(self, outfile, level, namespace_='', name_='VendorProperties', fromsubclass_=False):
        super(VendorProperties, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(VendorProperties, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VendorProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VendorProperties, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VendorProperties, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VendorProperties, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VendorProperties, self).buildChildren(child_, node, nodeName_, True)
        pass
    @classmethod
    def get_all_members(cls):
        member_items = VendorProperties.member_data_items_
        if VendorProperties.superclass != None:
            member_items.update(VendorProperties.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VendorProperties._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VendorProperties()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VendorProperties.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VendorProperties.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VendorProperties


class VmGenericDevice(Entity):
    member_data_items_ = {
        }
    subclass = None
    superclass = Entity
    def __init__(self):
        super(VmGenericDevice, self).__init__()
        pass
    def factory(*args_, **kwargs_):
        if VmGenericDevice.subclass:
            return VmGenericDevice.subclass(*args_, **kwargs_)
        else:
            return VmGenericDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='VmGenericDevice', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmGenericDevice')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmGenericDevice'):
        super(VmGenericDevice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmGenericDevice')
    def exportChildren(self, outfile, level, namespace_='', name_='VmGenericDevice', fromsubclass_=False):
        super(VmGenericDevice, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(VmGenericDevice, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmGenericDevice'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmGenericDevice, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmGenericDevice, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmGenericDevice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VmGenericDevice, self).buildChildren(child_, node, nodeName_, True)
        pass
    @classmethod
    def get_all_members(cls):
        member_items = VmGenericDevice.member_data_items_
        if VmGenericDevice.superclass != None:
            member_items.update(VmGenericDevice.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmGenericDevice._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmGenericDevice()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmGenericDevice.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmGenericDevice.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmGenericDevice


class VmGlobalSettings(Entity):
    member_data_items_ = {
        'autoStartAction': MemberSpec_('autoStartAction', 'xs:string', 0),
        'autoStopAction': MemberSpec_('autoStopAction', 'xs:string', 0),
        }
    subclass = None
    superclass = Entity
    def __init__(self, autoStartAction=None, autoStopAction=None):
        super(VmGlobalSettings, self).__init__()
        self.autoStartAction = autoStartAction
        self.autoStopAction = autoStopAction
    def factory(*args_, **kwargs_):
        if VmGlobalSettings.subclass:
            return VmGlobalSettings.subclass(*args_, **kwargs_)
        else:
            return VmGlobalSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoStartAction(self): return self.autoStartAction
    def set_autoStartAction(self, autoStartAction): self.autoStartAction = autoStartAction
    autoStartActionProp = property(get_autoStartAction, set_autoStartAction)
    def get_autoStopAction(self): return self.autoStopAction
    def set_autoStopAction(self, autoStopAction): self.autoStopAction = autoStopAction
    autoStopActionProp = property(get_autoStopAction, set_autoStopAction)
    def export(self, outfile, level, namespace_='', name_='VmGlobalSettings', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmGlobalSettings')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmGlobalSettings'):
        super(VmGlobalSettings, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmGlobalSettings')
    def exportChildren(self, outfile, level, namespace_='', name_='VmGlobalSettings', fromsubclass_=False):
        super(VmGlobalSettings, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.autoStartAction is not None:
            showIndent(outfile, level)
            outfile.write('<%sautoStartAction>%s</%sautoStartAction>\n' % (namespace_, self.gds_format_string(quote_xml(self.autoStartAction).encode(ExternalEncoding), input_name='autoStartAction'), namespace_))
        if self.autoStopAction is not None:
            showIndent(outfile, level)
            outfile.write('<%sautoStopAction>%s</%sautoStopAction>\n' % (namespace_, self.gds_format_string(quote_xml(self.autoStopAction).encode(ExternalEncoding), input_name='autoStopAction'), namespace_))
    def hasContent_(self):
        if (
            self.autoStartAction is not None or
            self.autoStopAction is not None or
            super(VmGlobalSettings, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmGlobalSettings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmGlobalSettings, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmGlobalSettings, self).exportLiteralChildren(outfile, level, name_)
        if self.autoStartAction is not None:
            showIndent(outfile, level)
            outfile.write('autoStartAction=%s,\n' % quote_python(self.autoStartAction).encode(ExternalEncoding))
        if self.autoStopAction is not None:
            showIndent(outfile, level)
            outfile.write('autoStopAction=%s,\n' % quote_python(self.autoStopAction).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmGlobalSettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'autoStartAction':
            autoStartAction_ = child_.text
            autoStartAction_ = self.gds_validate_string(autoStartAction_, node, 'autoStartAction')
            self.autoStartAction = autoStartAction_
        elif nodeName_ == 'autoStopAction':
            autoStopAction_ = child_.text
            autoStopAction_ = self.gds_validate_string(autoStopAction_, node, 'autoStopAction')
            self.autoStopAction = autoStopAction_
        super(VmGlobalSettings, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmGlobalSettings.member_data_items_
        if VmGlobalSettings.superclass != None:
            member_items.update(VmGlobalSettings.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmGlobalSettings._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmGlobalSettings()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmGlobalSettings.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmGlobalSettings.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmGlobalSettings


class OsProfile(GeneratedsSuper):
    member_data_items_ = {
        'resourceId': MemberSpec_('resourceId', 'xs:string', 0),
        'osType': MemberSpec_('osType', ['OsTypeEnum', 'xs:string'], 0),
        'osSubType': MemberSpec_('osSubType', 'xs:string', 0),
        'osDescription': MemberSpec_('osDescription', 'xs:string', 0),
        'osName': MemberSpec_('osName', 'xs:string', 0),
        'osVersion': MemberSpec_('osVersion', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, resourceId=None, osType=None, osSubType=None, osDescription=None, osName=None, osVersion=None):
        self.resourceId = resourceId
        self.osType = osType
        self.osSubType = osSubType
        self.osDescription = osDescription
        self.osName = osName
        self.osVersion = osVersion
    def factory(*args_, **kwargs_):
        if OsProfile.subclass:
            return OsProfile.subclass(*args_, **kwargs_)
        else:
            return OsProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceId(self): return self.resourceId
    def set_resourceId(self, resourceId): self.resourceId = resourceId
    resourceIdProp = property(get_resourceId, set_resourceId)
    def get_osType(self): return self.osType
    def set_osType(self, osType): self.osType = osType
    osTypeProp = property(get_osType, set_osType)
    def validate_OsTypeEnum(self, value):
        # Validate type OsTypeEnum, a restriction on xs:string.
        pass
    def get_osSubType(self): return self.osSubType
    def set_osSubType(self, osSubType): self.osSubType = osSubType
    osSubTypeProp = property(get_osSubType, set_osSubType)
    def get_osDescription(self): return self.osDescription
    def set_osDescription(self, osDescription): self.osDescription = osDescription
    osDescriptionProp = property(get_osDescription, set_osDescription)
    def get_osName(self): return self.osName
    def set_osName(self, osName): self.osName = osName
    osNameProp = property(get_osName, set_osName)
    def get_osVersion(self): return self.osVersion
    def set_osVersion(self, osVersion): self.osVersion = osVersion
    osVersionProp = property(get_osVersion, set_osVersion)
    def export(self, outfile, level, namespace_='', name_='OsProfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OsProfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OsProfile'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OsProfile', fromsubclass_=False):
        if self.resourceId is not None:
            showIndent(outfile, level)
            outfile.write('<%sresourceId>%s</%sresourceId>\n' % (namespace_, self.gds_format_string(quote_xml(self.resourceId).encode(ExternalEncoding), input_name='resourceId'), namespace_))
        if self.osType is not None:
            showIndent(outfile, level)
            outfile.write('<%sosType>%s</%sosType>\n' % (namespace_, self.gds_format_string(quote_xml(self.osType).encode(ExternalEncoding), input_name='osType'), namespace_))
        if self.osSubType is not None:
            showIndent(outfile, level)
            outfile.write('<%sosSubType>%s</%sosSubType>\n' % (namespace_, self.gds_format_string(quote_xml(self.osSubType).encode(ExternalEncoding), input_name='osSubType'), namespace_))
        if self.osDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sosDescription>%s</%sosDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.osDescription).encode(ExternalEncoding), input_name='osDescription'), namespace_))
        if self.osName is not None:
            showIndent(outfile, level)
            outfile.write('<%sosName>%s</%sosName>\n' % (namespace_, self.gds_format_string(quote_xml(self.osName).encode(ExternalEncoding), input_name='osName'), namespace_))
        if self.osVersion is not None:
            showIndent(outfile, level)
            outfile.write('<%sosVersion>%s</%sosVersion>\n' % (namespace_, self.gds_format_string(quote_xml(self.osVersion).encode(ExternalEncoding), input_name='osVersion'), namespace_))
    def hasContent_(self):
        if (
            self.resourceId is not None or
            self.osType is not None or
            self.osSubType is not None or
            self.osDescription is not None or
            self.osName is not None or
            self.osVersion is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OsProfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resourceId is not None:
            showIndent(outfile, level)
            outfile.write('resourceId=%s,\n' % quote_python(self.resourceId).encode(ExternalEncoding))
        if self.osType is not None:
            showIndent(outfile, level)
            outfile.write('osType=%s,\n' % quote_python(self.osType).encode(ExternalEncoding))
        if self.osSubType is not None:
            showIndent(outfile, level)
            outfile.write('osSubType=%s,\n' % quote_python(self.osSubType).encode(ExternalEncoding))
        if self.osDescription is not None:
            showIndent(outfile, level)
            outfile.write('osDescription=%s,\n' % quote_python(self.osDescription).encode(ExternalEncoding))
        if self.osName is not None:
            showIndent(outfile, level)
            outfile.write('osName=%s,\n' % quote_python(self.osName).encode(ExternalEncoding))
        if self.osVersion is not None:
            showIndent(outfile, level)
            outfile.write('osVersion=%s,\n' % quote_python(self.osVersion).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resourceId':
            resourceId_ = child_.text
            resourceId_ = self.gds_validate_string(resourceId_, node, 'resourceId')
            self.resourceId = resourceId_
        elif nodeName_ == 'osType':
            osType_ = child_.text
            osType_ = self.gds_validate_string(osType_, node, 'osType')
            self.osType = osType_
            self.validate_OsTypeEnum(self.osType)    # validate type OsTypeEnum
        elif nodeName_ == 'osSubType':
            osSubType_ = child_.text
            osSubType_ = self.gds_validate_string(osSubType_, node, 'osSubType')
            self.osSubType = osSubType_
        elif nodeName_ == 'osDescription':
            osDescription_ = child_.text
            osDescription_ = self.gds_validate_string(osDescription_, node, 'osDescription')
            self.osDescription = osDescription_
        elif nodeName_ == 'osName':
            osName_ = child_.text
            osName_ = self.gds_validate_string(osName_, node, 'osName')
            self.osName = osName_
        elif nodeName_ == 'osVersion':
            osVersion_ = child_.text
            osVersion_ = self.gds_validate_string(osVersion_, node, 'osVersion')
            self.osVersion = osVersion_
    @classmethod
    def get_all_members(cls):
        member_items = OsProfile.member_data_items_
        if OsProfile.superclass != None:
            member_items.update(OsProfile.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return OsProfile._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = OsProfile()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return OsProfile.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = OsProfile.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class OsProfile


class IpProfile(GeneratedsSuper):
    member_data_items_ = {
        'ipAddress': MemberSpec_('ipAddress', 'xs:string', 0),
        'ipType': MemberSpec_('ipType', ['IpTypeEnum', 'xs:string'], 0),
        'hostname': MemberSpec_('hostname', 'xs:string', 0),
        'domain': MemberSpec_('domain', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, ipAddress=None, ipType=None, hostname=None, domain=None):
        self.ipAddress = ipAddress
        self.ipType = ipType
        self.hostname = hostname
        self.domain = domain
    def factory(*args_, **kwargs_):
        if IpProfile.subclass:
            return IpProfile.subclass(*args_, **kwargs_)
        else:
            return IpProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipAddress(self): return self.ipAddress
    def set_ipAddress(self, ipAddress): self.ipAddress = ipAddress
    ipAddressProp = property(get_ipAddress, set_ipAddress)
    def get_ipType(self): return self.ipType
    def set_ipType(self, ipType): self.ipType = ipType
    ipTypeProp = property(get_ipType, set_ipType)
    def validate_IpTypeEnum(self, value):
        # Validate type IpTypeEnum, a restriction on xs:string.
        pass
    def get_hostname(self): return self.hostname
    def set_hostname(self, hostname): self.hostname = hostname
    hostnameProp = property(get_hostname, set_hostname)
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    domainProp = property(get_domain, set_domain)
    def export(self, outfile, level, namespace_='', name_='IpProfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpProfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpProfile'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IpProfile', fromsubclass_=False):
        if self.ipAddress is not None:
            showIndent(outfile, level)
            outfile.write('<%sipAddress>%s</%sipAddress>\n' % (namespace_, self.gds_format_string(quote_xml(self.ipAddress).encode(ExternalEncoding), input_name='ipAddress'), namespace_))
        if self.ipType is not None:
            showIndent(outfile, level)
            outfile.write('<%sipType>%s</%sipType>\n' % (namespace_, self.gds_format_string(quote_xml(self.ipType).encode(ExternalEncoding), input_name='ipType'), namespace_))
        if self.hostname is not None:
            showIndent(outfile, level)
            outfile.write('<%shostname>%s</%shostname>\n' % (namespace_, self.gds_format_string(quote_xml(self.hostname).encode(ExternalEncoding), input_name='hostname'), namespace_))
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('<%sdomain>%s</%sdomain>\n' % (namespace_, self.gds_format_string(quote_xml(self.domain).encode(ExternalEncoding), input_name='domain'), namespace_))
    def hasContent_(self):
        if (
            self.ipAddress is not None or
            self.ipType is not None or
            self.hostname is not None or
            self.domain is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IpProfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ipAddress is not None:
            showIndent(outfile, level)
            outfile.write('ipAddress=%s,\n' % quote_python(self.ipAddress).encode(ExternalEncoding))
        if self.ipType is not None:
            showIndent(outfile, level)
            outfile.write('ipType=%s,\n' % quote_python(self.ipType).encode(ExternalEncoding))
        if self.hostname is not None:
            showIndent(outfile, level)
            outfile.write('hostname=%s,\n' % quote_python(self.hostname).encode(ExternalEncoding))
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('domain=%s,\n' % quote_python(self.domain).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ipAddress':
            ipAddress_ = child_.text
            ipAddress_ = self.gds_validate_string(ipAddress_, node, 'ipAddress')
            self.ipAddress = ipAddress_
        elif nodeName_ == 'ipType':
            ipType_ = child_.text
            ipType_ = self.gds_validate_string(ipType_, node, 'ipType')
            self.ipType = ipType_
            self.validate_IpTypeEnum(self.ipType)    # validate type IpTypeEnum
        elif nodeName_ == 'hostname':
            hostname_ = child_.text
            hostname_ = self.gds_validate_string(hostname_, node, 'hostname')
            self.hostname = hostname_
        elif nodeName_ == 'domain':
            domain_ = child_.text
            domain_ = self.gds_validate_string(domain_, node, 'domain')
            self.domain = domain_
    @classmethod
    def get_all_members(cls):
        member_items = IpProfile.member_data_items_
        if IpProfile.superclass != None:
            member_items.update(IpProfile.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return IpProfile._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = IpProfile()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return IpProfile.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = IpProfile.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class IpProfile


class VmNetAdapter(Resource):
    member_data_items_ = {
        'addressType': MemberSpec_('addressType', 'xs:string', 0),
        'adapterType': MemberSpec_('adapterType', 'xs:string', 0),
        'switchType': MemberSpec_('switchType', 'xs:string', 0),
        'macAddress': MemberSpec_('macAddress', 'xs:string', 0),
        'ipAddresses': MemberSpec_('ipAddresses', 'xs:string', 1),
        'networkName': MemberSpec_('networkName', 'xs:string', 0),
        'vlanId': MemberSpec_('vlanId', 'xs:string', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, addressType=None, adapterType=None, switchType=None, macAddress=None, ipAddresses=None, networkName=None, vlanId=None):
        super(VmNetAdapter, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.addressType = addressType
        self.adapterType = adapterType
        self.switchType = switchType
        self.macAddress = macAddress
        if ipAddresses is None:
            self.ipAddresses = []
        else:
            self.ipAddresses = ipAddresses
        self.networkName = networkName
        self.vlanId = vlanId
    def factory(*args_, **kwargs_):
        if VmNetAdapter.subclass:
            return VmNetAdapter.subclass(*args_, **kwargs_)
        else:
            return VmNetAdapter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_addressType(self): return self.addressType
    def set_addressType(self, addressType): self.addressType = addressType
    addressTypeProp = property(get_addressType, set_addressType)
    def get_adapterType(self): return self.adapterType
    def set_adapterType(self, adapterType): self.adapterType = adapterType
    adapterTypeProp = property(get_adapterType, set_adapterType)
    def get_switchType(self): return self.switchType
    def set_switchType(self, switchType): self.switchType = switchType
    switchTypeProp = property(get_switchType, set_switchType)
    def get_macAddress(self): return self.macAddress
    def set_macAddress(self, macAddress): self.macAddress = macAddress
    macAddressProp = property(get_macAddress, set_macAddress)
    def get_ipAddresses(self): return self.ipAddresses
    def set_ipAddresses(self, ipAddresses): self.ipAddresses = ipAddresses
    def add_ipAddresses(self, value): self.ipAddresses.append(value)
    def insert_ipAddresses(self, index, value): self.ipAddresses[index] = value
    ipAddressesProp = property(get_ipAddresses, set_ipAddresses)
    def get_networkName(self): return self.networkName
    def set_networkName(self, networkName): self.networkName = networkName
    networkNameProp = property(get_networkName, set_networkName)
    def get_vlanId(self): return self.vlanId
    def set_vlanId(self, vlanId): self.vlanId = vlanId
    vlanIdProp = property(get_vlanId, set_vlanId)
    def export(self, outfile, level, namespace_='', name_='VmNetAdapter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmNetAdapter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmNetAdapter'):
        super(VmNetAdapter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmNetAdapter')
    def exportChildren(self, outfile, level, namespace_='', name_='VmNetAdapter', fromsubclass_=False):
        super(VmNetAdapter, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.addressType is not None:
            showIndent(outfile, level)
            outfile.write('<%saddressType>%s</%saddressType>\n' % (namespace_, self.gds_format_string(quote_xml(self.addressType).encode(ExternalEncoding), input_name='addressType'), namespace_))
        if self.adapterType is not None:
            showIndent(outfile, level)
            outfile.write('<%sadapterType>%s</%sadapterType>\n' % (namespace_, self.gds_format_string(quote_xml(self.adapterType).encode(ExternalEncoding), input_name='adapterType'), namespace_))
        if self.switchType is not None:
            showIndent(outfile, level)
            outfile.write('<%sswitchType>%s</%sswitchType>\n' % (namespace_, self.gds_format_string(quote_xml(self.switchType).encode(ExternalEncoding), input_name='switchType'), namespace_))
        if self.macAddress is not None:
            showIndent(outfile, level)
            outfile.write('<%smacAddress>%s</%smacAddress>\n' % (namespace_, self.gds_format_string(quote_xml(self.macAddress).encode(ExternalEncoding), input_name='macAddress'), namespace_))
        for ipAddresses_ in self.ipAddresses:
            showIndent(outfile, level)
            outfile.write('<%sipAddresses>%s</%sipAddresses>\n' % (namespace_, self.gds_format_string(quote_xml(ipAddresses_).encode(ExternalEncoding), input_name='ipAddresses'), namespace_))
        if self.networkName is not None:
            showIndent(outfile, level)
            outfile.write('<%snetworkName>%s</%snetworkName>\n' % (namespace_, self.gds_format_string(quote_xml(self.networkName).encode(ExternalEncoding), input_name='networkName'), namespace_))
        if self.vlanId is not None:
            showIndent(outfile, level)
            outfile.write('<%svlanId>%s</%svlanId>\n' % (namespace_, self.gds_format_string(quote_xml(self.vlanId).encode(ExternalEncoding), input_name='vlanId'), namespace_))
    def hasContent_(self):
        if (
            self.addressType is not None or
            self.adapterType is not None or
            self.switchType is not None or
            self.macAddress is not None or
            self.ipAddresses or
            self.networkName is not None or
            self.vlanId is not None or
            super(VmNetAdapter, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmNetAdapter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmNetAdapter, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmNetAdapter, self).exportLiteralChildren(outfile, level, name_)
        if self.addressType is not None:
            showIndent(outfile, level)
            outfile.write('addressType=%s,\n' % quote_python(self.addressType).encode(ExternalEncoding))
        if self.adapterType is not None:
            showIndent(outfile, level)
            outfile.write('adapterType=%s,\n' % quote_python(self.adapterType).encode(ExternalEncoding))
        if self.switchType is not None:
            showIndent(outfile, level)
            outfile.write('switchType=%s,\n' % quote_python(self.switchType).encode(ExternalEncoding))
        if self.macAddress is not None:
            showIndent(outfile, level)
            outfile.write('macAddress=%s,\n' % quote_python(self.macAddress).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ipAddresses=[\n')
        level += 1
        for ipAddresses_ in self.ipAddresses:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ipAddresses_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.networkName is not None:
            showIndent(outfile, level)
            outfile.write('networkName=%s,\n' % quote_python(self.networkName).encode(ExternalEncoding))
        if self.vlanId is not None:
            showIndent(outfile, level)
            outfile.write('vlanId=%s,\n' % quote_python(self.vlanId).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmNetAdapter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'addressType':
            addressType_ = child_.text
            addressType_ = self.gds_validate_string(addressType_, node, 'addressType')
            self.addressType = addressType_
        elif nodeName_ == 'adapterType':
            adapterType_ = child_.text
            adapterType_ = self.gds_validate_string(adapterType_, node, 'adapterType')
            self.adapterType = adapterType_
        elif nodeName_ == 'switchType':
            switchType_ = child_.text
            switchType_ = self.gds_validate_string(switchType_, node, 'switchType')
            self.switchType = switchType_
        elif nodeName_ == 'macAddress':
            macAddress_ = child_.text
            macAddress_ = self.gds_validate_string(macAddress_, node, 'macAddress')
            self.macAddress = macAddress_
        elif nodeName_ == 'ipAddresses':
            ipAddresses_ = child_.text
            ipAddresses_ = self.gds_validate_string(ipAddresses_, node, 'ipAddresses')
            self.ipAddresses.append(ipAddresses_)
        elif nodeName_ == 'networkName':
            networkName_ = child_.text
            networkName_ = self.gds_validate_string(networkName_, node, 'networkName')
            self.networkName = networkName_
        elif nodeName_ == 'vlanId':
            vlanId_ = child_.text
            vlanId_ = self.gds_validate_string(vlanId_, node, 'vlanId')
            self.vlanId = vlanId_
        super(VmNetAdapter, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmNetAdapter.member_data_items_
        if VmNetAdapter.superclass != None:
            member_items.update(VmNetAdapter.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmNetAdapter._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmNetAdapter()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmNetAdapter.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmNetAdapter.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmNetAdapter


class VmScsiController(Resource):
    member_data_items_ = {
        'controllerId': MemberSpec_('controllerId', 'xs:int', 0),
        'controllerName': MemberSpec_('controllerName', 'xs:string', 0),
        'type_': MemberSpec_('type_', 'xs:string', 0),
        'busSharing': MemberSpec_('busSharing', 'xs:string', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, controllerId=None, controllerName=None, type_=None, busSharing=None):
        super(VmScsiController, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.controllerId = controllerId
        self.controllerName = controllerName
        self.type_ = type_
        self.busSharing = busSharing
    def factory(*args_, **kwargs_):
        if VmScsiController.subclass:
            return VmScsiController.subclass(*args_, **kwargs_)
        else:
            return VmScsiController(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_controllerId(self): return self.controllerId
    def set_controllerId(self, controllerId): self.controllerId = controllerId
    controllerIdProp = property(get_controllerId, set_controllerId)
    def get_controllerName(self): return self.controllerName
    def set_controllerName(self, controllerName): self.controllerName = controllerName
    controllerNameProp = property(get_controllerName, set_controllerName)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_busSharing(self): return self.busSharing
    def set_busSharing(self, busSharing): self.busSharing = busSharing
    busSharingProp = property(get_busSharing, set_busSharing)
    def export(self, outfile, level, namespace_='', name_='VmScsiController', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmScsiController')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmScsiController'):
        super(VmScsiController, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmScsiController')
    def exportChildren(self, outfile, level, namespace_='', name_='VmScsiController', fromsubclass_=False):
        super(VmScsiController, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.controllerId is not None:
            showIndent(outfile, level)
            outfile.write('<%scontrollerId>%s</%scontrollerId>\n' % (namespace_, self.gds_format_integer(self.controllerId, input_name='controllerId'), namespace_))
        if self.controllerName is not None:
            showIndent(outfile, level)
            outfile.write('<%scontrollerName>%s</%scontrollerName>\n' % (namespace_, self.gds_format_string(quote_xml(self.controllerName).encode(ExternalEncoding), input_name='controllerName'), namespace_))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
        if self.busSharing is not None:
            showIndent(outfile, level)
            outfile.write('<%sbusSharing>%s</%sbusSharing>\n' % (namespace_, self.gds_format_string(quote_xml(self.busSharing).encode(ExternalEncoding), input_name='busSharing'), namespace_))
    def hasContent_(self):
        if (
            self.controllerId is not None or
            self.controllerName is not None or
            self.type_ is not None or
            self.busSharing is not None or
            super(VmScsiController, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmScsiController'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmScsiController, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmScsiController, self).exportLiteralChildren(outfile, level, name_)
        if self.controllerId is not None:
            showIndent(outfile, level)
            outfile.write('controllerId=%d,\n' % self.controllerId)
        if self.controllerName is not None:
            showIndent(outfile, level)
            outfile.write('controllerName=%s,\n' % quote_python(self.controllerName).encode(ExternalEncoding))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.busSharing is not None:
            showIndent(outfile, level)
            outfile.write('busSharing=%s,\n' % quote_python(self.busSharing).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmScsiController, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'controllerId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'controllerId')
            self.controllerId = ival_
        elif nodeName_ == 'controllerName':
            controllerName_ = child_.text
            controllerName_ = self.gds_validate_string(controllerName_, node, 'controllerName')
            self.controllerName = controllerName_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'busSharing':
            busSharing_ = child_.text
            busSharing_ = self.gds_validate_string(busSharing_, node, 'busSharing')
            self.busSharing = busSharing_
        super(VmScsiController, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmScsiController.member_data_items_
        if VmScsiController.superclass != None:
            member_items.update(VmScsiController.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmScsiController._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmScsiController()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmScsiController.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmScsiController.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmScsiController


class VmDisk(Resource):
    member_data_items_ = {
        'controllerType': MemberSpec_('controllerType', 'xs:string', 0),
        'controllerId': MemberSpec_('controllerId', 'xs:int', 0),
        'channel': MemberSpec_('channel', 'xs:int', 0),
        'fileName': MemberSpec_('fileName', 'xs:string', 0),
        'mode': MemberSpec_('mode', 'xs:string', 0),
        'diskSize': MemberSpec_('diskSize', 'xs:long', 0),
        'fileSize': MemberSpec_('fileSize', 'xs:long', 0),
        'rdmDiskProfile': MemberSpec_('rdmDiskProfile', 'RdmDiskProfile', 0),
        'storageVolumeId': MemberSpec_('storageVolumeId', 'xs:string', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, controllerType=None, controllerId=None, channel=None, fileName=None, mode=None, diskSize=None, fileSize=None, rdmDiskProfile=None, storageVolumeId=None):
        super(VmDisk, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.controllerType = controllerType
        self.controllerId = controllerId
        self.channel = channel
        self.fileName = fileName
        self.mode = mode
        self.diskSize = diskSize
        self.fileSize = fileSize
        self.rdmDiskProfile = rdmDiskProfile
        self.storageVolumeId = storageVolumeId
    def factory(*args_, **kwargs_):
        if VmDisk.subclass:
            return VmDisk.subclass(*args_, **kwargs_)
        else:
            return VmDisk(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_controllerType(self): return self.controllerType
    def set_controllerType(self, controllerType): self.controllerType = controllerType
    controllerTypeProp = property(get_controllerType, set_controllerType)
    def get_controllerId(self): return self.controllerId
    def set_controllerId(self, controllerId): self.controllerId = controllerId
    controllerIdProp = property(get_controllerId, set_controllerId)
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    channelProp = property(get_channel, set_channel)
    def get_fileName(self): return self.fileName
    def set_fileName(self, fileName): self.fileName = fileName
    fileNameProp = property(get_fileName, set_fileName)
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    modeProp = property(get_mode, set_mode)
    def get_diskSize(self): return self.diskSize
    def set_diskSize(self, diskSize): self.diskSize = diskSize
    diskSizeProp = property(get_diskSize, set_diskSize)
    def get_fileSize(self): return self.fileSize
    def set_fileSize(self, fileSize): self.fileSize = fileSize
    fileSizeProp = property(get_fileSize, set_fileSize)
    def get_rdmDiskProfile(self): return self.rdmDiskProfile
    def set_rdmDiskProfile(self, rdmDiskProfile): self.rdmDiskProfile = rdmDiskProfile
    rdmDiskProfileProp = property(get_rdmDiskProfile, set_rdmDiskProfile)
    def get_storageVolumeId(self): return self.storageVolumeId
    def set_storageVolumeId(self, storageVolumeId): self.storageVolumeId = storageVolumeId
    storageVolumeIdProp = property(get_storageVolumeId, set_storageVolumeId)
    def export(self, outfile, level, namespace_='', name_='VmDisk', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmDisk')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmDisk'):
        super(VmDisk, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmDisk')
    def exportChildren(self, outfile, level, namespace_='', name_='VmDisk', fromsubclass_=False):
        super(VmDisk, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.controllerType is not None:
            showIndent(outfile, level)
            outfile.write('<%scontrollerType>%s</%scontrollerType>\n' % (namespace_, self.gds_format_string(quote_xml(self.controllerType).encode(ExternalEncoding), input_name='controllerType'), namespace_))
        if self.controllerId is not None:
            showIndent(outfile, level)
            outfile.write('<%scontrollerId>%s</%scontrollerId>\n' % (namespace_, self.gds_format_integer(self.controllerId, input_name='controllerId'), namespace_))
        if self.channel is not None:
            showIndent(outfile, level)
            outfile.write('<%schannel>%s</%schannel>\n' % (namespace_, self.gds_format_integer(self.channel, input_name='channel'), namespace_))
        if self.fileName is not None:
            showIndent(outfile, level)
            outfile.write('<%sfileName>%s</%sfileName>\n' % (namespace_, self.gds_format_string(quote_xml(self.fileName).encode(ExternalEncoding), input_name='fileName'), namespace_))
        if self.mode is not None:
            showIndent(outfile, level)
            outfile.write('<%smode>%s</%smode>\n' % (namespace_, self.gds_format_string(quote_xml(self.mode).encode(ExternalEncoding), input_name='mode'), namespace_))
        if self.diskSize is not None:
            showIndent(outfile, level)
            outfile.write('<%sdiskSize>%s</%sdiskSize>\n' % (namespace_, self.gds_format_integer(self.diskSize, input_name='diskSize'), namespace_))
        if self.fileSize is not None:
            showIndent(outfile, level)
            outfile.write('<%sfileSize>%s</%sfileSize>\n' % (namespace_, self.gds_format_integer(self.fileSize, input_name='fileSize'), namespace_))
        if self.rdmDiskProfile is not None:
            self.rdmDiskProfile.export(outfile, level, namespace_, name_='rdmDiskProfile')
        if self.storageVolumeId is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageVolumeId>%s</%sstorageVolumeId>\n' % (namespace_, self.gds_format_string(quote_xml(self.storageVolumeId).encode(ExternalEncoding), input_name='storageVolumeId'), namespace_))
    def hasContent_(self):
        if (
            self.controllerType is not None or
            self.controllerId is not None or
            self.channel is not None or
            self.fileName is not None or
            self.mode is not None or
            self.diskSize is not None or
            self.fileSize is not None or
            self.rdmDiskProfile is not None or
            self.storageVolumeId is not None or
            super(VmDisk, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmDisk'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmDisk, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmDisk, self).exportLiteralChildren(outfile, level, name_)
        if self.controllerType is not None:
            showIndent(outfile, level)
            outfile.write('controllerType=%s,\n' % quote_python(self.controllerType).encode(ExternalEncoding))
        if self.controllerId is not None:
            showIndent(outfile, level)
            outfile.write('controllerId=%d,\n' % self.controllerId)
        if self.channel is not None:
            showIndent(outfile, level)
            outfile.write('channel=%d,\n' % self.channel)
        if self.fileName is not None:
            showIndent(outfile, level)
            outfile.write('fileName=%s,\n' % quote_python(self.fileName).encode(ExternalEncoding))
        if self.mode is not None:
            showIndent(outfile, level)
            outfile.write('mode=%s,\n' % quote_python(self.mode).encode(ExternalEncoding))
        if self.diskSize is not None:
            showIndent(outfile, level)
            outfile.write('diskSize=%d,\n' % self.diskSize)
        if self.fileSize is not None:
            showIndent(outfile, level)
            outfile.write('fileSize=%d,\n' % self.fileSize)
        if self.rdmDiskProfile is not None:
            showIndent(outfile, level)
            outfile.write('rdmDiskProfile=model_.RdmDiskProfile(\n')
            self.rdmDiskProfile.exportLiteral(outfile, level, name_='rdmDiskProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.storageVolumeId is not None:
            showIndent(outfile, level)
            outfile.write('storageVolumeId=%s,\n' % quote_python(self.storageVolumeId).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmDisk, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'controllerType':
            controllerType_ = child_.text
            controllerType_ = self.gds_validate_string(controllerType_, node, 'controllerType')
            self.controllerType = controllerType_
        elif nodeName_ == 'controllerId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'controllerId')
            self.controllerId = ival_
        elif nodeName_ == 'channel':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'channel')
            self.channel = ival_
        elif nodeName_ == 'fileName':
            fileName_ = child_.text
            fileName_ = self.gds_validate_string(fileName_, node, 'fileName')
            self.fileName = fileName_
        elif nodeName_ == 'mode':
            mode_ = child_.text
            mode_ = self.gds_validate_string(mode_, node, 'mode')
            self.mode = mode_
        elif nodeName_ == 'diskSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'diskSize')
            self.diskSize = ival_
        elif nodeName_ == 'fileSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fileSize')
            self.fileSize = ival_
        elif nodeName_ == 'rdmDiskProfile':
            obj_ = RdmDiskProfile.factory()
            obj_.build(child_)
            self.set_rdmDiskProfile(obj_)
        elif nodeName_ == 'storageVolumeId':
            storageVolumeId_ = child_.text
            storageVolumeId_ = self.gds_validate_string(storageVolumeId_, node, 'storageVolumeId')
            self.storageVolumeId = storageVolumeId_
        super(VmDisk, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmDisk.member_data_items_
        if VmDisk.superclass != None:
            member_items.update(VmDisk.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmDisk._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmDisk()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmDisk.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmDisk.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmDisk


class RdmDiskProfile(GeneratedsSuper):
    member_data_items_ = {
        'lunId': MemberSpec_('lunId', 'xs:string', 0),
        'deviceDescription': MemberSpec_('deviceDescription', 'xs:string', 0),
        'hostHbaNodeWwn': MemberSpec_('hostHbaNodeWwn', 'xs:string', 0),
        'hostHbaPortWwn': MemberSpec_('hostHbaPortWwn', 'xs:string', 0),
        'npivNodeWwns': MemberSpec_('npivNodeWwns', 'xs:string', 1),
        'npivPortWwns': MemberSpec_('npivPortWwns', 'xs:string', 1),
        'compatibilityMode': MemberSpec_('compatibilityMode', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, lunId=None, deviceDescription=None, hostHbaNodeWwn=None, hostHbaPortWwn=None, npivNodeWwns=None, npivPortWwns=None, compatibilityMode=None):
        self.lunId = lunId
        self.deviceDescription = deviceDescription
        self.hostHbaNodeWwn = hostHbaNodeWwn
        self.hostHbaPortWwn = hostHbaPortWwn
        if npivNodeWwns is None:
            self.npivNodeWwns = []
        else:
            self.npivNodeWwns = npivNodeWwns
        if npivPortWwns is None:
            self.npivPortWwns = []
        else:
            self.npivPortWwns = npivPortWwns
        self.compatibilityMode = compatibilityMode
    def factory(*args_, **kwargs_):
        if RdmDiskProfile.subclass:
            return RdmDiskProfile.subclass(*args_, **kwargs_)
        else:
            return RdmDiskProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lunId(self): return self.lunId
    def set_lunId(self, lunId): self.lunId = lunId
    lunIdProp = property(get_lunId, set_lunId)
    def get_deviceDescription(self): return self.deviceDescription
    def set_deviceDescription(self, deviceDescription): self.deviceDescription = deviceDescription
    deviceDescriptionProp = property(get_deviceDescription, set_deviceDescription)
    def get_hostHbaNodeWwn(self): return self.hostHbaNodeWwn
    def set_hostHbaNodeWwn(self, hostHbaNodeWwn): self.hostHbaNodeWwn = hostHbaNodeWwn
    hostHbaNodeWwnProp = property(get_hostHbaNodeWwn, set_hostHbaNodeWwn)
    def get_hostHbaPortWwn(self): return self.hostHbaPortWwn
    def set_hostHbaPortWwn(self, hostHbaPortWwn): self.hostHbaPortWwn = hostHbaPortWwn
    hostHbaPortWwnProp = property(get_hostHbaPortWwn, set_hostHbaPortWwn)
    def get_npivNodeWwns(self): return self.npivNodeWwns
    def set_npivNodeWwns(self, npivNodeWwns): self.npivNodeWwns = npivNodeWwns
    def add_npivNodeWwns(self, value): self.npivNodeWwns.append(value)
    def insert_npivNodeWwns(self, index, value): self.npivNodeWwns[index] = value
    npivNodeWwnsProp = property(get_npivNodeWwns, set_npivNodeWwns)
    def get_npivPortWwns(self): return self.npivPortWwns
    def set_npivPortWwns(self, npivPortWwns): self.npivPortWwns = npivPortWwns
    def add_npivPortWwns(self, value): self.npivPortWwns.append(value)
    def insert_npivPortWwns(self, index, value): self.npivPortWwns[index] = value
    npivPortWwnsProp = property(get_npivPortWwns, set_npivPortWwns)
    def get_compatibilityMode(self): return self.compatibilityMode
    def set_compatibilityMode(self, compatibilityMode): self.compatibilityMode = compatibilityMode
    compatibilityModeProp = property(get_compatibilityMode, set_compatibilityMode)
    def export(self, outfile, level, namespace_='', name_='RdmDiskProfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RdmDiskProfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RdmDiskProfile'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RdmDiskProfile', fromsubclass_=False):
        if self.lunId is not None:
            showIndent(outfile, level)
            outfile.write('<%slunId>%s</%slunId>\n' % (namespace_, self.gds_format_string(quote_xml(self.lunId).encode(ExternalEncoding), input_name='lunId'), namespace_))
        if self.deviceDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sdeviceDescription>%s</%sdeviceDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.deviceDescription).encode(ExternalEncoding), input_name='deviceDescription'), namespace_))
        if self.hostHbaNodeWwn is not None:
            showIndent(outfile, level)
            outfile.write('<%shostHbaNodeWwn>%s</%shostHbaNodeWwn>\n' % (namespace_, self.gds_format_string(quote_xml(self.hostHbaNodeWwn).encode(ExternalEncoding), input_name='hostHbaNodeWwn'), namespace_))
        if self.hostHbaPortWwn is not None:
            showIndent(outfile, level)
            outfile.write('<%shostHbaPortWwn>%s</%shostHbaPortWwn>\n' % (namespace_, self.gds_format_string(quote_xml(self.hostHbaPortWwn).encode(ExternalEncoding), input_name='hostHbaPortWwn'), namespace_))
        for npivNodeWwns_ in self.npivNodeWwns:
            showIndent(outfile, level)
            outfile.write('<%snpivNodeWwns>%s</%snpivNodeWwns>\n' % (namespace_, self.gds_format_string(quote_xml(npivNodeWwns_).encode(ExternalEncoding), input_name='npivNodeWwns'), namespace_))
        for npivPortWwns_ in self.npivPortWwns:
            showIndent(outfile, level)
            outfile.write('<%snpivPortWwns>%s</%snpivPortWwns>\n' % (namespace_, self.gds_format_string(quote_xml(npivPortWwns_).encode(ExternalEncoding), input_name='npivPortWwns'), namespace_))
        if self.compatibilityMode is not None:
            showIndent(outfile, level)
            outfile.write('<%scompatibilityMode>%s</%scompatibilityMode>\n' % (namespace_, self.gds_format_string(quote_xml(self.compatibilityMode).encode(ExternalEncoding), input_name='compatibilityMode'), namespace_))
    def hasContent_(self):
        if (
            self.lunId is not None or
            self.deviceDescription is not None or
            self.hostHbaNodeWwn is not None or
            self.hostHbaPortWwn is not None or
            self.npivNodeWwns or
            self.npivPortWwns or
            self.compatibilityMode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RdmDiskProfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.lunId is not None:
            showIndent(outfile, level)
            outfile.write('lunId=%s,\n' % quote_python(self.lunId).encode(ExternalEncoding))
        if self.deviceDescription is not None:
            showIndent(outfile, level)
            outfile.write('deviceDescription=%s,\n' % quote_python(self.deviceDescription).encode(ExternalEncoding))
        if self.hostHbaNodeWwn is not None:
            showIndent(outfile, level)
            outfile.write('hostHbaNodeWwn=%s,\n' % quote_python(self.hostHbaNodeWwn).encode(ExternalEncoding))
        if self.hostHbaPortWwn is not None:
            showIndent(outfile, level)
            outfile.write('hostHbaPortWwn=%s,\n' % quote_python(self.hostHbaPortWwn).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('npivNodeWwns=[\n')
        level += 1
        for npivNodeWwns_ in self.npivNodeWwns:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(npivNodeWwns_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('npivPortWwns=[\n')
        level += 1
        for npivPortWwns_ in self.npivPortWwns:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(npivPortWwns_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.compatibilityMode is not None:
            showIndent(outfile, level)
            outfile.write('compatibilityMode=%s,\n' % quote_python(self.compatibilityMode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lunId':
            lunId_ = child_.text
            lunId_ = self.gds_validate_string(lunId_, node, 'lunId')
            self.lunId = lunId_
        elif nodeName_ == 'deviceDescription':
            deviceDescription_ = child_.text
            deviceDescription_ = self.gds_validate_string(deviceDescription_, node, 'deviceDescription')
            self.deviceDescription = deviceDescription_
        elif nodeName_ == 'hostHbaNodeWwn':
            hostHbaNodeWwn_ = child_.text
            hostHbaNodeWwn_ = self.gds_validate_string(hostHbaNodeWwn_, node, 'hostHbaNodeWwn')
            self.hostHbaNodeWwn = hostHbaNodeWwn_
        elif nodeName_ == 'hostHbaPortWwn':
            hostHbaPortWwn_ = child_.text
            hostHbaPortWwn_ = self.gds_validate_string(hostHbaPortWwn_, node, 'hostHbaPortWwn')
            self.hostHbaPortWwn = hostHbaPortWwn_
        elif nodeName_ == 'npivNodeWwns':
            npivNodeWwns_ = child_.text
            npivNodeWwns_ = self.gds_validate_string(npivNodeWwns_, node, 'npivNodeWwns')
            self.npivNodeWwns.append(npivNodeWwns_)
        elif nodeName_ == 'npivPortWwns':
            npivPortWwns_ = child_.text
            npivPortWwns_ = self.gds_validate_string(npivPortWwns_, node, 'npivPortWwns')
            self.npivPortWwns.append(npivPortWwns_)
        elif nodeName_ == 'compatibilityMode':
            compatibilityMode_ = child_.text
            compatibilityMode_ = self.gds_validate_string(compatibilityMode_, node, 'compatibilityMode')
            self.compatibilityMode = compatibilityMode_
    @classmethod
    def get_all_members(cls):
        member_items = RdmDiskProfile.member_data_items_
        if RdmDiskProfile.superclass != None:
            member_items.update(RdmDiskProfile.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return RdmDiskProfile._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = RdmDiskProfile()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return RdmDiskProfile.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = RdmDiskProfile.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class RdmDiskProfile


class ResourceAllocation(GeneratedsSuper):
    member_data_items_ = {
        'share': MemberSpec_('share', ['ResourceAllocationShareEnum', 'xs:string'], 0),
        'customShareValue': MemberSpec_('customShareValue', 'xs:int', 0),
        'reservation': MemberSpec_('reservation', 'xs:long', 0),
        'isExpandableReservation': MemberSpec_('isExpandableReservation', 'xs:boolean', 0),
        'limit': MemberSpec_('limit', 'xs:long', 0),
        'isUnlimited': MemberSpec_('isUnlimited', 'xs:boolean', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, share=None, customShareValue=None, reservation=None, isExpandableReservation=None, limit=None, isUnlimited=None):
        self.share = share
        self.customShareValue = customShareValue
        self.reservation = reservation
        self.isExpandableReservation = isExpandableReservation
        self.limit = limit
        self.isUnlimited = isUnlimited
    def factory(*args_, **kwargs_):
        if ResourceAllocation.subclass:
            return ResourceAllocation.subclass(*args_, **kwargs_)
        else:
            return ResourceAllocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_share(self): return self.share
    def set_share(self, share): self.share = share
    shareProp = property(get_share, set_share)
    def validate_ResourceAllocationShareEnum(self, value):
        # Validate type ResourceAllocationShareEnum, a restriction on xs:string.
        pass
    def get_customShareValue(self): return self.customShareValue
    def set_customShareValue(self, customShareValue): self.customShareValue = customShareValue
    customShareValueProp = property(get_customShareValue, set_customShareValue)
    def get_reservation(self): return self.reservation
    def set_reservation(self, reservation): self.reservation = reservation
    reservationProp = property(get_reservation, set_reservation)
    def get_isExpandableReservation(self): return self.isExpandableReservation
    def set_isExpandableReservation(self, isExpandableReservation): self.isExpandableReservation = isExpandableReservation
    isExpandableReservationProp = property(get_isExpandableReservation, set_isExpandableReservation)
    def get_limit(self): return self.limit
    def set_limit(self, limit): self.limit = limit
    limitProp = property(get_limit, set_limit)
    def get_isUnlimited(self): return self.isUnlimited
    def set_isUnlimited(self, isUnlimited): self.isUnlimited = isUnlimited
    isUnlimitedProp = property(get_isUnlimited, set_isUnlimited)
    def export(self, outfile, level, namespace_='', name_='ResourceAllocation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceAllocation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceAllocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceAllocation', fromsubclass_=False):
        if self.share is not None:
            showIndent(outfile, level)
            outfile.write('<%sshare>%s</%sshare>\n' % (namespace_, self.gds_format_string(quote_xml(self.share).encode(ExternalEncoding), input_name='share'), namespace_))
        if self.customShareValue is not None:
            showIndent(outfile, level)
            outfile.write('<%scustomShareValue>%s</%scustomShareValue>\n' % (namespace_, self.gds_format_integer(self.customShareValue, input_name='customShareValue'), namespace_))
        if self.reservation is not None:
            showIndent(outfile, level)
            outfile.write('<%sreservation>%s</%sreservation>\n' % (namespace_, self.gds_format_integer(self.reservation, input_name='reservation'), namespace_))
        if self.isExpandableReservation is not None:
            showIndent(outfile, level)
            outfile.write('<%sisExpandableReservation>%s</%sisExpandableReservation>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isExpandableReservation)), input_name='isExpandableReservation'), namespace_))
        if self.limit is not None:
            showIndent(outfile, level)
            outfile.write('<%slimit>%s</%slimit>\n' % (namespace_, self.gds_format_integer(self.limit, input_name='limit'), namespace_))
        if self.isUnlimited is not None:
            showIndent(outfile, level)
            outfile.write('<%sisUnlimited>%s</%sisUnlimited>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isUnlimited)), input_name='isUnlimited'), namespace_))
    def hasContent_(self):
        if (
            self.share is not None or
            self.customShareValue is not None or
            self.reservation is not None or
            self.isExpandableReservation is not None or
            self.limit is not None or
            self.isUnlimited is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResourceAllocation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.share is not None:
            showIndent(outfile, level)
            outfile.write('share=%s,\n' % quote_python(self.share).encode(ExternalEncoding))
        if self.customShareValue is not None:
            showIndent(outfile, level)
            outfile.write('customShareValue=%d,\n' % self.customShareValue)
        if self.reservation is not None:
            showIndent(outfile, level)
            outfile.write('reservation=%d,\n' % self.reservation)
        if self.isExpandableReservation is not None:
            showIndent(outfile, level)
            outfile.write('isExpandableReservation=%s,\n' % self.isExpandableReservation)
        if self.limit is not None:
            showIndent(outfile, level)
            outfile.write('limit=%d,\n' % self.limit)
        if self.isUnlimited is not None:
            showIndent(outfile, level)
            outfile.write('isUnlimited=%s,\n' % self.isUnlimited)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'share':
            share_ = child_.text
            share_ = self.gds_validate_string(share_, node, 'share')
            self.share = share_
            self.validate_ResourceAllocationShareEnum(self.share)    # validate type ResourceAllocationShareEnum
        elif nodeName_ == 'customShareValue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'customShareValue')
            self.customShareValue = ival_
        elif nodeName_ == 'reservation':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reservation')
            self.reservation = ival_
        elif nodeName_ == 'isExpandableReservation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isExpandableReservation')
            self.isExpandableReservation = ival_
        elif nodeName_ == 'limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'limit')
            self.limit = ival_
        elif nodeName_ == 'isUnlimited':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isUnlimited')
            self.isUnlimited = ival_
    @classmethod
    def get_all_members(cls):
        member_items = ResourceAllocation.member_data_items_
        if ResourceAllocation.superclass != None:
            member_items.update(ResourceAllocation.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return ResourceAllocation._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = ResourceAllocation()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return ResourceAllocation.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = ResourceAllocation.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class ResourceAllocation


class ExtensibleRaidLevel(GeneratedsSuper):
    member_data_items_ = {
        'raidLevelEnum': MemberSpec_('raidLevelEnum', ['RaidLevelEnum', 'xs:string'], 0),
        'extendedRaidLevel': MemberSpec_('extendedRaidLevel', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, raidLevelEnum=None, extendedRaidLevel=None):
        self.raidLevelEnum = raidLevelEnum
        self.extendedRaidLevel = extendedRaidLevel
    def factory(*args_, **kwargs_):
        if ExtensibleRaidLevel.subclass:
            return ExtensibleRaidLevel.subclass(*args_, **kwargs_)
        else:
            return ExtensibleRaidLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_raidLevelEnum(self): return self.raidLevelEnum
    def set_raidLevelEnum(self, raidLevelEnum): self.raidLevelEnum = raidLevelEnum
    raidLevelEnumProp = property(get_raidLevelEnum, set_raidLevelEnum)
    def validate_RaidLevelEnum(self, value):
        # Validate type RaidLevelEnum, a restriction on xs:string.
        pass
    def get_extendedRaidLevel(self): return self.extendedRaidLevel
    def set_extendedRaidLevel(self, extendedRaidLevel): self.extendedRaidLevel = extendedRaidLevel
    extendedRaidLevelProp = property(get_extendedRaidLevel, set_extendedRaidLevel)
    def export(self, outfile, level, namespace_='', name_='ExtensibleRaidLevel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtensibleRaidLevel')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExtensibleRaidLevel'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExtensibleRaidLevel', fromsubclass_=False):
        if self.raidLevelEnum is not None:
            showIndent(outfile, level)
            outfile.write('<%sraidLevelEnum>%s</%sraidLevelEnum>\n' % (namespace_, self.gds_format_string(quote_xml(self.raidLevelEnum).encode(ExternalEncoding), input_name='raidLevelEnum'), namespace_))
        if self.extendedRaidLevel is not None:
            showIndent(outfile, level)
            outfile.write('<%sextendedRaidLevel>%s</%sextendedRaidLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.extendedRaidLevel).encode(ExternalEncoding), input_name='extendedRaidLevel'), namespace_))
    def hasContent_(self):
        if (
            self.raidLevelEnum is not None or
            self.extendedRaidLevel is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExtensibleRaidLevel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.raidLevelEnum is not None:
            showIndent(outfile, level)
            outfile.write('raidLevelEnum=%s,\n' % quote_python(self.raidLevelEnum).encode(ExternalEncoding))
        if self.extendedRaidLevel is not None:
            showIndent(outfile, level)
            outfile.write('extendedRaidLevel=%s,\n' % quote_python(self.extendedRaidLevel).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'raidLevelEnum':
            raidLevelEnum_ = child_.text
            raidLevelEnum_ = self.gds_validate_string(raidLevelEnum_, node, 'raidLevelEnum')
            self.raidLevelEnum = raidLevelEnum_
            self.validate_RaidLevelEnum(self.raidLevelEnum)    # validate type RaidLevelEnum
        elif nodeName_ == 'extendedRaidLevel':
            extendedRaidLevel_ = child_.text
            extendedRaidLevel_ = self.gds_validate_string(extendedRaidLevel_, node, 'extendedRaidLevel')
            self.extendedRaidLevel = extendedRaidLevel_
    @classmethod
    def get_all_members(cls):
        member_items = ExtensibleRaidLevel.member_data_items_
        if ExtensibleRaidLevel.superclass != None:
            member_items.update(ExtensibleRaidLevel.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return ExtensibleRaidLevel._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = ExtensibleRaidLevel()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return ExtensibleRaidLevel.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = ExtensibleRaidLevel.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class ExtensibleRaidLevel


class HostMountPoint(GeneratedsSuper):
    member_data_items_ = {
        'path': MemberSpec_('path', 'xs:string', 0),
        'vmHostId': MemberSpec_('vmHostId', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, path=None, vmHostId=None):
        self.path = path
        self.vmHostId = vmHostId
    def factory(*args_, **kwargs_):
        if HostMountPoint.subclass:
            return HostMountPoint.subclass(*args_, **kwargs_)
        else:
            return HostMountPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    pathProp = property(get_path, set_path)
    def get_vmHostId(self): return self.vmHostId
    def set_vmHostId(self, vmHostId): self.vmHostId = vmHostId
    vmHostIdProp = property(get_vmHostId, set_vmHostId)
    def export(self, outfile, level, namespace_='', name_='HostMountPoint', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HostMountPoint')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HostMountPoint'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HostMountPoint', fromsubclass_=False):
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.gds_format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.vmHostId is not None:
            showIndent(outfile, level)
            outfile.write('<%svmHostId>%s</%svmHostId>\n' % (namespace_, self.gds_format_string(quote_xml(self.vmHostId).encode(ExternalEncoding), input_name='vmHostId'), namespace_))
    def hasContent_(self):
        if (
            self.path is not None or
            self.vmHostId is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HostMountPoint'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.vmHostId is not None:
            showIndent(outfile, level)
            outfile.write('vmHostId=%s,\n' % quote_python(self.vmHostId).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'path':
            path_ = child_.text
            path_ = self.gds_validate_string(path_, node, 'path')
            self.path = path_
        elif nodeName_ == 'vmHostId':
            vmHostId_ = child_.text
            vmHostId_ = self.gds_validate_string(vmHostId_, node, 'vmHostId')
            self.vmHostId = vmHostId_
    @classmethod
    def get_all_members(cls):
        member_items = HostMountPoint.member_data_items_
        if HostMountPoint.superclass != None:
            member_items.update(HostMountPoint.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return HostMountPoint._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = HostMountPoint()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return HostMountPoint.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = HostMountPoint.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class HostMountPoint


class VmClusterCapabilities(Resource):
    member_data_items_ = {
        'haEnabled': MemberSpec_('haEnabled', 'xs:boolean', 0),
        'drsEnabled': MemberSpec_('drsEnabled', 'xs:boolean', 0),
        'dpmEnabled': MemberSpec_('dpmEnabled', 'xs:boolean', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, haEnabled=None, drsEnabled=None, dpmEnabled=None):
        super(VmClusterCapabilities, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.haEnabled = haEnabled
        self.drsEnabled = drsEnabled
        self.dpmEnabled = dpmEnabled
    def factory(*args_, **kwargs_):
        if VmClusterCapabilities.subclass:
            return VmClusterCapabilities.subclass(*args_, **kwargs_)
        else:
            return VmClusterCapabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_haEnabled(self): return self.haEnabled
    def set_haEnabled(self, haEnabled): self.haEnabled = haEnabled
    haEnabledProp = property(get_haEnabled, set_haEnabled)
    def get_drsEnabled(self): return self.drsEnabled
    def set_drsEnabled(self, drsEnabled): self.drsEnabled = drsEnabled
    drsEnabledProp = property(get_drsEnabled, set_drsEnabled)
    def get_dpmEnabled(self): return self.dpmEnabled
    def set_dpmEnabled(self, dpmEnabled): self.dpmEnabled = dpmEnabled
    dpmEnabledProp = property(get_dpmEnabled, set_dpmEnabled)
    def export(self, outfile, level, namespace_='', name_='VmClusterCapabilities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmClusterCapabilities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmClusterCapabilities'):
        super(VmClusterCapabilities, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmClusterCapabilities')
    def exportChildren(self, outfile, level, namespace_='', name_='VmClusterCapabilities', fromsubclass_=False):
        super(VmClusterCapabilities, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.haEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%shaEnabled>%s</%shaEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.haEnabled)), input_name='haEnabled'), namespace_))
        if self.drsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sdrsEnabled>%s</%sdrsEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.drsEnabled)), input_name='drsEnabled'), namespace_))
        if self.dpmEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sdpmEnabled>%s</%sdpmEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.dpmEnabled)), input_name='dpmEnabled'), namespace_))
    def hasContent_(self):
        if (
            self.haEnabled is not None or
            self.drsEnabled is not None or
            self.dpmEnabled is not None or
            super(VmClusterCapabilities, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmClusterCapabilities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmClusterCapabilities, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmClusterCapabilities, self).exportLiteralChildren(outfile, level, name_)
        if self.haEnabled is not None:
            showIndent(outfile, level)
            outfile.write('haEnabled=%s,\n' % self.haEnabled)
        if self.drsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('drsEnabled=%s,\n' % self.drsEnabled)
        if self.dpmEnabled is not None:
            showIndent(outfile, level)
            outfile.write('dpmEnabled=%s,\n' % self.dpmEnabled)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmClusterCapabilities, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'haEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'haEnabled')
            self.haEnabled = ival_
        elif nodeName_ == 'drsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'drsEnabled')
            self.drsEnabled = ival_
        elif nodeName_ == 'dpmEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'dpmEnabled')
            self.dpmEnabled = ival_
        super(VmClusterCapabilities, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmClusterCapabilities.member_data_items_
        if VmClusterCapabilities.superclass != None:
            member_items.update(VmClusterCapabilities.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmClusterCapabilities._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmClusterCapabilities()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmClusterCapabilities.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmClusterCapabilities.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmClusterCapabilities


class VmCapabilities(GeneratedsSuper):
    member_data_items_ = {
        'haEnabled': MemberSpec_('haEnabled', 'xs:boolean', 0),
        'ftEnabled': MemberSpec_('ftEnabled', 'xs:boolean', 0),
        'liveMoveEnabled': MemberSpec_('liveMoveEnabled', 'xs:boolean', 0),
        'storageMoveEnabled': MemberSpec_('storageMoveEnabled', 'xs:boolean', 0),
        'sharedDisksEnabled': MemberSpec_('sharedDisksEnabled', 'xs:boolean', 0),
        'linkedCloneEnabled': MemberSpec_('linkedCloneEnabled', 'xs:boolean', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, haEnabled=None, ftEnabled=None, liveMoveEnabled=None, storageMoveEnabled=None, sharedDisksEnabled=None, linkedCloneEnabled=None):
        self.haEnabled = haEnabled
        self.ftEnabled = ftEnabled
        self.liveMoveEnabled = liveMoveEnabled
        self.storageMoveEnabled = storageMoveEnabled
        self.sharedDisksEnabled = sharedDisksEnabled
        self.linkedCloneEnabled = linkedCloneEnabled
    def factory(*args_, **kwargs_):
        if VmCapabilities.subclass:
            return VmCapabilities.subclass(*args_, **kwargs_)
        else:
            return VmCapabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_haEnabled(self): return self.haEnabled
    def set_haEnabled(self, haEnabled): self.haEnabled = haEnabled
    haEnabledProp = property(get_haEnabled, set_haEnabled)
    def get_ftEnabled(self): return self.ftEnabled
    def set_ftEnabled(self, ftEnabled): self.ftEnabled = ftEnabled
    ftEnabledProp = property(get_ftEnabled, set_ftEnabled)
    def get_liveMoveEnabled(self): return self.liveMoveEnabled
    def set_liveMoveEnabled(self, liveMoveEnabled): self.liveMoveEnabled = liveMoveEnabled
    liveMoveEnabledProp = property(get_liveMoveEnabled, set_liveMoveEnabled)
    def get_storageMoveEnabled(self): return self.storageMoveEnabled
    def set_storageMoveEnabled(self, storageMoveEnabled): self.storageMoveEnabled = storageMoveEnabled
    storageMoveEnabledProp = property(get_storageMoveEnabled, set_storageMoveEnabled)
    def get_sharedDisksEnabled(self): return self.sharedDisksEnabled
    def set_sharedDisksEnabled(self, sharedDisksEnabled): self.sharedDisksEnabled = sharedDisksEnabled
    sharedDisksEnabledProp = property(get_sharedDisksEnabled, set_sharedDisksEnabled)
    def get_linkedCloneEnabled(self): return self.linkedCloneEnabled
    def set_linkedCloneEnabled(self, linkedCloneEnabled): self.linkedCloneEnabled = linkedCloneEnabled
    linkedCloneEnabledProp = property(get_linkedCloneEnabled, set_linkedCloneEnabled)
    def export(self, outfile, level, namespace_='', name_='VmCapabilities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmCapabilities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmCapabilities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VmCapabilities', fromsubclass_=False):
        if self.haEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%shaEnabled>%s</%shaEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.haEnabled)), input_name='haEnabled'), namespace_))
        if self.ftEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sftEnabled>%s</%sftEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.ftEnabled)), input_name='ftEnabled'), namespace_))
        if self.liveMoveEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sliveMoveEnabled>%s</%sliveMoveEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.liveMoveEnabled)), input_name='liveMoveEnabled'), namespace_))
        if self.storageMoveEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageMoveEnabled>%s</%sstorageMoveEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.storageMoveEnabled)), input_name='storageMoveEnabled'), namespace_))
        if self.sharedDisksEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%ssharedDisksEnabled>%s</%ssharedDisksEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.sharedDisksEnabled)), input_name='sharedDisksEnabled'), namespace_))
        if self.linkedCloneEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%slinkedCloneEnabled>%s</%slinkedCloneEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.linkedCloneEnabled)), input_name='linkedCloneEnabled'), namespace_))
    def hasContent_(self):
        if (
            self.haEnabled is not None or
            self.ftEnabled is not None or
            self.liveMoveEnabled is not None or
            self.storageMoveEnabled is not None or
            self.sharedDisksEnabled is not None or
            self.linkedCloneEnabled is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmCapabilities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.haEnabled is not None:
            showIndent(outfile, level)
            outfile.write('haEnabled=%s,\n' % self.haEnabled)
        if self.ftEnabled is not None:
            showIndent(outfile, level)
            outfile.write('ftEnabled=%s,\n' % self.ftEnabled)
        if self.liveMoveEnabled is not None:
            showIndent(outfile, level)
            outfile.write('liveMoveEnabled=%s,\n' % self.liveMoveEnabled)
        if self.storageMoveEnabled is not None:
            showIndent(outfile, level)
            outfile.write('storageMoveEnabled=%s,\n' % self.storageMoveEnabled)
        if self.sharedDisksEnabled is not None:
            showIndent(outfile, level)
            outfile.write('sharedDisksEnabled=%s,\n' % self.sharedDisksEnabled)
        if self.linkedCloneEnabled is not None:
            showIndent(outfile, level)
            outfile.write('linkedCloneEnabled=%s,\n' % self.linkedCloneEnabled)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'haEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'haEnabled')
            self.haEnabled = ival_
        elif nodeName_ == 'ftEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ftEnabled')
            self.ftEnabled = ival_
        elif nodeName_ == 'liveMoveEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'liveMoveEnabled')
            self.liveMoveEnabled = ival_
        elif nodeName_ == 'storageMoveEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'storageMoveEnabled')
            self.storageMoveEnabled = ival_
        elif nodeName_ == 'sharedDisksEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'sharedDisksEnabled')
            self.sharedDisksEnabled = ival_
        elif nodeName_ == 'linkedCloneEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'linkedCloneEnabled')
            self.linkedCloneEnabled = ival_
    @classmethod
    def get_all_members(cls):
        member_items = VmCapabilities.member_data_items_
        if VmCapabilities.superclass != None:
            member_items.update(VmCapabilities.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmCapabilities._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmCapabilities()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmCapabilities.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmCapabilities.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmCapabilities


class Error(GeneratedsSuper):
    member_data_items_ = {
        'code': MemberSpec_('code', 'xs:int', 0),
        'message': MemberSpec_('message', 'xs:string', 0),
        'messageBundleKey': MemberSpec_('messageBundleKey', 'xs:string', 0),
        'detail': MemberSpec_('detail', 'xs:string', 0),
        'entityId': MemberSpec_('entityId', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, code=None, message=None, messageBundleKey=None, detail=None, entityId=None):
        self.code = code
        self.message = message
        self.messageBundleKey = messageBundleKey
        self.detail = detail
        self.entityId = entityId
    def factory(*args_, **kwargs_):
        if Error.subclass:
            return Error.subclass(*args_, **kwargs_)
        else:
            return Error(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    codeProp = property(get_code, set_code)
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    messageProp = property(get_message, set_message)
    def get_messageBundleKey(self): return self.messageBundleKey
    def set_messageBundleKey(self, messageBundleKey): self.messageBundleKey = messageBundleKey
    messageBundleKeyProp = property(get_messageBundleKey, set_messageBundleKey)
    def get_detail(self): return self.detail
    def set_detail(self, detail): self.detail = detail
    detailProp = property(get_detail, set_detail)
    def get_entityId(self): return self.entityId
    def set_entityId(self, entityId): self.entityId = entityId
    entityIdProp = property(get_entityId, set_entityId)
    def export(self, outfile, level, namespace_='', name_='Error', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Error')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Error'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Error', fromsubclass_=False):
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('<%scode>%s</%scode>\n' % (namespace_, self.gds_format_integer(self.code, input_name='code'), namespace_))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('<%smessage>%s</%smessage>\n' % (namespace_, self.gds_format_string(quote_xml(self.message).encode(ExternalEncoding), input_name='message'), namespace_))
        if self.messageBundleKey is not None:
            showIndent(outfile, level)
            outfile.write('<%smessageBundleKey>%s</%smessageBundleKey>\n' % (namespace_, self.gds_format_string(quote_xml(self.messageBundleKey).encode(ExternalEncoding), input_name='messageBundleKey'), namespace_))
        if self.detail is not None:
            showIndent(outfile, level)
            outfile.write('<%sdetail>%s</%sdetail>\n' % (namespace_, self.gds_format_string(quote_xml(self.detail).encode(ExternalEncoding), input_name='detail'), namespace_))
        if self.entityId is not None:
            showIndent(outfile, level)
            outfile.write('<%sentityId>%s</%sentityId>\n' % (namespace_, self.gds_format_string(quote_xml(self.entityId).encode(ExternalEncoding), input_name='entityId'), namespace_))
    def hasContent_(self):
        if (
            self.code is not None or
            self.message is not None or
            self.messageBundleKey is not None or
            self.detail is not None or
            self.entityId is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Error'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=%d,\n' % self.code)
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % quote_python(self.message).encode(ExternalEncoding))
        if self.messageBundleKey is not None:
            showIndent(outfile, level)
            outfile.write('messageBundleKey=%s,\n' % quote_python(self.messageBundleKey).encode(ExternalEncoding))
        if self.detail is not None:
            showIndent(outfile, level)
            outfile.write('detail=%s,\n' % quote_python(self.detail).encode(ExternalEncoding))
        if self.entityId is not None:
            showIndent(outfile, level)
            outfile.write('entityId=%s,\n' % quote_python(self.entityId).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'messageBundleKey':
            messageBundleKey_ = child_.text
            messageBundleKey_ = self.gds_validate_string(messageBundleKey_, node, 'messageBundleKey')
            self.messageBundleKey = messageBundleKey_
        elif nodeName_ == 'detail':
            detail_ = child_.text
            detail_ = self.gds_validate_string(detail_, node, 'detail')
            self.detail = detail_
        elif nodeName_ == 'entityId':
            entityId_ = child_.text
            entityId_ = self.gds_validate_string(entityId_, node, 'entityId')
            self.entityId = entityId_
    @classmethod
    def get_all_members(cls):
        member_items = Error.member_data_items_
        if Error.superclass != None:
            member_items.update(Error.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Error._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Error()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Error.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Error.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Error


class Event(GeneratedsSuper):
    member_data_items_ = {
        'date': MemberSpec_('date', 'xs:long', 0),
        'message': MemberSpec_('message', 'xs:string', 0),
        'messageBundleKey': MemberSpec_('messageBundleKey', 'xs:string', 0),
        'parameters': MemberSpec_('parameters', 'MessageParameter', 1),
        'status': MemberSpec_('status', ['StatusMessageEnum', 'xs:string'], 0),
        }
    subclass = None
    superclass = None
    def __init__(self, date=None, message=None, messageBundleKey=None, parameters=None, status=None):
        self.date = date
        self.message = message
        self.messageBundleKey = messageBundleKey
        if parameters is None:
            self.parameters = []
        else:
            self.parameters = parameters
        self.status = status
    def factory(*args_, **kwargs_):
        if Event.subclass:
            return Event.subclass(*args_, **kwargs_)
        else:
            return Event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    dateProp = property(get_date, set_date)
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    messageProp = property(get_message, set_message)
    def get_messageBundleKey(self): return self.messageBundleKey
    def set_messageBundleKey(self, messageBundleKey): self.messageBundleKey = messageBundleKey
    messageBundleKeyProp = property(get_messageBundleKey, set_messageBundleKey)
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def add_parameters(self, value): self.parameters.append(value)
    def insert_parameters(self, index, value): self.parameters[index] = value
    parametersProp = property(get_parameters, set_parameters)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    statusProp = property(get_status, set_status)
    def validate_StatusMessageEnum(self, value):
        # Validate type StatusMessageEnum, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Event', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Event')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Event'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Event', fromsubclass_=False):
        if self.date is not None:
            showIndent(outfile, level)
            outfile.write('<%sdate>%s</%sdate>\n' % (namespace_, self.gds_format_integer(self.date, input_name='date'), namespace_))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('<%smessage>%s</%smessage>\n' % (namespace_, self.gds_format_string(quote_xml(self.message).encode(ExternalEncoding), input_name='message'), namespace_))
        if self.messageBundleKey is not None:
            showIndent(outfile, level)
            outfile.write('<%smessageBundleKey>%s</%smessageBundleKey>\n' % (namespace_, self.gds_format_string(quote_xml(self.messageBundleKey).encode(ExternalEncoding), input_name='messageBundleKey'), namespace_))
        for parameters_ in self.parameters:
            parameters_.export(outfile, level, namespace_, name_='parameters')
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('<%sstatus>%s</%sstatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_))
    def hasContent_(self):
        if (
            self.date is not None or
            self.message is not None or
            self.messageBundleKey is not None or
            self.parameters or
            self.status is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Event'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.date is not None:
            showIndent(outfile, level)
            outfile.write('date=%d,\n' % self.date)
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % quote_python(self.message).encode(ExternalEncoding))
        if self.messageBundleKey is not None:
            showIndent(outfile, level)
            outfile.write('messageBundleKey=%s,\n' % quote_python(self.messageBundleKey).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('parameters=[\n')
        level += 1
        for parameters_ in self.parameters:
            showIndent(outfile, level)
            outfile.write('model_.MessageParameter(\n')
            parameters_.exportLiteral(outfile, level, name_='MessageParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'date':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'date')
            self.date = ival_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'messageBundleKey':
            messageBundleKey_ = child_.text
            messageBundleKey_ = self.gds_validate_string(messageBundleKey_, node, 'messageBundleKey')
            self.messageBundleKey = messageBundleKey_
        elif nodeName_ == 'parameters':
            obj_ = MessageParameter.factory()
            obj_.build(child_)
            self.parameters.append(obj_)
        elif nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
            self.validate_StatusMessageEnum(self.status)    # validate type StatusMessageEnum
    @classmethod
    def get_all_members(cls):
        member_items = Event.member_data_items_
        if Event.superclass != None:
            member_items.update(Event.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Event._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Event()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Event.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Event.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Event


class MessageParameter(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:long', 0),
        'message': MemberSpec_('message', 'xs:string', 0),
        'parameters': MemberSpec_('parameters', 'MessageParameter', 1),
        }
    subclass = None
    superclass = None
    def __init__(self, id=None, message=None, parameters=None):
        self.id = id
        self.message = message
        if parameters is None:
            self.parameters = []
        else:
            self.parameters = parameters
    def factory(*args_, **kwargs_):
        if MessageParameter.subclass:
            return MessageParameter.subclass(*args_, **kwargs_)
        else:
            return MessageParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    idProp = property(get_id, set_id)
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    messageProp = property(get_message, set_message)
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def add_parameters(self, value): self.parameters.append(value)
    def insert_parameters(self, index, value): self.parameters[index] = value
    parametersProp = property(get_parameters, set_parameters)
    def export(self, outfile, level, namespace_='', name_='MessageParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MessageParameter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MessageParameter', fromsubclass_=False):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('<%sid>%s</%sid>\n' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('<%smessage>%s</%smessage>\n' % (namespace_, self.gds_format_string(quote_xml(self.message).encode(ExternalEncoding), input_name='message'), namespace_))
        for parameters_ in self.parameters:
            parameters_.export(outfile, level, namespace_, name_='parameters')
    def hasContent_(self):
        if (
            self.id is not None or
            self.message is not None or
            self.parameters
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MessageParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % quote_python(self.message).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('parameters=[\n')
        level += 1
        for parameters_ in self.parameters:
            showIndent(outfile, level)
            outfile.write('model_.MessageParameter(\n')
            parameters_.exportLiteral(outfile, level, name_='MessageParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'parameters':
            obj_ = MessageParameter.factory()
            obj_.build(child_)
            self.parameters.append(obj_)
    @classmethod
    def get_all_members(cls):
        member_items = MessageParameter.member_data_items_
        if MessageParameter.superclass != None:
            member_items.update(MessageParameter.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return MessageParameter._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = MessageParameter()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return MessageParameter.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = MessageParameter.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class MessageParameter


class ComputeCluster(Resource):
    member_data_items_ = {
        'processorSpeedTotalMhz': MemberSpec_('processorSpeedTotalMhz', 'xs:int', 0),
        'memorySize': MemberSpec_('memorySize', 'xs:long', 0),
        'processorCoresCount': MemberSpec_('processorCoresCount', 'xs:int', 0),
        'hostsCount': MemberSpec_('hostsCount', 'xs:int', 0),
        'effectiveHostsCount': MemberSpec_('effectiveHostsCount', 'xs:int', 0),
        'effectiveProcessorSpeedTotalMhz': MemberSpec_('effectiveProcessorSpeedTotalMhz', 'xs:int', 0),
        'effectiveMemorySize': MemberSpec_('effectiveMemorySize', 'xs:long', 0),
        'memoryConsumed': MemberSpec_('memoryConsumed', 'xs:long', 0),
        'processorLoadPercent': MemberSpec_('processorLoadPercent', 'xs:int', 0),
        'computeServers': MemberSpec_('computeServers', 'ComputeServer', 1),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, processorSpeedTotalMhz=None, memorySize=None, processorCoresCount=None, hostsCount=None, effectiveHostsCount=None, effectiveProcessorSpeedTotalMhz=None, effectiveMemorySize=None, memoryConsumed=None, processorLoadPercent=None, computeServers=None, extensiontype_=None):
        super(ComputeCluster, self).__init__(resourceManagerId, utilization, limits, vendorProperties, extensiontype_, )
        self.processorSpeedTotalMhz = processorSpeedTotalMhz
        self.memorySize = memorySize
        self.processorCoresCount = processorCoresCount
        self.hostsCount = hostsCount
        self.effectiveHostsCount = effectiveHostsCount
        self.effectiveProcessorSpeedTotalMhz = effectiveProcessorSpeedTotalMhz
        self.effectiveMemorySize = effectiveMemorySize
        self.memoryConsumed = memoryConsumed
        self.processorLoadPercent = processorLoadPercent
        if computeServers is None:
            self.computeServers = []
        else:
            self.computeServers = computeServers
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ComputeCluster.subclass:
            return ComputeCluster.subclass(*args_, **kwargs_)
        else:
            return ComputeCluster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processorSpeedTotalMhz(self): return self.processorSpeedTotalMhz
    def set_processorSpeedTotalMhz(self, processorSpeedTotalMhz): self.processorSpeedTotalMhz = processorSpeedTotalMhz
    processorSpeedTotalMhzProp = property(get_processorSpeedTotalMhz, set_processorSpeedTotalMhz)
    def get_memorySize(self): return self.memorySize
    def set_memorySize(self, memorySize): self.memorySize = memorySize
    memorySizeProp = property(get_memorySize, set_memorySize)
    def get_processorCoresCount(self): return self.processorCoresCount
    def set_processorCoresCount(self, processorCoresCount): self.processorCoresCount = processorCoresCount
    processorCoresCountProp = property(get_processorCoresCount, set_processorCoresCount)
    def get_hostsCount(self): return self.hostsCount
    def set_hostsCount(self, hostsCount): self.hostsCount = hostsCount
    hostsCountProp = property(get_hostsCount, set_hostsCount)
    def get_effectiveHostsCount(self): return self.effectiveHostsCount
    def set_effectiveHostsCount(self, effectiveHostsCount): self.effectiveHostsCount = effectiveHostsCount
    effectiveHostsCountProp = property(get_effectiveHostsCount, set_effectiveHostsCount)
    def get_effectiveProcessorSpeedTotalMhz(self): return self.effectiveProcessorSpeedTotalMhz
    def set_effectiveProcessorSpeedTotalMhz(self, effectiveProcessorSpeedTotalMhz): self.effectiveProcessorSpeedTotalMhz = effectiveProcessorSpeedTotalMhz
    effectiveProcessorSpeedTotalMhzProp = property(get_effectiveProcessorSpeedTotalMhz, set_effectiveProcessorSpeedTotalMhz)
    def get_effectiveMemorySize(self): return self.effectiveMemorySize
    def set_effectiveMemorySize(self, effectiveMemorySize): self.effectiveMemorySize = effectiveMemorySize
    effectiveMemorySizeProp = property(get_effectiveMemorySize, set_effectiveMemorySize)
    def get_memoryConsumed(self): return self.memoryConsumed
    def set_memoryConsumed(self, memoryConsumed): self.memoryConsumed = memoryConsumed
    memoryConsumedProp = property(get_memoryConsumed, set_memoryConsumed)
    def get_processorLoadPercent(self): return self.processorLoadPercent
    def set_processorLoadPercent(self, processorLoadPercent): self.processorLoadPercent = processorLoadPercent
    processorLoadPercentProp = property(get_processorLoadPercent, set_processorLoadPercent)
    def get_computeServers(self): return self.computeServers
    def set_computeServers(self, computeServers): self.computeServers = computeServers
    def add_computeServers(self, value): self.computeServers.append(value)
    def insert_computeServers(self, index, value): self.computeServers[index] = value
    computeServersProp = property(get_computeServers, set_computeServers)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ComputeCluster', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeCluster')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComputeCluster'):
        super(ComputeCluster, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeCluster')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ComputeCluster', fromsubclass_=False):
        super(ComputeCluster, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.processorSpeedTotalMhz is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorSpeedTotalMhz>%s</%sprocessorSpeedTotalMhz>\n' % (namespace_, self.gds_format_integer(self.processorSpeedTotalMhz, input_name='processorSpeedTotalMhz'), namespace_))
        if self.memorySize is not None:
            showIndent(outfile, level)
            outfile.write('<%smemorySize>%s</%smemorySize>\n' % (namespace_, self.gds_format_integer(self.memorySize, input_name='memorySize'), namespace_))
        if self.processorCoresCount is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorCoresCount>%s</%sprocessorCoresCount>\n' % (namespace_, self.gds_format_integer(self.processorCoresCount, input_name='processorCoresCount'), namespace_))
        if self.hostsCount is not None:
            showIndent(outfile, level)
            outfile.write('<%shostsCount>%s</%shostsCount>\n' % (namespace_, self.gds_format_integer(self.hostsCount, input_name='hostsCount'), namespace_))
        if self.effectiveHostsCount is not None:
            showIndent(outfile, level)
            outfile.write('<%seffectiveHostsCount>%s</%seffectiveHostsCount>\n' % (namespace_, self.gds_format_integer(self.effectiveHostsCount, input_name='effectiveHostsCount'), namespace_))
        if self.effectiveProcessorSpeedTotalMhz is not None:
            showIndent(outfile, level)
            outfile.write('<%seffectiveProcessorSpeedTotalMhz>%s</%seffectiveProcessorSpeedTotalMhz>\n' % (namespace_, self.gds_format_integer(self.effectiveProcessorSpeedTotalMhz, input_name='effectiveProcessorSpeedTotalMhz'), namespace_))
        if self.effectiveMemorySize is not None:
            showIndent(outfile, level)
            outfile.write('<%seffectiveMemorySize>%s</%seffectiveMemorySize>\n' % (namespace_, self.gds_format_integer(self.effectiveMemorySize, input_name='effectiveMemorySize'), namespace_))
        if self.memoryConsumed is not None:
            showIndent(outfile, level)
            outfile.write('<%smemoryConsumed>%s</%smemoryConsumed>\n' % (namespace_, self.gds_format_integer(self.memoryConsumed, input_name='memoryConsumed'), namespace_))
        if self.processorLoadPercent is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorLoadPercent>%s</%sprocessorLoadPercent>\n' % (namespace_, self.gds_format_integer(self.processorLoadPercent, input_name='processorLoadPercent'), namespace_))
        for computeServers_ in self.computeServers:
            computeServers_.export(outfile, level, namespace_, name_='computeServers')
    def hasContent_(self):
        if (
            self.processorSpeedTotalMhz is not None or
            self.memorySize is not None or
            self.processorCoresCount is not None or
            self.hostsCount is not None or
            self.effectiveHostsCount is not None or
            self.effectiveProcessorSpeedTotalMhz is not None or
            self.effectiveMemorySize is not None or
            self.memoryConsumed is not None or
            self.processorLoadPercent is not None or
            self.computeServers or
            super(ComputeCluster, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ComputeCluster'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ComputeCluster, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ComputeCluster, self).exportLiteralChildren(outfile, level, name_)
        if self.processorSpeedTotalMhz is not None:
            showIndent(outfile, level)
            outfile.write('processorSpeedTotalMhz=%d,\n' % self.processorSpeedTotalMhz)
        if self.memorySize is not None:
            showIndent(outfile, level)
            outfile.write('memorySize=%d,\n' % self.memorySize)
        if self.processorCoresCount is not None:
            showIndent(outfile, level)
            outfile.write('processorCoresCount=%d,\n' % self.processorCoresCount)
        if self.hostsCount is not None:
            showIndent(outfile, level)
            outfile.write('hostsCount=%d,\n' % self.hostsCount)
        if self.effectiveHostsCount is not None:
            showIndent(outfile, level)
            outfile.write('effectiveHostsCount=%d,\n' % self.effectiveHostsCount)
        if self.effectiveProcessorSpeedTotalMhz is not None:
            showIndent(outfile, level)
            outfile.write('effectiveProcessorSpeedTotalMhz=%d,\n' % self.effectiveProcessorSpeedTotalMhz)
        if self.effectiveMemorySize is not None:
            showIndent(outfile, level)
            outfile.write('effectiveMemorySize=%d,\n' % self.effectiveMemorySize)
        if self.memoryConsumed is not None:
            showIndent(outfile, level)
            outfile.write('memoryConsumed=%d,\n' % self.memoryConsumed)
        if self.processorLoadPercent is not None:
            showIndent(outfile, level)
            outfile.write('processorLoadPercent=%d,\n' % self.processorLoadPercent)
        showIndent(outfile, level)
        outfile.write('computeServers=[\n')
        level += 1
        for computeServers_ in self.computeServers:
            showIndent(outfile, level)
            outfile.write('model_.ComputeServer(\n')
            computeServers_.exportLiteral(outfile, level, name_='ComputeServer')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(ComputeCluster, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processorSpeedTotalMhz':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorSpeedTotalMhz')
            self.processorSpeedTotalMhz = ival_
        elif nodeName_ == 'memorySize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memorySize')
            self.memorySize = ival_
        elif nodeName_ == 'processorCoresCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorCoresCount')
            self.processorCoresCount = ival_
        elif nodeName_ == 'hostsCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hostsCount')
            self.hostsCount = ival_
        elif nodeName_ == 'effectiveHostsCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'effectiveHostsCount')
            self.effectiveHostsCount = ival_
        elif nodeName_ == 'effectiveProcessorSpeedTotalMhz':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'effectiveProcessorSpeedTotalMhz')
            self.effectiveProcessorSpeedTotalMhz = ival_
        elif nodeName_ == 'effectiveMemorySize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'effectiveMemorySize')
            self.effectiveMemorySize = ival_
        elif nodeName_ == 'memoryConsumed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memoryConsumed')
            self.memoryConsumed = ival_
        elif nodeName_ == 'processorLoadPercent':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorLoadPercent')
            self.processorLoadPercent = ival_
        elif nodeName_ == 'computeServers':
            class_obj_ = self.get_class_obj_(child_, ComputeServer)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.computeServers.append(obj_)
        super(ComputeCluster, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = ComputeCluster.member_data_items_
        if ComputeCluster.superclass != None:
            member_items.update(ComputeCluster.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return ComputeCluster._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = ComputeCluster()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return ComputeCluster.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = ComputeCluster.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class ComputeCluster


class ComputeServer(Resource):
    member_data_items_ = {
        'memorySize': MemberSpec_('memorySize', 'xs:long', 0),
        'processorSpeedMhz': MemberSpec_('processorSpeedMhz', 'xs:int', 0),
        'processorSpeedTotalMhz': MemberSpec_('processorSpeedTotalMhz', 'xs:int', 0),
        'processorCount': MemberSpec_('processorCount', 'xs:int', 0),
        'processorCoresCount': MemberSpec_('processorCoresCount', 'xs:int', 0),
        'processorArchitecture': MemberSpec_('processorArchitecture', ['ProcessorArchitectureEnum', 'xs:string'], 0),
        'serialNumber': MemberSpec_('serialNumber', 'xs:string', 0),
        'groupId': MemberSpec_('groupId', 'xs:string', 0),
        'memoryConsumed': MemberSpec_('memoryConsumed', 'xs:long', 0),
        'processorLoadPercent': MemberSpec_('processorLoadPercent', 'xs:int', 0),
        'hyperThreadEnabled': MemberSpec_('hyperThreadEnabled', 'xs:boolean', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, memorySize=None, processorSpeedMhz=None, processorSpeedTotalMhz=None, processorCount=None, processorCoresCount=None, processorArchitecture=None, serialNumber=None, groupId=None, memoryConsumed=None, processorLoadPercent=None, hyperThreadEnabled=None, extensiontype_=None):
        super(ComputeServer, self).__init__(resourceManagerId, utilization, limits, vendorProperties, extensiontype_, )
        self.memorySize = memorySize
        self.processorSpeedMhz = processorSpeedMhz
        self.processorSpeedTotalMhz = processorSpeedTotalMhz
        self.processorCount = processorCount
        self.processorCoresCount = processorCoresCount
        self.processorArchitecture = processorArchitecture
        self.serialNumber = serialNumber
        self.groupId = groupId
        self.memoryConsumed = memoryConsumed
        self.processorLoadPercent = processorLoadPercent
        self.hyperThreadEnabled = hyperThreadEnabled
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ComputeServer.subclass:
            return ComputeServer.subclass(*args_, **kwargs_)
        else:
            return ComputeServer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memorySize(self): return self.memorySize
    def set_memorySize(self, memorySize): self.memorySize = memorySize
    memorySizeProp = property(get_memorySize, set_memorySize)
    def get_processorSpeedMhz(self): return self.processorSpeedMhz
    def set_processorSpeedMhz(self, processorSpeedMhz): self.processorSpeedMhz = processorSpeedMhz
    processorSpeedMhzProp = property(get_processorSpeedMhz, set_processorSpeedMhz)
    def get_processorSpeedTotalMhz(self): return self.processorSpeedTotalMhz
    def set_processorSpeedTotalMhz(self, processorSpeedTotalMhz): self.processorSpeedTotalMhz = processorSpeedTotalMhz
    processorSpeedTotalMhzProp = property(get_processorSpeedTotalMhz, set_processorSpeedTotalMhz)
    def get_processorCount(self): return self.processorCount
    def set_processorCount(self, processorCount): self.processorCount = processorCount
    processorCountProp = property(get_processorCount, set_processorCount)
    def get_processorCoresCount(self): return self.processorCoresCount
    def set_processorCoresCount(self, processorCoresCount): self.processorCoresCount = processorCoresCount
    processorCoresCountProp = property(get_processorCoresCount, set_processorCoresCount)
    def get_processorArchitecture(self): return self.processorArchitecture
    def set_processorArchitecture(self, processorArchitecture): self.processorArchitecture = processorArchitecture
    processorArchitectureProp = property(get_processorArchitecture, set_processorArchitecture)
    def validate_ProcessorArchitectureEnum(self, value):
        # Validate type ProcessorArchitectureEnum, a restriction on xs:string.
        pass
    def get_serialNumber(self): return self.serialNumber
    def set_serialNumber(self, serialNumber): self.serialNumber = serialNumber
    serialNumberProp = property(get_serialNumber, set_serialNumber)
    def get_groupId(self): return self.groupId
    def set_groupId(self, groupId): self.groupId = groupId
    groupIdProp = property(get_groupId, set_groupId)
    def get_memoryConsumed(self): return self.memoryConsumed
    def set_memoryConsumed(self, memoryConsumed): self.memoryConsumed = memoryConsumed
    memoryConsumedProp = property(get_memoryConsumed, set_memoryConsumed)
    def get_processorLoadPercent(self): return self.processorLoadPercent
    def set_processorLoadPercent(self, processorLoadPercent): self.processorLoadPercent = processorLoadPercent
    processorLoadPercentProp = property(get_processorLoadPercent, set_processorLoadPercent)
    def get_hyperThreadEnabled(self): return self.hyperThreadEnabled
    def set_hyperThreadEnabled(self, hyperThreadEnabled): self.hyperThreadEnabled = hyperThreadEnabled
    hyperThreadEnabledProp = property(get_hyperThreadEnabled, set_hyperThreadEnabled)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ComputeServer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeServer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComputeServer'):
        super(ComputeServer, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeServer')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ComputeServer', fromsubclass_=False):
        super(ComputeServer, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.memorySize is not None:
            showIndent(outfile, level)
            outfile.write('<%smemorySize>%s</%smemorySize>\n' % (namespace_, self.gds_format_integer(self.memorySize, input_name='memorySize'), namespace_))
        if self.processorSpeedMhz is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorSpeedMhz>%s</%sprocessorSpeedMhz>\n' % (namespace_, self.gds_format_integer(self.processorSpeedMhz, input_name='processorSpeedMhz'), namespace_))
        if self.processorSpeedTotalMhz is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorSpeedTotalMhz>%s</%sprocessorSpeedTotalMhz>\n' % (namespace_, self.gds_format_integer(self.processorSpeedTotalMhz, input_name='processorSpeedTotalMhz'), namespace_))
        if self.processorCount is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorCount>%s</%sprocessorCount>\n' % (namespace_, self.gds_format_integer(self.processorCount, input_name='processorCount'), namespace_))
        if self.processorCoresCount is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorCoresCount>%s</%sprocessorCoresCount>\n' % (namespace_, self.gds_format_integer(self.processorCoresCount, input_name='processorCoresCount'), namespace_))
        if self.processorArchitecture is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorArchitecture>%s</%sprocessorArchitecture>\n' % (namespace_, self.gds_format_string(quote_xml(self.processorArchitecture).encode(ExternalEncoding), input_name='processorArchitecture'), namespace_))
        if self.serialNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sserialNumber>%s</%sserialNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.serialNumber).encode(ExternalEncoding), input_name='serialNumber'), namespace_))
        if self.groupId is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroupId>%s</%sgroupId>\n' % (namespace_, self.gds_format_string(quote_xml(self.groupId).encode(ExternalEncoding), input_name='groupId'), namespace_))
        if self.memoryConsumed is not None:
            showIndent(outfile, level)
            outfile.write('<%smemoryConsumed>%s</%smemoryConsumed>\n' % (namespace_, self.gds_format_integer(self.memoryConsumed, input_name='memoryConsumed'), namespace_))
        if self.processorLoadPercent is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorLoadPercent>%s</%sprocessorLoadPercent>\n' % (namespace_, self.gds_format_integer(self.processorLoadPercent, input_name='processorLoadPercent'), namespace_))
        if self.hyperThreadEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%shyperThreadEnabled>%s</%shyperThreadEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.hyperThreadEnabled)), input_name='hyperThreadEnabled'), namespace_))
    def hasContent_(self):
        if (
            self.memorySize is not None or
            self.processorSpeedMhz is not None or
            self.processorSpeedTotalMhz is not None or
            self.processorCount is not None or
            self.processorCoresCount is not None or
            self.processorArchitecture is not None or
            self.serialNumber is not None or
            self.groupId is not None or
            self.memoryConsumed is not None or
            self.processorLoadPercent is not None or
            self.hyperThreadEnabled is not None or
            super(ComputeServer, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ComputeServer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ComputeServer, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ComputeServer, self).exportLiteralChildren(outfile, level, name_)
        if self.memorySize is not None:
            showIndent(outfile, level)
            outfile.write('memorySize=%d,\n' % self.memorySize)
        if self.processorSpeedMhz is not None:
            showIndent(outfile, level)
            outfile.write('processorSpeedMhz=%d,\n' % self.processorSpeedMhz)
        if self.processorSpeedTotalMhz is not None:
            showIndent(outfile, level)
            outfile.write('processorSpeedTotalMhz=%d,\n' % self.processorSpeedTotalMhz)
        if self.processorCount is not None:
            showIndent(outfile, level)
            outfile.write('processorCount=%d,\n' % self.processorCount)
        if self.processorCoresCount is not None:
            showIndent(outfile, level)
            outfile.write('processorCoresCount=%d,\n' % self.processorCoresCount)
        if self.processorArchitecture is not None:
            showIndent(outfile, level)
            outfile.write('processorArchitecture=%s,\n' % quote_python(self.processorArchitecture).encode(ExternalEncoding))
        if self.serialNumber is not None:
            showIndent(outfile, level)
            outfile.write('serialNumber=%s,\n' % quote_python(self.serialNumber).encode(ExternalEncoding))
        if self.groupId is not None:
            showIndent(outfile, level)
            outfile.write('groupId=%s,\n' % quote_python(self.groupId).encode(ExternalEncoding))
        if self.memoryConsumed is not None:
            showIndent(outfile, level)
            outfile.write('memoryConsumed=%d,\n' % self.memoryConsumed)
        if self.processorLoadPercent is not None:
            showIndent(outfile, level)
            outfile.write('processorLoadPercent=%d,\n' % self.processorLoadPercent)
        if self.hyperThreadEnabled is not None:
            showIndent(outfile, level)
            outfile.write('hyperThreadEnabled=%s,\n' % self.hyperThreadEnabled)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(ComputeServer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'memorySize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memorySize')
            self.memorySize = ival_
        elif nodeName_ == 'processorSpeedMhz':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorSpeedMhz')
            self.processorSpeedMhz = ival_
        elif nodeName_ == 'processorSpeedTotalMhz':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorSpeedTotalMhz')
            self.processorSpeedTotalMhz = ival_
        elif nodeName_ == 'processorCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorCount')
            self.processorCount = ival_
        elif nodeName_ == 'processorCoresCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorCoresCount')
            self.processorCoresCount = ival_
        elif nodeName_ == 'processorArchitecture':
            processorArchitecture_ = child_.text
            processorArchitecture_ = self.gds_validate_string(processorArchitecture_, node, 'processorArchitecture')
            self.processorArchitecture = processorArchitecture_
            self.validate_ProcessorArchitectureEnum(self.processorArchitecture)    # validate type ProcessorArchitectureEnum
        elif nodeName_ == 'serialNumber':
            serialNumber_ = child_.text
            serialNumber_ = self.gds_validate_string(serialNumber_, node, 'serialNumber')
            self.serialNumber = serialNumber_
        elif nodeName_ == 'groupId':
            groupId_ = child_.text
            groupId_ = self.gds_validate_string(groupId_, node, 'groupId')
            self.groupId = groupId_
        elif nodeName_ == 'memoryConsumed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memoryConsumed')
            self.memoryConsumed = ival_
        elif nodeName_ == 'processorLoadPercent':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorLoadPercent')
            self.processorLoadPercent = ival_
        elif nodeName_ == 'hyperThreadEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'hyperThreadEnabled')
            self.hyperThreadEnabled = ival_
        super(ComputeServer, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = ComputeServer.member_data_items_
        if ComputeServer.superclass != None:
            member_items.update(ComputeServer.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return ComputeServer._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = ComputeServer()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return ComputeServer.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = ComputeServer.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class ComputeServer


class PhysicalServer(ComputeServer):
    member_data_items_ = {
        'os': MemberSpec_('os', 'OsProfile', 0),
        'ipAddresses': MemberSpec_('ipAddresses', 'IpProfile', 1),
        'model': MemberSpec_('model', 'xs:string', 0),
        'licensingId': MemberSpec_('licensingId', 'xs:string', 0),
        'enclosure': MemberSpec_('enclosure', 'xs:string', 0),
        'bay': MemberSpec_('bay', 'xs:string', 0),
        'uuid': MemberSpec_('uuid', 'xs:string', 0),
        'inUse': MemberSpec_('inUse', 'xs:boolean', 0),
        'fcVirtualInitiator': MemberSpec_('fcVirtualInitiator', 'xs:boolean', 0),
        'ethernetVirtualInitiator': MemberSpec_('ethernetVirtualInitiator', 'xs:boolean', 0),
        'localDisks': MemberSpec_('localDisks', 'StorageVolume', 1),
        'validTarget': MemberSpec_('validTarget', 'xs:boolean', 0),
        }
    subclass = None
    superclass = ComputeServer
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, memorySize=None, processorSpeedMhz=None, processorSpeedTotalMhz=None, processorCount=None, processorCoresCount=None, processorArchitecture=None, serialNumber=None, groupId=None, memoryConsumed=None, processorLoadPercent=None, hyperThreadEnabled=None, os=None, ipAddresses=None, model=None, licensingId=None, enclosure=None, bay=None, uuid=None, inUse=None, fcVirtualInitiator=None, ethernetVirtualInitiator=None, localDisks=None, validTarget=None, extensiontype_=None):
        super(PhysicalServer, self).__init__(resourceManagerId, utilization, limits, vendorProperties, memorySize, processorSpeedMhz, processorSpeedTotalMhz, processorCount, processorCoresCount, processorArchitecture, serialNumber, groupId, memoryConsumed, processorLoadPercent, hyperThreadEnabled, extensiontype_, )
        self.os = os
        if ipAddresses is None:
            self.ipAddresses = []
        else:
            self.ipAddresses = ipAddresses
        self.model = model
        self.licensingId = licensingId
        self.enclosure = enclosure
        self.bay = bay
        self.uuid = uuid
        self.inUse = inUse
        self.fcVirtualInitiator = fcVirtualInitiator
        self.ethernetVirtualInitiator = ethernetVirtualInitiator
        if localDisks is None:
            self.localDisks = []
        else:
            self.localDisks = localDisks
        self.validTarget = validTarget
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if PhysicalServer.subclass:
            return PhysicalServer.subclass(*args_, **kwargs_)
        else:
            return PhysicalServer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_os(self): return self.os
    def set_os(self, os): self.os = os
    osProp = property(get_os, set_os)
    def get_ipAddresses(self): return self.ipAddresses
    def set_ipAddresses(self, ipAddresses): self.ipAddresses = ipAddresses
    def add_ipAddresses(self, value): self.ipAddresses.append(value)
    def insert_ipAddresses(self, index, value): self.ipAddresses[index] = value
    ipAddressesProp = property(get_ipAddresses, set_ipAddresses)
    def get_model(self): return self.model
    def set_model(self, model): self.model = model
    modelProp = property(get_model, set_model)
    def get_licensingId(self): return self.licensingId
    def set_licensingId(self, licensingId): self.licensingId = licensingId
    licensingIdProp = property(get_licensingId, set_licensingId)
    def get_enclosure(self): return self.enclosure
    def set_enclosure(self, enclosure): self.enclosure = enclosure
    enclosureProp = property(get_enclosure, set_enclosure)
    def get_bay(self): return self.bay
    def set_bay(self, bay): self.bay = bay
    bayProp = property(get_bay, set_bay)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    uuidProp = property(get_uuid, set_uuid)
    def get_inUse(self): return self.inUse
    def set_inUse(self, inUse): self.inUse = inUse
    inUseProp = property(get_inUse, set_inUse)
    def get_fcVirtualInitiator(self): return self.fcVirtualInitiator
    def set_fcVirtualInitiator(self, fcVirtualInitiator): self.fcVirtualInitiator = fcVirtualInitiator
    fcVirtualInitiatorProp = property(get_fcVirtualInitiator, set_fcVirtualInitiator)
    def get_ethernetVirtualInitiator(self): return self.ethernetVirtualInitiator
    def set_ethernetVirtualInitiator(self, ethernetVirtualInitiator): self.ethernetVirtualInitiator = ethernetVirtualInitiator
    ethernetVirtualInitiatorProp = property(get_ethernetVirtualInitiator, set_ethernetVirtualInitiator)
    def get_localDisks(self): return self.localDisks
    def set_localDisks(self, localDisks): self.localDisks = localDisks
    def add_localDisks(self, value): self.localDisks.append(value)
    def insert_localDisks(self, index, value): self.localDisks[index] = value
    localDisksProp = property(get_localDisks, set_localDisks)
    def get_validTarget(self): return self.validTarget
    def set_validTarget(self, validTarget): self.validTarget = validTarget
    validTargetProp = property(get_validTarget, set_validTarget)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='PhysicalServer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalServer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhysicalServer'):
        super(PhysicalServer, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalServer')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PhysicalServer', fromsubclass_=False):
        super(PhysicalServer, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.os is not None:
            self.os.export(outfile, level, namespace_, name_='os')
        for ipAddresses_ in self.ipAddresses:
            ipAddresses_.export(outfile, level, namespace_, name_='ipAddresses')
        if self.model is not None:
            showIndent(outfile, level)
            outfile.write('<%smodel>%s</%smodel>\n' % (namespace_, self.gds_format_string(quote_xml(self.model).encode(ExternalEncoding), input_name='model'), namespace_))
        if self.licensingId is not None:
            showIndent(outfile, level)
            outfile.write('<%slicensingId>%s</%slicensingId>\n' % (namespace_, self.gds_format_string(quote_xml(self.licensingId).encode(ExternalEncoding), input_name='licensingId'), namespace_))
        if self.enclosure is not None:
            showIndent(outfile, level)
            outfile.write('<%senclosure>%s</%senclosure>\n' % (namespace_, self.gds_format_string(quote_xml(self.enclosure).encode(ExternalEncoding), input_name='enclosure'), namespace_))
        if self.bay is not None:
            showIndent(outfile, level)
            outfile.write('<%sbay>%s</%sbay>\n' % (namespace_, self.gds_format_string(quote_xml(self.bay).encode(ExternalEncoding), input_name='bay'), namespace_))
        if self.uuid is not None:
            showIndent(outfile, level)
            outfile.write('<%suuid>%s</%suuid>\n' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_))
        if self.inUse is not None:
            showIndent(outfile, level)
            outfile.write('<%sinUse>%s</%sinUse>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.inUse)), input_name='inUse'), namespace_))
        if self.fcVirtualInitiator is not None:
            showIndent(outfile, level)
            outfile.write('<%sfcVirtualInitiator>%s</%sfcVirtualInitiator>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.fcVirtualInitiator)), input_name='fcVirtualInitiator'), namespace_))
        if self.ethernetVirtualInitiator is not None:
            showIndent(outfile, level)
            outfile.write('<%sethernetVirtualInitiator>%s</%sethernetVirtualInitiator>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.ethernetVirtualInitiator)), input_name='ethernetVirtualInitiator'), namespace_))
        for localDisks_ in self.localDisks:
            localDisks_.export(outfile, level, namespace_, name_='localDisks')
        if self.validTarget is not None:
            showIndent(outfile, level)
            outfile.write('<%svalidTarget>%s</%svalidTarget>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.validTarget)), input_name='validTarget'), namespace_))
    def hasContent_(self):
        if (
            self.os is not None or
            self.ipAddresses or
            self.model is not None or
            self.licensingId is not None or
            self.enclosure is not None or
            self.bay is not None or
            self.uuid is not None or
            self.inUse is not None or
            self.fcVirtualInitiator is not None or
            self.ethernetVirtualInitiator is not None or
            self.localDisks or
            self.validTarget is not None or
            super(PhysicalServer, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PhysicalServer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PhysicalServer, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PhysicalServer, self).exportLiteralChildren(outfile, level, name_)
        if self.os is not None:
            showIndent(outfile, level)
            outfile.write('os=model_.OsProfile(\n')
            self.os.exportLiteral(outfile, level, name_='os')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ipAddresses=[\n')
        level += 1
        for ipAddresses_ in self.ipAddresses:
            showIndent(outfile, level)
            outfile.write('model_.IpProfile(\n')
            ipAddresses_.exportLiteral(outfile, level, name_='IpProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.model is not None:
            showIndent(outfile, level)
            outfile.write('model=%s,\n' % quote_python(self.model).encode(ExternalEncoding))
        if self.licensingId is not None:
            showIndent(outfile, level)
            outfile.write('licensingId=%s,\n' % quote_python(self.licensingId).encode(ExternalEncoding))
        if self.enclosure is not None:
            showIndent(outfile, level)
            outfile.write('enclosure=%s,\n' % quote_python(self.enclosure).encode(ExternalEncoding))
        if self.bay is not None:
            showIndent(outfile, level)
            outfile.write('bay=%s,\n' % quote_python(self.bay).encode(ExternalEncoding))
        if self.uuid is not None:
            showIndent(outfile, level)
            outfile.write('uuid=%s,\n' % quote_python(self.uuid).encode(ExternalEncoding))
        if self.inUse is not None:
            showIndent(outfile, level)
            outfile.write('inUse=%s,\n' % self.inUse)
        if self.fcVirtualInitiator is not None:
            showIndent(outfile, level)
            outfile.write('fcVirtualInitiator=%s,\n' % self.fcVirtualInitiator)
        if self.ethernetVirtualInitiator is not None:
            showIndent(outfile, level)
            outfile.write('ethernetVirtualInitiator=%s,\n' % self.ethernetVirtualInitiator)
        showIndent(outfile, level)
        outfile.write('localDisks=[\n')
        level += 1
        for localDisks_ in self.localDisks:
            showIndent(outfile, level)
            outfile.write('model_.StorageVolume(\n')
            localDisks_.exportLiteral(outfile, level, name_='StorageVolume')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.validTarget is not None:
            showIndent(outfile, level)
            outfile.write('validTarget=%s,\n' % self.validTarget)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(PhysicalServer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'os':
            obj_ = OsProfile.factory()
            obj_.build(child_)
            self.set_os(obj_)
        elif nodeName_ == 'ipAddresses':
            obj_ = IpProfile.factory()
            obj_.build(child_)
            self.ipAddresses.append(obj_)
        elif nodeName_ == 'model':
            model_ = child_.text
            model_ = self.gds_validate_string(model_, node, 'model')
            self.model = model_
        elif nodeName_ == 'licensingId':
            licensingId_ = child_.text
            licensingId_ = self.gds_validate_string(licensingId_, node, 'licensingId')
            self.licensingId = licensingId_
        elif nodeName_ == 'enclosure':
            enclosure_ = child_.text
            enclosure_ = self.gds_validate_string(enclosure_, node, 'enclosure')
            self.enclosure = enclosure_
        elif nodeName_ == 'bay':
            bay_ = child_.text
            bay_ = self.gds_validate_string(bay_, node, 'bay')
            self.bay = bay_
        elif nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'inUse':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'inUse')
            self.inUse = ival_
        elif nodeName_ == 'fcVirtualInitiator':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fcVirtualInitiator')
            self.fcVirtualInitiator = ival_
        elif nodeName_ == 'ethernetVirtualInitiator':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ethernetVirtualInitiator')
            self.ethernetVirtualInitiator = ival_
        elif nodeName_ == 'localDisks':
            obj_ = StorageVolume.factory()
            obj_.build(child_)
            self.localDisks.append(obj_)
        elif nodeName_ == 'validTarget':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'validTarget')
            self.validTarget = ival_
        super(PhysicalServer, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = PhysicalServer.member_data_items_
        if PhysicalServer.superclass != None:
            member_items.update(PhysicalServer.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return PhysicalServer._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = PhysicalServer()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return PhysicalServer.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = PhysicalServer.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class PhysicalServer


class VmHost(PhysicalServer):
    member_data_items_ = {
        'virtualizationType': MemberSpec_('virtualizationType', ['VirtualizationEnum', 'xs:string'], 0),
        'clusterName': MemberSpec_('clusterName', 'xs:string', 0),
        'clusterId': MemberSpec_('clusterId', 'xs:string', 0),
        'storageVolumeIds': MemberSpec_('storageVolumeIds', 'xs:string', 1),
        'virtualSwitches': MemberSpec_('virtualSwitches', 'VirtualSwitch', 1),
        'portGroups': MemberSpec_('portGroups', 'PortGroup', 1),
        'capacityPools': MemberSpec_('capacityPools', 'VmCapacityPool', 1),
        'virtualMachineIds': MemberSpec_('virtualMachineIds', 'xs:string', 1),
        'ftEnabled': MemberSpec_('ftEnabled', 'xs:boolean', 0),
        'liveMoveEnabled': MemberSpec_('liveMoveEnabled', 'xs:boolean', 0),
        'storageMoveEnabled': MemberSpec_('storageMoveEnabled', 'xs:boolean', 0),
        'sharedDisksEnabled': MemberSpec_('sharedDisksEnabled', 'xs:boolean', 0),
        'linkedCloneEnabled': MemberSpec_('linkedCloneEnabled', 'xs:boolean', 0),
        'connectionState': MemberSpec_('connectionState', 'xs:string', 0),
        'isMaintenanceMode': MemberSpec_('isMaintenanceMode', 'xs:boolean', 0),
        'powerState': MemberSpec_('powerState', 'xs:string', 0),
        }
    subclass = None
    superclass = PhysicalServer
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, memorySize=None, processorSpeedMhz=None, processorSpeedTotalMhz=None, processorCount=None, processorCoresCount=None, processorArchitecture=None, serialNumber=None, groupId=None, memoryConsumed=None, processorLoadPercent=None, hyperThreadEnabled=None, os=None, ipAddresses=None, model=None, licensingId=None, enclosure=None, bay=None, uuid=None, inUse=None, fcVirtualInitiator=None, ethernetVirtualInitiator=None, localDisks=None, validTarget=None, virtualizationType=None, clusterName=None, clusterId=None, storageVolumeIds=None, virtualSwitches=None, portGroups=None, capacityPools=None, virtualMachineIds=None, ftEnabled=None, liveMoveEnabled=None, storageMoveEnabled=None, sharedDisksEnabled=None, linkedCloneEnabled=None, connectionState=None, isMaintenanceMode=None, powerState=None):
        super(VmHost, self).__init__(resourceManagerId, utilization, limits, vendorProperties, memorySize, processorSpeedMhz, processorSpeedTotalMhz, processorCount, processorCoresCount, processorArchitecture, serialNumber, groupId, memoryConsumed, processorLoadPercent, hyperThreadEnabled, os, ipAddresses, model, licensingId, enclosure, bay, uuid, inUse, fcVirtualInitiator, ethernetVirtualInitiator, localDisks, validTarget, )
        self.virtualizationType = virtualizationType
        self.clusterName = clusterName
        self.clusterId = clusterId
        if storageVolumeIds is None:
            self.storageVolumeIds = []
        else:
            self.storageVolumeIds = storageVolumeIds
        if virtualSwitches is None:
            self.virtualSwitches = []
        else:
            self.virtualSwitches = virtualSwitches
        if portGroups is None:
            self.portGroups = []
        else:
            self.portGroups = portGroups
        if capacityPools is None:
            self.capacityPools = []
        else:
            self.capacityPools = capacityPools
        if virtualMachineIds is None:
            self.virtualMachineIds = []
        else:
            self.virtualMachineIds = virtualMachineIds
        self.ftEnabled = ftEnabled
        self.liveMoveEnabled = liveMoveEnabled
        self.storageMoveEnabled = storageMoveEnabled
        self.sharedDisksEnabled = sharedDisksEnabled
        self.linkedCloneEnabled = linkedCloneEnabled
        self.connectionState = connectionState
        self.isMaintenanceMode = isMaintenanceMode
        self.powerState = powerState
    def factory(*args_, **kwargs_):
        if VmHost.subclass:
            return VmHost.subclass(*args_, **kwargs_)
        else:
            return VmHost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtualizationType(self): return self.virtualizationType
    def set_virtualizationType(self, virtualizationType): self.virtualizationType = virtualizationType
    virtualizationTypeProp = property(get_virtualizationType, set_virtualizationType)
    def validate_VirtualizationEnum(self, value):
        # Validate type VirtualizationEnum, a restriction on xs:string.
        pass
    def get_clusterName(self): return self.clusterName
    def set_clusterName(self, clusterName): self.clusterName = clusterName
    clusterNameProp = property(get_clusterName, set_clusterName)
    def get_clusterId(self): return self.clusterId
    def set_clusterId(self, clusterId): self.clusterId = clusterId
    clusterIdProp = property(get_clusterId, set_clusterId)
    def get_storageVolumeIds(self): return self.storageVolumeIds
    def set_storageVolumeIds(self, storageVolumeIds): self.storageVolumeIds = storageVolumeIds
    def add_storageVolumeIds(self, value): self.storageVolumeIds.append(value)
    def insert_storageVolumeIds(self, index, value): self.storageVolumeIds[index] = value
    storageVolumeIdsProp = property(get_storageVolumeIds, set_storageVolumeIds)
    def get_virtualSwitches(self): return self.virtualSwitches
    def set_virtualSwitches(self, virtualSwitches): self.virtualSwitches = virtualSwitches
    def add_virtualSwitches(self, value): self.virtualSwitches.append(value)
    def insert_virtualSwitches(self, index, value): self.virtualSwitches[index] = value
    virtualSwitchesProp = property(get_virtualSwitches, set_virtualSwitches)
    def get_portGroups(self): return self.portGroups
    def set_portGroups(self, portGroups): self.portGroups = portGroups
    def add_portGroups(self, value): self.portGroups.append(value)
    def insert_portGroups(self, index, value): self.portGroups[index] = value
    portGroupsProp = property(get_portGroups, set_portGroups)
    def get_capacityPools(self): return self.capacityPools
    def set_capacityPools(self, capacityPools): self.capacityPools = capacityPools
    def add_capacityPools(self, value): self.capacityPools.append(value)
    def insert_capacityPools(self, index, value): self.capacityPools[index] = value
    capacityPoolsProp = property(get_capacityPools, set_capacityPools)
    def get_virtualMachineIds(self): return self.virtualMachineIds
    def set_virtualMachineIds(self, virtualMachineIds): self.virtualMachineIds = virtualMachineIds
    def add_virtualMachineIds(self, value): self.virtualMachineIds.append(value)
    def insert_virtualMachineIds(self, index, value): self.virtualMachineIds[index] = value
    virtualMachineIdsProp = property(get_virtualMachineIds, set_virtualMachineIds)
    def get_ftEnabled(self): return self.ftEnabled
    def set_ftEnabled(self, ftEnabled): self.ftEnabled = ftEnabled
    ftEnabledProp = property(get_ftEnabled, set_ftEnabled)
    def get_liveMoveEnabled(self): return self.liveMoveEnabled
    def set_liveMoveEnabled(self, liveMoveEnabled): self.liveMoveEnabled = liveMoveEnabled
    liveMoveEnabledProp = property(get_liveMoveEnabled, set_liveMoveEnabled)
    def get_storageMoveEnabled(self): return self.storageMoveEnabled
    def set_storageMoveEnabled(self, storageMoveEnabled): self.storageMoveEnabled = storageMoveEnabled
    storageMoveEnabledProp = property(get_storageMoveEnabled, set_storageMoveEnabled)
    def get_sharedDisksEnabled(self): return self.sharedDisksEnabled
    def set_sharedDisksEnabled(self, sharedDisksEnabled): self.sharedDisksEnabled = sharedDisksEnabled
    sharedDisksEnabledProp = property(get_sharedDisksEnabled, set_sharedDisksEnabled)
    def get_linkedCloneEnabled(self): return self.linkedCloneEnabled
    def set_linkedCloneEnabled(self, linkedCloneEnabled): self.linkedCloneEnabled = linkedCloneEnabled
    linkedCloneEnabledProp = property(get_linkedCloneEnabled, set_linkedCloneEnabled)
    def get_connectionState(self): return self.connectionState
    def set_connectionState(self, connectionState): self.connectionState = connectionState
    connectionStateProp = property(get_connectionState, set_connectionState)
    def get_isMaintenanceMode(self): return self.isMaintenanceMode
    def set_isMaintenanceMode(self, isMaintenanceMode): self.isMaintenanceMode = isMaintenanceMode
    isMaintenanceModeProp = property(get_isMaintenanceMode, set_isMaintenanceMode)
    def get_powerState(self): return self.powerState
    def set_powerState(self, powerState): self.powerState = powerState
    powerStateProp = property(get_powerState, set_powerState)
    def export(self, outfile, level, namespace_='', name_='VmHost', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmHost')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmHost'):
        super(VmHost, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmHost')
    def exportChildren(self, outfile, level, namespace_='', name_='VmHost', fromsubclass_=False):
        super(VmHost, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtualizationType>%s</%svirtualizationType>\n' % (namespace_, self.gds_format_string(quote_xml(self.virtualizationType).encode(ExternalEncoding), input_name='virtualizationType'), namespace_))
        if self.clusterName is not None:
            showIndent(outfile, level)
            outfile.write('<%sclusterName>%s</%sclusterName>\n' % (namespace_, self.gds_format_string(quote_xml(self.clusterName).encode(ExternalEncoding), input_name='clusterName'), namespace_))
        if self.clusterId is not None:
            showIndent(outfile, level)
            outfile.write('<%sclusterId>%s</%sclusterId>\n' % (namespace_, self.gds_format_string(quote_xml(self.clusterId).encode(ExternalEncoding), input_name='clusterId'), namespace_))
        for storageVolumeIds_ in self.storageVolumeIds:
            showIndent(outfile, level)
            outfile.write('<%sstorageVolumeIds>%s</%sstorageVolumeIds>\n' % (namespace_, self.gds_format_string(quote_xml(storageVolumeIds_).encode(ExternalEncoding), input_name='storageVolumeIds'), namespace_))
        for virtualSwitches_ in self.virtualSwitches:
            virtualSwitches_.export(outfile, level, namespace_, name_='virtualSwitches')
        for portGroups_ in self.portGroups:
            portGroups_.export(outfile, level, namespace_, name_='portGroups')
        for capacityPools_ in self.capacityPools:
            capacityPools_.export(outfile, level, namespace_, name_='capacityPools')
        for virtualMachineIds_ in self.virtualMachineIds:
            showIndent(outfile, level)
            outfile.write('<%svirtualMachineIds>%s</%svirtualMachineIds>\n' % (namespace_, self.gds_format_string(quote_xml(virtualMachineIds_).encode(ExternalEncoding), input_name='virtualMachineIds'), namespace_))
        if self.ftEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sftEnabled>%s</%sftEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.ftEnabled)), input_name='ftEnabled'), namespace_))
        if self.liveMoveEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sliveMoveEnabled>%s</%sliveMoveEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.liveMoveEnabled)), input_name='liveMoveEnabled'), namespace_))
        if self.storageMoveEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageMoveEnabled>%s</%sstorageMoveEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.storageMoveEnabled)), input_name='storageMoveEnabled'), namespace_))
        if self.sharedDisksEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%ssharedDisksEnabled>%s</%ssharedDisksEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.sharedDisksEnabled)), input_name='sharedDisksEnabled'), namespace_))
        if self.linkedCloneEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%slinkedCloneEnabled>%s</%slinkedCloneEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.linkedCloneEnabled)), input_name='linkedCloneEnabled'), namespace_))
        if self.connectionState is not None:
            showIndent(outfile, level)
            outfile.write('<%sconnectionState>%s</%sconnectionState>\n' % (namespace_, self.gds_format_string(quote_xml(self.connectionState).encode(ExternalEncoding), input_name='connectionState'), namespace_))
        if self.isMaintenanceMode is not None:
            showIndent(outfile, level)
            outfile.write('<%sisMaintenanceMode>%s</%sisMaintenanceMode>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isMaintenanceMode)), input_name='isMaintenanceMode'), namespace_))
        if self.powerState is not None:
            showIndent(outfile, level)
            outfile.write('<%spowerState>%s</%spowerState>\n' % (namespace_, self.gds_format_string(quote_xml(self.powerState).encode(ExternalEncoding), input_name='powerState'), namespace_))
    def hasContent_(self):
        if (
            self.virtualizationType is not None or
            self.clusterName is not None or
            self.clusterId is not None or
            self.storageVolumeIds or
            self.virtualSwitches or
            self.portGroups or
            self.capacityPools or
            self.virtualMachineIds or
            self.ftEnabled is not None or
            self.liveMoveEnabled is not None or
            self.storageMoveEnabled is not None or
            self.sharedDisksEnabled is not None or
            self.linkedCloneEnabled is not None or
            self.connectionState is not None or
            self.isMaintenanceMode is not None or
            self.powerState is not None or
            super(VmHost, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmHost'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmHost, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmHost, self).exportLiteralChildren(outfile, level, name_)
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('virtualizationType=%s,\n' % quote_python(self.virtualizationType).encode(ExternalEncoding))
        if self.clusterName is not None:
            showIndent(outfile, level)
            outfile.write('clusterName=%s,\n' % quote_python(self.clusterName).encode(ExternalEncoding))
        if self.clusterId is not None:
            showIndent(outfile, level)
            outfile.write('clusterId=%s,\n' % quote_python(self.clusterId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('storageVolumeIds=[\n')
        level += 1
        for storageVolumeIds_ in self.storageVolumeIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(storageVolumeIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('virtualSwitches=[\n')
        level += 1
        for virtualSwitches_ in self.virtualSwitches:
            showIndent(outfile, level)
            outfile.write('model_.VirtualSwitch(\n')
            virtualSwitches_.exportLiteral(outfile, level, name_='VirtualSwitch')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('portGroups=[\n')
        level += 1
        for portGroups_ in self.portGroups:
            showIndent(outfile, level)
            outfile.write('model_.PortGroup(\n')
            portGroups_.exportLiteral(outfile, level, name_='PortGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('capacityPools=[\n')
        level += 1
        for capacityPools_ in self.capacityPools:
            showIndent(outfile, level)
            outfile.write('model_.VmCapacityPool(\n')
            capacityPools_.exportLiteral(outfile, level, name_='VmCapacityPool')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('virtualMachineIds=[\n')
        level += 1
        for virtualMachineIds_ in self.virtualMachineIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(virtualMachineIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ftEnabled is not None:
            showIndent(outfile, level)
            outfile.write('ftEnabled=%s,\n' % self.ftEnabled)
        if self.liveMoveEnabled is not None:
            showIndent(outfile, level)
            outfile.write('liveMoveEnabled=%s,\n' % self.liveMoveEnabled)
        if self.storageMoveEnabled is not None:
            showIndent(outfile, level)
            outfile.write('storageMoveEnabled=%s,\n' % self.storageMoveEnabled)
        if self.sharedDisksEnabled is not None:
            showIndent(outfile, level)
            outfile.write('sharedDisksEnabled=%s,\n' % self.sharedDisksEnabled)
        if self.linkedCloneEnabled is not None:
            showIndent(outfile, level)
            outfile.write('linkedCloneEnabled=%s,\n' % self.linkedCloneEnabled)
        if self.connectionState is not None:
            showIndent(outfile, level)
            outfile.write('connectionState=%s,\n' % quote_python(self.connectionState).encode(ExternalEncoding))
        if self.isMaintenanceMode is not None:
            showIndent(outfile, level)
            outfile.write('isMaintenanceMode=%s,\n' % self.isMaintenanceMode)
        if self.powerState is not None:
            showIndent(outfile, level)
            outfile.write('powerState=%s,\n' % quote_python(self.powerState).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmHost, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'virtualizationType':
            virtualizationType_ = child_.text
            virtualizationType_ = self.gds_validate_string(virtualizationType_, node, 'virtualizationType')
            self.virtualizationType = virtualizationType_
            self.validate_VirtualizationEnum(self.virtualizationType)    # validate type VirtualizationEnum
        elif nodeName_ == 'clusterName':
            clusterName_ = child_.text
            clusterName_ = self.gds_validate_string(clusterName_, node, 'clusterName')
            self.clusterName = clusterName_
        elif nodeName_ == 'clusterId':
            clusterId_ = child_.text
            clusterId_ = self.gds_validate_string(clusterId_, node, 'clusterId')
            self.clusterId = clusterId_
        elif nodeName_ == 'storageVolumeIds':
            storageVolumeIds_ = child_.text
            storageVolumeIds_ = self.gds_validate_string(storageVolumeIds_, node, 'storageVolumeIds')
            self.storageVolumeIds.append(storageVolumeIds_)
        elif nodeName_ == 'virtualSwitches':
            obj_ = VirtualSwitch.factory()
            obj_.build(child_)
            self.virtualSwitches.append(obj_)
        elif nodeName_ == 'portGroups':
            obj_ = PortGroup.factory()
            obj_.build(child_)
            self.portGroups.append(obj_)
        elif nodeName_ == 'capacityPools':
            obj_ = VmCapacityPool.factory()
            obj_.build(child_)
            self.capacityPools.append(obj_)
        elif nodeName_ == 'virtualMachineIds':
            virtualMachineIds_ = child_.text
            virtualMachineIds_ = self.gds_validate_string(virtualMachineIds_, node, 'virtualMachineIds')
            self.virtualMachineIds.append(virtualMachineIds_)
        elif nodeName_ == 'ftEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ftEnabled')
            self.ftEnabled = ival_
        elif nodeName_ == 'liveMoveEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'liveMoveEnabled')
            self.liveMoveEnabled = ival_
        elif nodeName_ == 'storageMoveEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'storageMoveEnabled')
            self.storageMoveEnabled = ival_
        elif nodeName_ == 'sharedDisksEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'sharedDisksEnabled')
            self.sharedDisksEnabled = ival_
        elif nodeName_ == 'linkedCloneEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'linkedCloneEnabled')
            self.linkedCloneEnabled = ival_
        elif nodeName_ == 'connectionState':
            connectionState_ = child_.text
            connectionState_ = self.gds_validate_string(connectionState_, node, 'connectionState')
            self.connectionState = connectionState_
        elif nodeName_ == 'isMaintenanceMode':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isMaintenanceMode')
            self.isMaintenanceMode = ival_
        elif nodeName_ == 'powerState':
            powerState_ = child_.text
            powerState_ = self.gds_validate_string(powerState_, node, 'powerState')
            self.powerState = powerState_
        super(VmHost, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmHost.member_data_items_
        if VmHost.superclass != None:
            member_items.update(VmHost.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmHost._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmHost()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmHost.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmHost.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmHost


class VmCluster(ComputeCluster):
    member_data_items_ = {
        'virtualizationType': MemberSpec_('virtualizationType', ['VirtualizationEnum', 'xs:string'], 0),
        'capabilities': MemberSpec_('capabilities', 'VmClusterCapabilities', 0),
        'hosts': MemberSpec_('hosts', 'VmHost', 1),
        'storageVolumeIds': MemberSpec_('storageVolumeIds', 'xs:string', 1),
        'virtualSwitches': MemberSpec_('virtualSwitches', 'VirtualSwitch', 1),
        'portGroups': MemberSpec_('portGroups', 'PortGroup', 1),
        'capacityPools': MemberSpec_('capacityPools', 'VmCapacityPool', 1),
        'virtualMachineIds': MemberSpec_('virtualMachineIds', 'xs:string', 1),
        }
    subclass = None
    superclass = ComputeCluster
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, processorSpeedTotalMhz=None, memorySize=None, processorCoresCount=None, hostsCount=None, effectiveHostsCount=None, effectiveProcessorSpeedTotalMhz=None, effectiveMemorySize=None, memoryConsumed=None, processorLoadPercent=None, computeServers=None, virtualizationType=None, capabilities=None, hosts=None, storageVolumeIds=None, virtualSwitches=None, portGroups=None, capacityPools=None, virtualMachineIds=None):
        super(VmCluster, self).__init__(resourceManagerId, utilization, limits, vendorProperties, processorSpeedTotalMhz, memorySize, processorCoresCount, hostsCount, effectiveHostsCount, effectiveProcessorSpeedTotalMhz, effectiveMemorySize, memoryConsumed, processorLoadPercent, computeServers, )
        self.virtualizationType = virtualizationType
        self.capabilities = capabilities
        if hosts is None:
            self.hosts = []
        else:
            self.hosts = hosts
        if storageVolumeIds is None:
            self.storageVolumeIds = []
        else:
            self.storageVolumeIds = storageVolumeIds
        if virtualSwitches is None:
            self.virtualSwitches = []
        else:
            self.virtualSwitches = virtualSwitches
        if portGroups is None:
            self.portGroups = []
        else:
            self.portGroups = portGroups
        if capacityPools is None:
            self.capacityPools = []
        else:
            self.capacityPools = capacityPools
        if virtualMachineIds is None:
            self.virtualMachineIds = []
        else:
            self.virtualMachineIds = virtualMachineIds
    def factory(*args_, **kwargs_):
        if VmCluster.subclass:
            return VmCluster.subclass(*args_, **kwargs_)
        else:
            return VmCluster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtualizationType(self): return self.virtualizationType
    def set_virtualizationType(self, virtualizationType): self.virtualizationType = virtualizationType
    virtualizationTypeProp = property(get_virtualizationType, set_virtualizationType)
    def validate_VirtualizationEnum(self, value):
        # Validate type VirtualizationEnum, a restriction on xs:string.
        pass
    def get_capabilities(self): return self.capabilities
    def set_capabilities(self, capabilities): self.capabilities = capabilities
    capabilitiesProp = property(get_capabilities, set_capabilities)
    def get_hosts(self): return self.hosts
    def set_hosts(self, hosts): self.hosts = hosts
    def add_hosts(self, value): self.hosts.append(value)
    def insert_hosts(self, index, value): self.hosts[index] = value
    hostsProp = property(get_hosts, set_hosts)
    def get_storageVolumeIds(self): return self.storageVolumeIds
    def set_storageVolumeIds(self, storageVolumeIds): self.storageVolumeIds = storageVolumeIds
    def add_storageVolumeIds(self, value): self.storageVolumeIds.append(value)
    def insert_storageVolumeIds(self, index, value): self.storageVolumeIds[index] = value
    storageVolumeIdsProp = property(get_storageVolumeIds, set_storageVolumeIds)
    def get_virtualSwitches(self): return self.virtualSwitches
    def set_virtualSwitches(self, virtualSwitches): self.virtualSwitches = virtualSwitches
    def add_virtualSwitches(self, value): self.virtualSwitches.append(value)
    def insert_virtualSwitches(self, index, value): self.virtualSwitches[index] = value
    virtualSwitchesProp = property(get_virtualSwitches, set_virtualSwitches)
    def get_portGroups(self): return self.portGroups
    def set_portGroups(self, portGroups): self.portGroups = portGroups
    def add_portGroups(self, value): self.portGroups.append(value)
    def insert_portGroups(self, index, value): self.portGroups[index] = value
    portGroupsProp = property(get_portGroups, set_portGroups)
    def get_capacityPools(self): return self.capacityPools
    def set_capacityPools(self, capacityPools): self.capacityPools = capacityPools
    def add_capacityPools(self, value): self.capacityPools.append(value)
    def insert_capacityPools(self, index, value): self.capacityPools[index] = value
    capacityPoolsProp = property(get_capacityPools, set_capacityPools)
    def get_virtualMachineIds(self): return self.virtualMachineIds
    def set_virtualMachineIds(self, virtualMachineIds): self.virtualMachineIds = virtualMachineIds
    def add_virtualMachineIds(self, value): self.virtualMachineIds.append(value)
    def insert_virtualMachineIds(self, index, value): self.virtualMachineIds[index] = value
    virtualMachineIdsProp = property(get_virtualMachineIds, set_virtualMachineIds)
    def export(self, outfile, level, namespace_='', name_='VmCluster', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmCluster')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmCluster'):
        super(VmCluster, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmCluster')
    def exportChildren(self, outfile, level, namespace_='', name_='VmCluster', fromsubclass_=False):
        super(VmCluster, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtualizationType>%s</%svirtualizationType>\n' % (namespace_, self.gds_format_string(quote_xml(self.virtualizationType).encode(ExternalEncoding), input_name='virtualizationType'), namespace_))
        if self.capabilities is not None:
            self.capabilities.export(outfile, level, namespace_, name_='capabilities')
        for hosts_ in self.hosts:
            hosts_.export(outfile, level, namespace_, name_='hosts')
        for storageVolumeIds_ in self.storageVolumeIds:
            showIndent(outfile, level)
            outfile.write('<%sstorageVolumeIds>%s</%sstorageVolumeIds>\n' % (namespace_, self.gds_format_string(quote_xml(storageVolumeIds_).encode(ExternalEncoding), input_name='storageVolumeIds'), namespace_))
        for virtualSwitches_ in self.virtualSwitches:
            virtualSwitches_.export(outfile, level, namespace_, name_='virtualSwitches')
        for portGroups_ in self.portGroups:
            portGroups_.export(outfile, level, namespace_, name_='portGroups')
        for capacityPools_ in self.capacityPools:
            capacityPools_.export(outfile, level, namespace_, name_='capacityPools')
        for virtualMachineIds_ in self.virtualMachineIds:
            showIndent(outfile, level)
            outfile.write('<%svirtualMachineIds>%s</%svirtualMachineIds>\n' % (namespace_, self.gds_format_string(quote_xml(virtualMachineIds_).encode(ExternalEncoding), input_name='virtualMachineIds'), namespace_))
    def hasContent_(self):
        if (
            self.virtualizationType is not None or
            self.capabilities is not None or
            self.hosts or
            self.storageVolumeIds or
            self.virtualSwitches or
            self.portGroups or
            self.capacityPools or
            self.virtualMachineIds or
            super(VmCluster, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmCluster'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmCluster, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmCluster, self).exportLiteralChildren(outfile, level, name_)
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('virtualizationType=%s,\n' % quote_python(self.virtualizationType).encode(ExternalEncoding))
        if self.capabilities is not None:
            showIndent(outfile, level)
            outfile.write('capabilities=model_.VmClusterCapabilities(\n')
            self.capabilities.exportLiteral(outfile, level, name_='capabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('hosts=[\n')
        level += 1
        for hosts_ in self.hosts:
            showIndent(outfile, level)
            outfile.write('model_.VmHost(\n')
            hosts_.exportLiteral(outfile, level, name_='VmHost')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('storageVolumeIds=[\n')
        level += 1
        for storageVolumeIds_ in self.storageVolumeIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(storageVolumeIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('virtualSwitches=[\n')
        level += 1
        for virtualSwitches_ in self.virtualSwitches:
            showIndent(outfile, level)
            outfile.write('model_.VirtualSwitch(\n')
            virtualSwitches_.exportLiteral(outfile, level, name_='VirtualSwitch')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('portGroups=[\n')
        level += 1
        for portGroups_ in self.portGroups:
            showIndent(outfile, level)
            outfile.write('model_.PortGroup(\n')
            portGroups_.exportLiteral(outfile, level, name_='PortGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('capacityPools=[\n')
        level += 1
        for capacityPools_ in self.capacityPools:
            showIndent(outfile, level)
            outfile.write('model_.VmCapacityPool(\n')
            capacityPools_.exportLiteral(outfile, level, name_='VmCapacityPool')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('virtualMachineIds=[\n')
        level += 1
        for virtualMachineIds_ in self.virtualMachineIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(virtualMachineIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmCluster, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'virtualizationType':
            virtualizationType_ = child_.text
            virtualizationType_ = self.gds_validate_string(virtualizationType_, node, 'virtualizationType')
            self.virtualizationType = virtualizationType_
            self.validate_VirtualizationEnum(self.virtualizationType)    # validate type VirtualizationEnum
        elif nodeName_ == 'capabilities':
            obj_ = VmClusterCapabilities.factory()
            obj_.build(child_)
            self.set_capabilities(obj_)
        elif nodeName_ == 'hosts':
            obj_ = VmHost.factory()
            obj_.build(child_)
            self.hosts.append(obj_)
        elif nodeName_ == 'storageVolumeIds':
            storageVolumeIds_ = child_.text
            storageVolumeIds_ = self.gds_validate_string(storageVolumeIds_, node, 'storageVolumeIds')
            self.storageVolumeIds.append(storageVolumeIds_)
        elif nodeName_ == 'virtualSwitches':
            obj_ = VirtualSwitch.factory()
            obj_.build(child_)
            self.virtualSwitches.append(obj_)
        elif nodeName_ == 'portGroups':
            obj_ = PortGroup.factory()
            obj_.build(child_)
            self.portGroups.append(obj_)
        elif nodeName_ == 'capacityPools':
            obj_ = VmCapacityPool.factory()
            obj_.build(child_)
            self.capacityPools.append(obj_)
        elif nodeName_ == 'virtualMachineIds':
            virtualMachineIds_ = child_.text
            virtualMachineIds_ = self.gds_validate_string(virtualMachineIds_, node, 'virtualMachineIds')
            self.virtualMachineIds.append(virtualMachineIds_)
        super(VmCluster, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmCluster.member_data_items_
        if VmCluster.superclass != None:
            member_items.update(VmCluster.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmCluster._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmCluster()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmCluster.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmCluster.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmCluster


class Vm(ComputeServer):
    member_data_items_ = {
        'connectionState': MemberSpec_('connectionState', 'xs:string', 0),
        'bootOrder': MemberSpec_('bootOrder', 'xs:string', 0),
        'powerState': MemberSpec_('powerState', 'xs:string', 0),
        'virtualizationType': MemberSpec_('virtualizationType', ['VirtualizationEnum', 'xs:string'], 0),
        'ipAddresses': MemberSpec_('ipAddresses', 'IpProfile', 1),
        'os': MemberSpec_('os', 'OsProfile', 0),
        'vmNetAdapters': MemberSpec_('vmNetAdapters', 'VmNetAdapter', 1),
        'vmScsiControllers': MemberSpec_('vmScsiControllers', 'VmScsiController', 1),
        'vmDisks': MemberSpec_('vmDisks', 'VmDisk', 1),
        'vmGenericDevices': MemberSpec_('vmGenericDevices', 'VmGenericDevice', 1),
        'vmGlobalSettings': MemberSpec_('vmGlobalSettings', 'VmGlobalSettings', 0),
        'capabilities': MemberSpec_('capabilities', 'VmCapabilities', 0),
        'templateId': MemberSpec_('templateId', 'xs:string', 0),
        'vmHostId': MemberSpec_('vmHostId', 'xs:string', 0),
        'cpuResourceAllocation': MemberSpec_('cpuResourceAllocation', 'ResourceAllocation', 0),
        'memoryResourceAllocation': MemberSpec_('memoryResourceAllocation', 'ResourceAllocation', 0),
        }
    subclass = None
    superclass = ComputeServer
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, memorySize=None, processorSpeedMhz=None, processorSpeedTotalMhz=None, processorCount=None, processorCoresCount=None, processorArchitecture=None, serialNumber=None, groupId=None, memoryConsumed=None, processorLoadPercent=None, hyperThreadEnabled=None, connectionState=None, bootOrder=None, powerState=None, virtualizationType=None, ipAddresses=None, os=None, vmNetAdapters=None, vmScsiControllers=None, vmDisks=None, vmGenericDevices=None, vmGlobalSettings=None, capabilities=None, templateId=None, vmHostId=None, cpuResourceAllocation=None, memoryResourceAllocation=None):
        super(Vm, self).__init__(resourceManagerId, utilization, limits, vendorProperties, memorySize, processorSpeedMhz, processorSpeedTotalMhz, processorCount, processorCoresCount, processorArchitecture, serialNumber, groupId, memoryConsumed, processorLoadPercent, hyperThreadEnabled, )
        self.connectionState = connectionState
        self.bootOrder = bootOrder
        self.powerState = powerState
        self.virtualizationType = virtualizationType
        if ipAddresses is None:
            self.ipAddresses = []
        else:
            self.ipAddresses = ipAddresses
        self.os = os
        if vmNetAdapters is None:
            self.vmNetAdapters = []
        else:
            self.vmNetAdapters = vmNetAdapters
        if vmScsiControllers is None:
            self.vmScsiControllers = []
        else:
            self.vmScsiControllers = vmScsiControllers
        if vmDisks is None:
            self.vmDisks = []
        else:
            self.vmDisks = vmDisks
        if vmGenericDevices is None:
            self.vmGenericDevices = []
        else:
            self.vmGenericDevices = vmGenericDevices
        self.vmGlobalSettings = vmGlobalSettings
        self.capabilities = capabilities
        self.templateId = templateId
        self.vmHostId = vmHostId
        self.cpuResourceAllocation = cpuResourceAllocation
        self.memoryResourceAllocation = memoryResourceAllocation
    def factory(*args_, **kwargs_):
        if Vm.subclass:
            return Vm.subclass(*args_, **kwargs_)
        else:
            return Vm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectionState(self): return self.connectionState
    def set_connectionState(self, connectionState): self.connectionState = connectionState
    connectionStateProp = property(get_connectionState, set_connectionState)
    def get_bootOrder(self): return self.bootOrder
    def set_bootOrder(self, bootOrder): self.bootOrder = bootOrder
    bootOrderProp = property(get_bootOrder, set_bootOrder)
    def get_powerState(self): return self.powerState
    def set_powerState(self, powerState): self.powerState = powerState
    powerStateProp = property(get_powerState, set_powerState)
    def get_virtualizationType(self): return self.virtualizationType
    def set_virtualizationType(self, virtualizationType): self.virtualizationType = virtualizationType
    virtualizationTypeProp = property(get_virtualizationType, set_virtualizationType)
    def validate_VirtualizationEnum(self, value):
        # Validate type VirtualizationEnum, a restriction on xs:string.
        pass
    def get_ipAddresses(self): return self.ipAddresses
    def set_ipAddresses(self, ipAddresses): self.ipAddresses = ipAddresses
    def add_ipAddresses(self, value): self.ipAddresses.append(value)
    def insert_ipAddresses(self, index, value): self.ipAddresses[index] = value
    ipAddressesProp = property(get_ipAddresses, set_ipAddresses)
    def get_os(self): return self.os
    def set_os(self, os): self.os = os
    osProp = property(get_os, set_os)
    def get_vmNetAdapters(self): return self.vmNetAdapters
    def set_vmNetAdapters(self, vmNetAdapters): self.vmNetAdapters = vmNetAdapters
    def add_vmNetAdapters(self, value): self.vmNetAdapters.append(value)
    def insert_vmNetAdapters(self, index, value): self.vmNetAdapters[index] = value
    vmNetAdaptersProp = property(get_vmNetAdapters, set_vmNetAdapters)
    def get_vmScsiControllers(self): return self.vmScsiControllers
    def set_vmScsiControllers(self, vmScsiControllers): self.vmScsiControllers = vmScsiControllers
    def add_vmScsiControllers(self, value): self.vmScsiControllers.append(value)
    def insert_vmScsiControllers(self, index, value): self.vmScsiControllers[index] = value
    vmScsiControllersProp = property(get_vmScsiControllers, set_vmScsiControllers)
    def get_vmDisks(self): return self.vmDisks
    def set_vmDisks(self, vmDisks): self.vmDisks = vmDisks
    def add_vmDisks(self, value): self.vmDisks.append(value)
    def insert_vmDisks(self, index, value): self.vmDisks[index] = value
    vmDisksProp = property(get_vmDisks, set_vmDisks)
    def get_vmGenericDevices(self): return self.vmGenericDevices
    def set_vmGenericDevices(self, vmGenericDevices): self.vmGenericDevices = vmGenericDevices
    def add_vmGenericDevices(self, value): self.vmGenericDevices.append(value)
    def insert_vmGenericDevices(self, index, value): self.vmGenericDevices[index] = value
    vmGenericDevicesProp = property(get_vmGenericDevices, set_vmGenericDevices)
    def get_vmGlobalSettings(self): return self.vmGlobalSettings
    def set_vmGlobalSettings(self, vmGlobalSettings): self.vmGlobalSettings = vmGlobalSettings
    vmGlobalSettingsProp = property(get_vmGlobalSettings, set_vmGlobalSettings)
    def get_capabilities(self): return self.capabilities
    def set_capabilities(self, capabilities): self.capabilities = capabilities
    capabilitiesProp = property(get_capabilities, set_capabilities)
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    templateIdProp = property(get_templateId, set_templateId)
    def get_vmHostId(self): return self.vmHostId
    def set_vmHostId(self, vmHostId): self.vmHostId = vmHostId
    vmHostIdProp = property(get_vmHostId, set_vmHostId)
    def get_cpuResourceAllocation(self): return self.cpuResourceAllocation
    def set_cpuResourceAllocation(self, cpuResourceAllocation): self.cpuResourceAllocation = cpuResourceAllocation
    cpuResourceAllocationProp = property(get_cpuResourceAllocation, set_cpuResourceAllocation)
    def get_memoryResourceAllocation(self): return self.memoryResourceAllocation
    def set_memoryResourceAllocation(self, memoryResourceAllocation): self.memoryResourceAllocation = memoryResourceAllocation
    memoryResourceAllocationProp = property(get_memoryResourceAllocation, set_memoryResourceAllocation)
    def export(self, outfile, level, namespace_='', name_='Vm', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Vm')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Vm'):
        super(Vm, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Vm')
    def exportChildren(self, outfile, level, namespace_='', name_='Vm', fromsubclass_=False):
        super(Vm, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.connectionState is not None:
            showIndent(outfile, level)
            outfile.write('<%sconnectionState>%s</%sconnectionState>\n' % (namespace_, self.gds_format_string(quote_xml(self.connectionState).encode(ExternalEncoding), input_name='connectionState'), namespace_))
        if self.bootOrder is not None:
            showIndent(outfile, level)
            outfile.write('<%sbootOrder>%s</%sbootOrder>\n' % (namespace_, self.gds_format_string(quote_xml(self.bootOrder).encode(ExternalEncoding), input_name='bootOrder'), namespace_))
        if self.powerState is not None:
            showIndent(outfile, level)
            outfile.write('<%spowerState>%s</%spowerState>\n' % (namespace_, self.gds_format_string(quote_xml(self.powerState).encode(ExternalEncoding), input_name='powerState'), namespace_))
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtualizationType>%s</%svirtualizationType>\n' % (namespace_, self.gds_format_string(quote_xml(self.virtualizationType).encode(ExternalEncoding), input_name='virtualizationType'), namespace_))
        for ipAddresses_ in self.ipAddresses:
            ipAddresses_.export(outfile, level, namespace_, name_='ipAddresses')
        if self.os is not None:
            self.os.export(outfile, level, namespace_, name_='os')
        for vmNetAdapters_ in self.vmNetAdapters:
            vmNetAdapters_.export(outfile, level, namespace_, name_='vmNetAdapters')
        for vmScsiControllers_ in self.vmScsiControllers:
            vmScsiControllers_.export(outfile, level, namespace_, name_='vmScsiControllers')
        for vmDisks_ in self.vmDisks:
            vmDisks_.export(outfile, level, namespace_, name_='vmDisks')
        for vmGenericDevices_ in self.vmGenericDevices:
            vmGenericDevices_.export(outfile, level, namespace_, name_='vmGenericDevices')
        if self.vmGlobalSettings is not None:
            self.vmGlobalSettings.export(outfile, level, namespace_, name_='vmGlobalSettings')
        if self.capabilities is not None:
            self.capabilities.export(outfile, level, namespace_, name_='capabilities')
        if self.templateId is not None:
            showIndent(outfile, level)
            outfile.write('<%stemplateId>%s</%stemplateId>\n' % (namespace_, self.gds_format_string(quote_xml(self.templateId).encode(ExternalEncoding), input_name='templateId'), namespace_))
        if self.vmHostId is not None:
            showIndent(outfile, level)
            outfile.write('<%svmHostId>%s</%svmHostId>\n' % (namespace_, self.gds_format_string(quote_xml(self.vmHostId).encode(ExternalEncoding), input_name='vmHostId'), namespace_))
        if self.cpuResourceAllocation is not None:
            self.cpuResourceAllocation.export(outfile, level, namespace_, name_='cpuResourceAllocation')
        if self.memoryResourceAllocation is not None:
            self.memoryResourceAllocation.export(outfile, level, namespace_, name_='memoryResourceAllocation')
    def hasContent_(self):
        if (
            self.connectionState is not None or
            self.bootOrder is not None or
            self.powerState is not None or
            self.virtualizationType is not None or
            self.ipAddresses or
            self.os is not None or
            self.vmNetAdapters or
            self.vmScsiControllers or
            self.vmDisks or
            self.vmGenericDevices or
            self.vmGlobalSettings is not None or
            self.capabilities is not None or
            self.templateId is not None or
            self.vmHostId is not None or
            self.cpuResourceAllocation is not None or
            self.memoryResourceAllocation is not None or
            super(Vm, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Vm'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Vm, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Vm, self).exportLiteralChildren(outfile, level, name_)
        if self.connectionState is not None:
            showIndent(outfile, level)
            outfile.write('connectionState=%s,\n' % quote_python(self.connectionState).encode(ExternalEncoding))
        if self.bootOrder is not None:
            showIndent(outfile, level)
            outfile.write('bootOrder=%s,\n' % quote_python(self.bootOrder).encode(ExternalEncoding))
        if self.powerState is not None:
            showIndent(outfile, level)
            outfile.write('powerState=%s,\n' % quote_python(self.powerState).encode(ExternalEncoding))
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('virtualizationType=%s,\n' % quote_python(self.virtualizationType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ipAddresses=[\n')
        level += 1
        for ipAddresses_ in self.ipAddresses:
            showIndent(outfile, level)
            outfile.write('model_.IpProfile(\n')
            ipAddresses_.exportLiteral(outfile, level, name_='IpProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.os is not None:
            showIndent(outfile, level)
            outfile.write('os=model_.OsProfile(\n')
            self.os.exportLiteral(outfile, level, name_='os')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('vmNetAdapters=[\n')
        level += 1
        for vmNetAdapters_ in self.vmNetAdapters:
            showIndent(outfile, level)
            outfile.write('model_.VmNetAdapter(\n')
            vmNetAdapters_.exportLiteral(outfile, level, name_='VmNetAdapter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmScsiControllers=[\n')
        level += 1
        for vmScsiControllers_ in self.vmScsiControllers:
            showIndent(outfile, level)
            outfile.write('model_.VmScsiController(\n')
            vmScsiControllers_.exportLiteral(outfile, level, name_='VmScsiController')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmDisks=[\n')
        level += 1
        for vmDisks_ in self.vmDisks:
            showIndent(outfile, level)
            outfile.write('model_.VmDisk(\n')
            vmDisks_.exportLiteral(outfile, level, name_='VmDisk')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmGenericDevices=[\n')
        level += 1
        for vmGenericDevices_ in self.vmGenericDevices:
            showIndent(outfile, level)
            outfile.write('model_.VmGenericDevice(\n')
            vmGenericDevices_.exportLiteral(outfile, level, name_='VmGenericDevice')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.vmGlobalSettings is not None:
            showIndent(outfile, level)
            outfile.write('vmGlobalSettings=model_.VmGlobalSettings(\n')
            self.vmGlobalSettings.exportLiteral(outfile, level, name_='vmGlobalSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.capabilities is not None:
            showIndent(outfile, level)
            outfile.write('capabilities=model_.VmCapabilities(\n')
            self.capabilities.exportLiteral(outfile, level, name_='capabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.templateId is not None:
            showIndent(outfile, level)
            outfile.write('templateId=%s,\n' % quote_python(self.templateId).encode(ExternalEncoding))
        if self.vmHostId is not None:
            showIndent(outfile, level)
            outfile.write('vmHostId=%s,\n' % quote_python(self.vmHostId).encode(ExternalEncoding))
        if self.cpuResourceAllocation is not None:
            showIndent(outfile, level)
            outfile.write('cpuResourceAllocation=model_.ResourceAllocation(\n')
            self.cpuResourceAllocation.exportLiteral(outfile, level, name_='cpuResourceAllocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.memoryResourceAllocation is not None:
            showIndent(outfile, level)
            outfile.write('memoryResourceAllocation=model_.ResourceAllocation(\n')
            self.memoryResourceAllocation.exportLiteral(outfile, level, name_='memoryResourceAllocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Vm, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'connectionState':
            connectionState_ = child_.text
            connectionState_ = self.gds_validate_string(connectionState_, node, 'connectionState')
            self.connectionState = connectionState_
        elif nodeName_ == 'bootOrder':
            bootOrder_ = child_.text
            bootOrder_ = self.gds_validate_string(bootOrder_, node, 'bootOrder')
            self.bootOrder = bootOrder_
        elif nodeName_ == 'powerState':
            powerState_ = child_.text
            powerState_ = self.gds_validate_string(powerState_, node, 'powerState')
            self.powerState = powerState_
        elif nodeName_ == 'virtualizationType':
            virtualizationType_ = child_.text
            virtualizationType_ = self.gds_validate_string(virtualizationType_, node, 'virtualizationType')
            self.virtualizationType = virtualizationType_
            self.validate_VirtualizationEnum(self.virtualizationType)    # validate type VirtualizationEnum
        elif nodeName_ == 'ipAddresses':
            obj_ = IpProfile.factory()
            obj_.build(child_)
            self.ipAddresses.append(obj_)
        elif nodeName_ == 'os':
            obj_ = OsProfile.factory()
            obj_.build(child_)
            self.set_os(obj_)
        elif nodeName_ == 'vmNetAdapters':
            obj_ = VmNetAdapter.factory()
            obj_.build(child_)
            self.vmNetAdapters.append(obj_)
        elif nodeName_ == 'vmScsiControllers':
            obj_ = VmScsiController.factory()
            obj_.build(child_)
            self.vmScsiControllers.append(obj_)
        elif nodeName_ == 'vmDisks':
            obj_ = VmDisk.factory()
            obj_.build(child_)
            self.vmDisks.append(obj_)
        elif nodeName_ == 'vmGenericDevices':
            obj_ = VmGenericDevice.factory()
            obj_.build(child_)
            self.vmGenericDevices.append(obj_)
        elif nodeName_ == 'vmGlobalSettings':
            obj_ = VmGlobalSettings.factory()
            obj_.build(child_)
            self.set_vmGlobalSettings(obj_)
        elif nodeName_ == 'capabilities':
            obj_ = VmCapabilities.factory()
            obj_.build(child_)
            self.set_capabilities(obj_)
        elif nodeName_ == 'templateId':
            templateId_ = child_.text
            templateId_ = self.gds_validate_string(templateId_, node, 'templateId')
            self.templateId = templateId_
        elif nodeName_ == 'vmHostId':
            vmHostId_ = child_.text
            vmHostId_ = self.gds_validate_string(vmHostId_, node, 'vmHostId')
            self.vmHostId = vmHostId_
        elif nodeName_ == 'cpuResourceAllocation':
            obj_ = ResourceAllocation.factory()
            obj_.build(child_)
            self.set_cpuResourceAllocation(obj_)
        elif nodeName_ == 'memoryResourceAllocation':
            obj_ = ResourceAllocation.factory()
            obj_.build(child_)
            self.set_memoryResourceAllocation(obj_)
        super(Vm, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = Vm.member_data_items_
        if Vm.superclass != None:
            member_items.update(Vm.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Vm._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Vm()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Vm.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Vm.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Vm


class ResourceCapacityPool(Resource):
    member_data_items_ = {
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, extensiontype_=None):
        super(ResourceCapacityPool, self).__init__(resourceManagerId, utilization, limits, vendorProperties, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ResourceCapacityPool.subclass:
            return ResourceCapacityPool.subclass(*args_, **kwargs_)
        else:
            return ResourceCapacityPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ResourceCapacityPool', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceCapacityPool')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceCapacityPool'):
        super(ResourceCapacityPool, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceCapacityPool')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceCapacityPool', fromsubclass_=False):
        super(ResourceCapacityPool, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(ResourceCapacityPool, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResourceCapacityPool'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResourceCapacityPool, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceCapacityPool, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(ResourceCapacityPool, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResourceCapacityPool, self).buildChildren(child_, node, nodeName_, True)
        pass
    @classmethod
    def get_all_members(cls):
        member_items = ResourceCapacityPool.member_data_items_
        if ResourceCapacityPool.superclass != None:
            member_items.update(ResourceCapacityPool.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return ResourceCapacityPool._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = ResourceCapacityPool()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return ResourceCapacityPool.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = ResourceCapacityPool.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class ResourceCapacityPool


class VmCapacityPool(ResourceCapacityPool):
    member_data_items_ = {
        'virtualizationType': MemberSpec_('virtualizationType', ['VirtualizationEnum', 'xs:string'], 0),
        'parentId': MemberSpec_('parentId', 'xs:string', 0),
        'parentName': MemberSpec_('parentName', 'xs:string', 0),
        'cpuResourceAllocation': MemberSpec_('cpuResourceAllocation', 'ResourceAllocation', 0),
        'memoryResourceAllocation': MemberSpec_('memoryResourceAllocation', 'ResourceAllocation', 0),
        'diskResourceAllocation': MemberSpec_('diskResourceAllocation', 'ResourceAllocation', 0),
        'virtualMachineIds': MemberSpec_('virtualMachineIds', 'xs:string', 1),
        }
    subclass = None
    superclass = ResourceCapacityPool
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, virtualizationType=None, parentId=None, parentName=None, cpuResourceAllocation=None, memoryResourceAllocation=None, diskResourceAllocation=None, virtualMachineIds=None):
        super(VmCapacityPool, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.virtualizationType = virtualizationType
        self.parentId = parentId
        self.parentName = parentName
        self.cpuResourceAllocation = cpuResourceAllocation
        self.memoryResourceAllocation = memoryResourceAllocation
        self.diskResourceAllocation = diskResourceAllocation
        if virtualMachineIds is None:
            self.virtualMachineIds = []
        else:
            self.virtualMachineIds = virtualMachineIds
    def factory(*args_, **kwargs_):
        if VmCapacityPool.subclass:
            return VmCapacityPool.subclass(*args_, **kwargs_)
        else:
            return VmCapacityPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtualizationType(self): return self.virtualizationType
    def set_virtualizationType(self, virtualizationType): self.virtualizationType = virtualizationType
    virtualizationTypeProp = property(get_virtualizationType, set_virtualizationType)
    def validate_VirtualizationEnum(self, value):
        # Validate type VirtualizationEnum, a restriction on xs:string.
        pass
    def get_parentId(self): return self.parentId
    def set_parentId(self, parentId): self.parentId = parentId
    parentIdProp = property(get_parentId, set_parentId)
    def get_parentName(self): return self.parentName
    def set_parentName(self, parentName): self.parentName = parentName
    parentNameProp = property(get_parentName, set_parentName)
    def get_cpuResourceAllocation(self): return self.cpuResourceAllocation
    def set_cpuResourceAllocation(self, cpuResourceAllocation): self.cpuResourceAllocation = cpuResourceAllocation
    cpuResourceAllocationProp = property(get_cpuResourceAllocation, set_cpuResourceAllocation)
    def get_memoryResourceAllocation(self): return self.memoryResourceAllocation
    def set_memoryResourceAllocation(self, memoryResourceAllocation): self.memoryResourceAllocation = memoryResourceAllocation
    memoryResourceAllocationProp = property(get_memoryResourceAllocation, set_memoryResourceAllocation)
    def get_diskResourceAllocation(self): return self.diskResourceAllocation
    def set_diskResourceAllocation(self, diskResourceAllocation): self.diskResourceAllocation = diskResourceAllocation
    diskResourceAllocationProp = property(get_diskResourceAllocation, set_diskResourceAllocation)
    def get_virtualMachineIds(self): return self.virtualMachineIds
    def set_virtualMachineIds(self, virtualMachineIds): self.virtualMachineIds = virtualMachineIds
    def add_virtualMachineIds(self, value): self.virtualMachineIds.append(value)
    def insert_virtualMachineIds(self, index, value): self.virtualMachineIds[index] = value
    virtualMachineIdsProp = property(get_virtualMachineIds, set_virtualMachineIds)
    def export(self, outfile, level, namespace_='', name_='VmCapacityPool', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmCapacityPool')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmCapacityPool'):
        super(VmCapacityPool, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmCapacityPool')
    def exportChildren(self, outfile, level, namespace_='', name_='VmCapacityPool', fromsubclass_=False):
        super(VmCapacityPool, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtualizationType>%s</%svirtualizationType>\n' % (namespace_, self.gds_format_string(quote_xml(self.virtualizationType).encode(ExternalEncoding), input_name='virtualizationType'), namespace_))
        if self.parentId is not None:
            showIndent(outfile, level)
            outfile.write('<%sparentId>%s</%sparentId>\n' % (namespace_, self.gds_format_string(quote_xml(self.parentId).encode(ExternalEncoding), input_name='parentId'), namespace_))
        if self.parentName is not None:
            showIndent(outfile, level)
            outfile.write('<%sparentName>%s</%sparentName>\n' % (namespace_, self.gds_format_string(quote_xml(self.parentName).encode(ExternalEncoding), input_name='parentName'), namespace_))
        if self.cpuResourceAllocation is not None:
            self.cpuResourceAllocation.export(outfile, level, namespace_, name_='cpuResourceAllocation')
        if self.memoryResourceAllocation is not None:
            self.memoryResourceAllocation.export(outfile, level, namespace_, name_='memoryResourceAllocation')
        if self.diskResourceAllocation is not None:
            self.diskResourceAllocation.export(outfile, level, namespace_, name_='diskResourceAllocation')
        for virtualMachineIds_ in self.virtualMachineIds:
            showIndent(outfile, level)
            outfile.write('<%svirtualMachineIds>%s</%svirtualMachineIds>\n' % (namespace_, self.gds_format_string(quote_xml(virtualMachineIds_).encode(ExternalEncoding), input_name='virtualMachineIds'), namespace_))
    def hasContent_(self):
        if (
            self.virtualizationType is not None or
            self.parentId is not None or
            self.parentName is not None or
            self.cpuResourceAllocation is not None or
            self.memoryResourceAllocation is not None or
            self.diskResourceAllocation is not None or
            self.virtualMachineIds or
            super(VmCapacityPool, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmCapacityPool'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmCapacityPool, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmCapacityPool, self).exportLiteralChildren(outfile, level, name_)
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('virtualizationType=%s,\n' % quote_python(self.virtualizationType).encode(ExternalEncoding))
        if self.parentId is not None:
            showIndent(outfile, level)
            outfile.write('parentId=%s,\n' % quote_python(self.parentId).encode(ExternalEncoding))
        if self.parentName is not None:
            showIndent(outfile, level)
            outfile.write('parentName=%s,\n' % quote_python(self.parentName).encode(ExternalEncoding))
        if self.cpuResourceAllocation is not None:
            showIndent(outfile, level)
            outfile.write('cpuResourceAllocation=model_.ResourceAllocation(\n')
            self.cpuResourceAllocation.exportLiteral(outfile, level, name_='cpuResourceAllocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.memoryResourceAllocation is not None:
            showIndent(outfile, level)
            outfile.write('memoryResourceAllocation=model_.ResourceAllocation(\n')
            self.memoryResourceAllocation.exportLiteral(outfile, level, name_='memoryResourceAllocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.diskResourceAllocation is not None:
            showIndent(outfile, level)
            outfile.write('diskResourceAllocation=model_.ResourceAllocation(\n')
            self.diskResourceAllocation.exportLiteral(outfile, level, name_='diskResourceAllocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('virtualMachineIds=[\n')
        level += 1
        for virtualMachineIds_ in self.virtualMachineIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(virtualMachineIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmCapacityPool, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'virtualizationType':
            virtualizationType_ = child_.text
            virtualizationType_ = self.gds_validate_string(virtualizationType_, node, 'virtualizationType')
            self.virtualizationType = virtualizationType_
            self.validate_VirtualizationEnum(self.virtualizationType)    # validate type VirtualizationEnum
        elif nodeName_ == 'parentId':
            parentId_ = child_.text
            parentId_ = self.gds_validate_string(parentId_, node, 'parentId')
            self.parentId = parentId_
        elif nodeName_ == 'parentName':
            parentName_ = child_.text
            parentName_ = self.gds_validate_string(parentName_, node, 'parentName')
            self.parentName = parentName_
        elif nodeName_ == 'cpuResourceAllocation':
            obj_ = ResourceAllocation.factory()
            obj_.build(child_)
            self.set_cpuResourceAllocation(obj_)
        elif nodeName_ == 'memoryResourceAllocation':
            obj_ = ResourceAllocation.factory()
            obj_.build(child_)
            self.set_memoryResourceAllocation(obj_)
        elif nodeName_ == 'diskResourceAllocation':
            obj_ = ResourceAllocation.factory()
            obj_.build(child_)
            self.set_diskResourceAllocation(obj_)
        elif nodeName_ == 'virtualMachineIds':
            virtualMachineIds_ = child_.text
            virtualMachineIds_ = self.gds_validate_string(virtualMachineIds_, node, 'virtualMachineIds')
            self.virtualMachineIds.append(virtualMachineIds_)
        super(VmCapacityPool, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmCapacityPool.member_data_items_
        if VmCapacityPool.superclass != None:
            member_items.update(VmCapacityPool.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmCapacityPool._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmCapacityPool()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmCapacityPool.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmCapacityPool.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmCapacityPool


class CloudCapacityPool(ResourceCapacityPool):
    member_data_items_ = {
        }
    subclass = None
    superclass = ResourceCapacityPool
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None):
        super(CloudCapacityPool, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        pass
    def factory(*args_, **kwargs_):
        if CloudCapacityPool.subclass:
            return CloudCapacityPool.subclass(*args_, **kwargs_)
        else:
            return CloudCapacityPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CloudCapacityPool', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CloudCapacityPool')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CloudCapacityPool'):
        super(CloudCapacityPool, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CloudCapacityPool')
    def exportChildren(self, outfile, level, namespace_='', name_='CloudCapacityPool', fromsubclass_=False):
        super(CloudCapacityPool, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(CloudCapacityPool, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CloudCapacityPool'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CloudCapacityPool, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CloudCapacityPool, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CloudCapacityPool, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CloudCapacityPool, self).buildChildren(child_, node, nodeName_, True)
        pass
    @classmethod
    def get_all_members(cls):
        member_items = CloudCapacityPool.member_data_items_
        if CloudCapacityPool.superclass != None:
            member_items.update(CloudCapacityPool.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return CloudCapacityPool._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = CloudCapacityPool()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return CloudCapacityPool.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = CloudCapacityPool.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class CloudCapacityPool


class DiskArray(Resource):
    member_data_items_ = {
        'sanVolumes': MemberSpec_('sanVolumes', 'SanVolume', 1),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, sanVolumes=None):
        super(DiskArray, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        if sanVolumes is None:
            self.sanVolumes = []
        else:
            self.sanVolumes = sanVolumes
    def factory(*args_, **kwargs_):
        if DiskArray.subclass:
            return DiskArray.subclass(*args_, **kwargs_)
        else:
            return DiskArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sanVolumes(self): return self.sanVolumes
    def set_sanVolumes(self, sanVolumes): self.sanVolumes = sanVolumes
    def add_sanVolumes(self, value): self.sanVolumes.append(value)
    def insert_sanVolumes(self, index, value): self.sanVolumes[index] = value
    sanVolumesProp = property(get_sanVolumes, set_sanVolumes)
    def export(self, outfile, level, namespace_='', name_='DiskArray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskArray')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskArray'):
        super(DiskArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskArray')
    def exportChildren(self, outfile, level, namespace_='', name_='DiskArray', fromsubclass_=False):
        super(DiskArray, self).exportChildren(outfile, level, namespace_, name_, True)
        for sanVolumes_ in self.sanVolumes:
            sanVolumes_.export(outfile, level, namespace_, name_='sanVolumes')
    def hasContent_(self):
        if (
            self.sanVolumes or
            super(DiskArray, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DiskArray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiskArray, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskArray, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('sanVolumes=[\n')
        level += 1
        for sanVolumes_ in self.sanVolumes:
            showIndent(outfile, level)
            outfile.write('model_.SanVolume(\n')
            sanVolumes_.exportLiteral(outfile, level, name_='SanVolume')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sanVolumes':
            obj_ = SanVolume.factory()
            obj_.build(child_)
            self.sanVolumes.append(obj_)
        super(DiskArray, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = DiskArray.member_data_items_
        if DiskArray.superclass != None:
            member_items.update(DiskArray.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return DiskArray._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = DiskArray()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return DiskArray.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = DiskArray.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class DiskArray


class WwnConnection(GeneratedsSuper):
    member_data_items_ = {
        'serverWwn': MemberSpec_('serverWwn', 'xs:string', 0),
        'targetWwns': MemberSpec_('targetWwns', 'xs:string', 1),
        'fabricId': MemberSpec_('fabricId', 'xs:string', 0),
        'presentation': MemberSpec_('presentation', 'xs:string', 0),
        }
    subclass = None
    superclass = None
    def __init__(self, serverWwn=None, targetWwns=None, fabricId=None, presentation=None):
        self.serverWwn = serverWwn
        if targetWwns is None:
            self.targetWwns = []
        else:
            self.targetWwns = targetWwns
        self.fabricId = fabricId
        self.presentation = presentation
    def factory(*args_, **kwargs_):
        if WwnConnection.subclass:
            return WwnConnection.subclass(*args_, **kwargs_)
        else:
            return WwnConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serverWwn(self): return self.serverWwn
    def set_serverWwn(self, serverWwn): self.serverWwn = serverWwn
    serverWwnProp = property(get_serverWwn, set_serverWwn)
    def get_targetWwns(self): return self.targetWwns
    def set_targetWwns(self, targetWwns): self.targetWwns = targetWwns
    def add_targetWwns(self, value): self.targetWwns.append(value)
    def insert_targetWwns(self, index, value): self.targetWwns[index] = value
    targetWwnsProp = property(get_targetWwns, set_targetWwns)
    def get_fabricId(self): return self.fabricId
    def set_fabricId(self, fabricId): self.fabricId = fabricId
    fabricIdProp = property(get_fabricId, set_fabricId)
    def get_presentation(self): return self.presentation
    def set_presentation(self, presentation): self.presentation = presentation
    presentationProp = property(get_presentation, set_presentation)
    def export(self, outfile, level, namespace_='', name_='WwnConnection', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WwnConnection')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WwnConnection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WwnConnection', fromsubclass_=False):
        if self.serverWwn is not None:
            showIndent(outfile, level)
            outfile.write('<%sserverWwn>%s</%sserverWwn>\n' % (namespace_, self.gds_format_string(quote_xml(self.serverWwn).encode(ExternalEncoding), input_name='serverWwn'), namespace_))
        for targetWwns_ in self.targetWwns:
            showIndent(outfile, level)
            outfile.write('<%stargetWwns>%s</%stargetWwns>\n' % (namespace_, self.gds_format_string(quote_xml(targetWwns_).encode(ExternalEncoding), input_name='targetWwns'), namespace_))
        if self.fabricId is not None:
            showIndent(outfile, level)
            outfile.write('<%sfabricId>%s</%sfabricId>\n' % (namespace_, self.gds_format_string(quote_xml(self.fabricId).encode(ExternalEncoding), input_name='fabricId'), namespace_))
        if self.presentation is not None:
            showIndent(outfile, level)
            outfile.write('<%spresentation>%s</%spresentation>\n' % (namespace_, self.gds_format_string(quote_xml(self.presentation).encode(ExternalEncoding), input_name='presentation'), namespace_))
    def hasContent_(self):
        if (
            self.serverWwn is not None or
            self.targetWwns or
            self.fabricId is not None or
            self.presentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WwnConnection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.serverWwn is not None:
            showIndent(outfile, level)
            outfile.write('serverWwn=%s,\n' % quote_python(self.serverWwn).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('targetWwns=[\n')
        level += 1
        for targetWwns_ in self.targetWwns:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(targetWwns_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.fabricId is not None:
            showIndent(outfile, level)
            outfile.write('fabricId=%s,\n' % quote_python(self.fabricId).encode(ExternalEncoding))
        if self.presentation is not None:
            showIndent(outfile, level)
            outfile.write('presentation=%s,\n' % quote_python(self.presentation).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'serverWwn':
            serverWwn_ = child_.text
            serverWwn_ = self.gds_validate_string(serverWwn_, node, 'serverWwn')
            self.serverWwn = serverWwn_
        elif nodeName_ == 'targetWwns':
            targetWwns_ = child_.text
            targetWwns_ = self.gds_validate_string(targetWwns_, node, 'targetWwns')
            self.targetWwns.append(targetWwns_)
        elif nodeName_ == 'fabricId':
            fabricId_ = child_.text
            fabricId_ = self.gds_validate_string(fabricId_, node, 'fabricId')
            self.fabricId = fabricId_
        elif nodeName_ == 'presentation':
            presentation_ = child_.text
            presentation_ = self.gds_validate_string(presentation_, node, 'presentation')
            self.presentation = presentation_
    @classmethod
    def get_all_members(cls):
        member_items = WwnConnection.member_data_items_
        if WwnConnection.superclass != None:
            member_items.update(WwnConnection.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return WwnConnection._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = WwnConnection()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return WwnConnection.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = WwnConnection.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class WwnConnection


class SanVolume(Resource):
    member_data_items_ = {
        'size': MemberSpec_('size', 'xs:long', 0),
        'extensibleRaidLevel': MemberSpec_('extensibleRaidLevel', 'ExtensibleRaidLevel', 0),
        'osType': MemberSpec_('osType', ['OsTypeEnum', 'xs:string'], 0),
        'diskArrayId': MemberSpec_('diskArrayId', 'xs:string', 0),
        'lunId': MemberSpec_('lunId', 'xs:string', 0),
        'tags': MemberSpec_('tags', 'xs:string', 1),
        'groupId': MemberSpec_('groupId', 'xs:string', 0),
        'setId': MemberSpec_('setId', 'xs:string', 0),
        'isMultiMemberSet': MemberSpec_('isMultiMemberSet', 'xs:boolean', 0),
        'setName': MemberSpec_('setName', 'xs:string', 0),
        'availableConnectionCount': MemberSpec_('availableConnectionCount', 'xs:int', 0),
        'isBootable': MemberSpec_('isBootable', 'xs:boolean', 0),
        'inUse': MemberSpec_('inUse', 'xs:boolean', 0),
        'isSinglePath': MemberSpec_('isSinglePath', 'xs:boolean', 0),
        'volumeState': MemberSpec_('volumeState', ['VolumeStateEnum', 'xs:string'], 0),
        'provisioningType': MemberSpec_('provisioningType', ['StorageProvisioningTypeEnum', 'xs:string'], 0),
        'wwnConnections': MemberSpec_('wwnConnections', 'WwnConnection', 1),
        'isAutoGenerated': MemberSpec_('isAutoGenerated', 'xs:boolean', 0),
        'isManualZoningRequired': MemberSpec_('isManualZoningRequired', 'xs:boolean', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, size=None, extensibleRaidLevel=None, osType=None, diskArrayId=None, lunId=None, tags=None, groupId=None, setId=None, isMultiMemberSet=None, setName=None, availableConnectionCount=None, isBootable=None, inUse=None, isSinglePath=None, volumeState=None, provisioningType=None, wwnConnections=None, isAutoGenerated=None, isManualZoningRequired=None):
        super(SanVolume, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.size = size
        self.extensibleRaidLevel = extensibleRaidLevel
        self.osType = osType
        self.diskArrayId = diskArrayId
        self.lunId = lunId
        if tags is None:
            self.tags = []
        else:
            self.tags = tags
        self.groupId = groupId
        self.setId = setId
        self.isMultiMemberSet = isMultiMemberSet
        self.setName = setName
        self.availableConnectionCount = availableConnectionCount
        self.isBootable = isBootable
        self.inUse = inUse
        self.isSinglePath = isSinglePath
        self.volumeState = volumeState
        self.provisioningType = provisioningType
        if wwnConnections is None:
            self.wwnConnections = []
        else:
            self.wwnConnections = wwnConnections
        self.isAutoGenerated = isAutoGenerated
        self.isManualZoningRequired = isManualZoningRequired
    def factory(*args_, **kwargs_):
        if SanVolume.subclass:
            return SanVolume.subclass(*args_, **kwargs_)
        else:
            return SanVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    sizeProp = property(get_size, set_size)
    def get_extensibleRaidLevel(self): return self.extensibleRaidLevel
    def set_extensibleRaidLevel(self, extensibleRaidLevel): self.extensibleRaidLevel = extensibleRaidLevel
    extensibleRaidLevelProp = property(get_extensibleRaidLevel, set_extensibleRaidLevel)
    def get_osType(self): return self.osType
    def set_osType(self, osType): self.osType = osType
    osTypeProp = property(get_osType, set_osType)
    def validate_OsTypeEnum(self, value):
        # Validate type OsTypeEnum, a restriction on xs:string.
        pass
    def get_diskArrayId(self): return self.diskArrayId
    def set_diskArrayId(self, diskArrayId): self.diskArrayId = diskArrayId
    diskArrayIdProp = property(get_diskArrayId, set_diskArrayId)
    def get_lunId(self): return self.lunId
    def set_lunId(self, lunId): self.lunId = lunId
    lunIdProp = property(get_lunId, set_lunId)
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags(self, index, value): self.tags[index] = value
    tagsProp = property(get_tags, set_tags)
    def get_groupId(self): return self.groupId
    def set_groupId(self, groupId): self.groupId = groupId
    groupIdProp = property(get_groupId, set_groupId)
    def get_setId(self): return self.setId
    def set_setId(self, setId): self.setId = setId
    setIdProp = property(get_setId, set_setId)
    def get_isMultiMemberSet(self): return self.isMultiMemberSet
    def set_isMultiMemberSet(self, isMultiMemberSet): self.isMultiMemberSet = isMultiMemberSet
    isMultiMemberSetProp = property(get_isMultiMemberSet, set_isMultiMemberSet)
    def get_setName(self): return self.setName
    def set_setName(self, setName): self.setName = setName
    setNameProp = property(get_setName, set_setName)
    def get_availableConnectionCount(self): return self.availableConnectionCount
    def set_availableConnectionCount(self, availableConnectionCount): self.availableConnectionCount = availableConnectionCount
    availableConnectionCountProp = property(get_availableConnectionCount, set_availableConnectionCount)
    def get_isBootable(self): return self.isBootable
    def set_isBootable(self, isBootable): self.isBootable = isBootable
    isBootableProp = property(get_isBootable, set_isBootable)
    def get_inUse(self): return self.inUse
    def set_inUse(self, inUse): self.inUse = inUse
    inUseProp = property(get_inUse, set_inUse)
    def get_isSinglePath(self): return self.isSinglePath
    def set_isSinglePath(self, isSinglePath): self.isSinglePath = isSinglePath
    isSinglePathProp = property(get_isSinglePath, set_isSinglePath)
    def get_volumeState(self): return self.volumeState
    def set_volumeState(self, volumeState): self.volumeState = volumeState
    volumeStateProp = property(get_volumeState, set_volumeState)
    def validate_VolumeStateEnum(self, value):
        # Validate type VolumeStateEnum, a restriction on xs:string.
        pass
    def get_provisioningType(self): return self.provisioningType
    def set_provisioningType(self, provisioningType): self.provisioningType = provisioningType
    provisioningTypeProp = property(get_provisioningType, set_provisioningType)
    def validate_StorageProvisioningTypeEnum(self, value):
        # Validate type StorageProvisioningTypeEnum, a restriction on xs:string.
        pass
    def get_wwnConnections(self): return self.wwnConnections
    def set_wwnConnections(self, wwnConnections): self.wwnConnections = wwnConnections
    def add_wwnConnections(self, value): self.wwnConnections.append(value)
    def insert_wwnConnections(self, index, value): self.wwnConnections[index] = value
    wwnConnectionsProp = property(get_wwnConnections, set_wwnConnections)
    def get_isAutoGenerated(self): return self.isAutoGenerated
    def set_isAutoGenerated(self, isAutoGenerated): self.isAutoGenerated = isAutoGenerated
    isAutoGeneratedProp = property(get_isAutoGenerated, set_isAutoGenerated)
    def get_isManualZoningRequired(self): return self.isManualZoningRequired
    def set_isManualZoningRequired(self, isManualZoningRequired): self.isManualZoningRequired = isManualZoningRequired
    isManualZoningRequiredProp = property(get_isManualZoningRequired, set_isManualZoningRequired)
    def export(self, outfile, level, namespace_='', name_='SanVolume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanVolume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SanVolume'):
        super(SanVolume, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SanVolume')
    def exportChildren(self, outfile, level, namespace_='', name_='SanVolume', fromsubclass_=False):
        super(SanVolume, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('<%ssize>%s</%ssize>\n' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_))
        if self.extensibleRaidLevel is not None:
            self.extensibleRaidLevel.export(outfile, level, namespace_, name_='extensibleRaidLevel')
        if self.osType is not None:
            showIndent(outfile, level)
            outfile.write('<%sosType>%s</%sosType>\n' % (namespace_, self.gds_format_string(quote_xml(self.osType).encode(ExternalEncoding), input_name='osType'), namespace_))
        if self.diskArrayId is not None:
            showIndent(outfile, level)
            outfile.write('<%sdiskArrayId>%s</%sdiskArrayId>\n' % (namespace_, self.gds_format_string(quote_xml(self.diskArrayId).encode(ExternalEncoding), input_name='diskArrayId'), namespace_))
        if self.lunId is not None:
            showIndent(outfile, level)
            outfile.write('<%slunId>%s</%slunId>\n' % (namespace_, self.gds_format_string(quote_xml(self.lunId).encode(ExternalEncoding), input_name='lunId'), namespace_))
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('<%stags>%s</%stags>\n' % (namespace_, self.gds_format_string(quote_xml(tags_).encode(ExternalEncoding), input_name='tags'), namespace_))
        if self.groupId is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroupId>%s</%sgroupId>\n' % (namespace_, self.gds_format_string(quote_xml(self.groupId).encode(ExternalEncoding), input_name='groupId'), namespace_))
        if self.setId is not None:
            showIndent(outfile, level)
            outfile.write('<%ssetId>%s</%ssetId>\n' % (namespace_, self.gds_format_string(quote_xml(self.setId).encode(ExternalEncoding), input_name='setId'), namespace_))
        if self.isMultiMemberSet is not None:
            showIndent(outfile, level)
            outfile.write('<%sisMultiMemberSet>%s</%sisMultiMemberSet>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isMultiMemberSet)), input_name='isMultiMemberSet'), namespace_))
        if self.setName is not None:
            showIndent(outfile, level)
            outfile.write('<%ssetName>%s</%ssetName>\n' % (namespace_, self.gds_format_string(quote_xml(self.setName).encode(ExternalEncoding), input_name='setName'), namespace_))
        if self.availableConnectionCount is not None:
            showIndent(outfile, level)
            outfile.write('<%savailableConnectionCount>%s</%savailableConnectionCount>\n' % (namespace_, self.gds_format_integer(self.availableConnectionCount, input_name='availableConnectionCount'), namespace_))
        if self.isBootable is not None:
            showIndent(outfile, level)
            outfile.write('<%sisBootable>%s</%sisBootable>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isBootable)), input_name='isBootable'), namespace_))
        if self.inUse is not None:
            showIndent(outfile, level)
            outfile.write('<%sinUse>%s</%sinUse>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.inUse)), input_name='inUse'), namespace_))
        if self.isSinglePath is not None:
            showIndent(outfile, level)
            outfile.write('<%sisSinglePath>%s</%sisSinglePath>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isSinglePath)), input_name='isSinglePath'), namespace_))
        if self.volumeState is not None:
            showIndent(outfile, level)
            outfile.write('<%svolumeState>%s</%svolumeState>\n' % (namespace_, self.gds_format_string(quote_xml(self.volumeState).encode(ExternalEncoding), input_name='volumeState'), namespace_))
        if self.provisioningType is not None:
            showIndent(outfile, level)
            outfile.write('<%sprovisioningType>%s</%sprovisioningType>\n' % (namespace_, self.gds_format_string(quote_xml(self.provisioningType).encode(ExternalEncoding), input_name='provisioningType'), namespace_))
        for wwnConnections_ in self.wwnConnections:
            wwnConnections_.export(outfile, level, namespace_, name_='wwnConnections')
        if self.isAutoGenerated is not None:
            showIndent(outfile, level)
            outfile.write('<%sisAutoGenerated>%s</%sisAutoGenerated>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isAutoGenerated)), input_name='isAutoGenerated'), namespace_))
        if self.isManualZoningRequired is not None:
            showIndent(outfile, level)
            outfile.write('<%sisManualZoningRequired>%s</%sisManualZoningRequired>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isManualZoningRequired)), input_name='isManualZoningRequired'), namespace_))
    def hasContent_(self):
        if (
            self.size is not None or
            self.extensibleRaidLevel is not None or
            self.osType is not None or
            self.diskArrayId is not None or
            self.lunId is not None or
            self.tags or
            self.groupId is not None or
            self.setId is not None or
            self.isMultiMemberSet is not None or
            self.setName is not None or
            self.availableConnectionCount is not None or
            self.isBootable is not None or
            self.inUse is not None or
            self.isSinglePath is not None or
            self.volumeState is not None or
            self.provisioningType is not None or
            self.wwnConnections or
            self.isAutoGenerated is not None or
            self.isManualZoningRequired is not None or
            super(SanVolume, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SanVolume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SanVolume, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SanVolume, self).exportLiteralChildren(outfile, level, name_)
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.extensibleRaidLevel is not None:
            showIndent(outfile, level)
            outfile.write('extensibleRaidLevel=model_.ExtensibleRaidLevel(\n')
            self.extensibleRaidLevel.exportLiteral(outfile, level, name_='extensibleRaidLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.osType is not None:
            showIndent(outfile, level)
            outfile.write('osType=%s,\n' % quote_python(self.osType).encode(ExternalEncoding))
        if self.diskArrayId is not None:
            showIndent(outfile, level)
            outfile.write('diskArrayId=%s,\n' % quote_python(self.diskArrayId).encode(ExternalEncoding))
        if self.lunId is not None:
            showIndent(outfile, level)
            outfile.write('lunId=%s,\n' % quote_python(self.lunId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(tags_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.groupId is not None:
            showIndent(outfile, level)
            outfile.write('groupId=%s,\n' % quote_python(self.groupId).encode(ExternalEncoding))
        if self.setId is not None:
            showIndent(outfile, level)
            outfile.write('setId=%s,\n' % quote_python(self.setId).encode(ExternalEncoding))
        if self.isMultiMemberSet is not None:
            showIndent(outfile, level)
            outfile.write('isMultiMemberSet=%s,\n' % self.isMultiMemberSet)
        if self.setName is not None:
            showIndent(outfile, level)
            outfile.write('setName=%s,\n' % quote_python(self.setName).encode(ExternalEncoding))
        if self.availableConnectionCount is not None:
            showIndent(outfile, level)
            outfile.write('availableConnectionCount=%d,\n' % self.availableConnectionCount)
        if self.isBootable is not None:
            showIndent(outfile, level)
            outfile.write('isBootable=%s,\n' % self.isBootable)
        if self.inUse is not None:
            showIndent(outfile, level)
            outfile.write('inUse=%s,\n' % self.inUse)
        if self.isSinglePath is not None:
            showIndent(outfile, level)
            outfile.write('isSinglePath=%s,\n' % self.isSinglePath)
        if self.volumeState is not None:
            showIndent(outfile, level)
            outfile.write('volumeState=%s,\n' % quote_python(self.volumeState).encode(ExternalEncoding))
        if self.provisioningType is not None:
            showIndent(outfile, level)
            outfile.write('provisioningType=%s,\n' % quote_python(self.provisioningType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('wwnConnections=[\n')
        level += 1
        for wwnConnections_ in self.wwnConnections:
            showIndent(outfile, level)
            outfile.write('model_.WwnConnection(\n')
            wwnConnections_.exportLiteral(outfile, level, name_='WwnConnection')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.isAutoGenerated is not None:
            showIndent(outfile, level)
            outfile.write('isAutoGenerated=%s,\n' % self.isAutoGenerated)
        if self.isManualZoningRequired is not None:
            showIndent(outfile, level)
            outfile.write('isManualZoningRequired=%s,\n' % self.isManualZoningRequired)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SanVolume, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'extensibleRaidLevel':
            obj_ = ExtensibleRaidLevel.factory()
            obj_.build(child_)
            self.set_extensibleRaidLevel(obj_)
        elif nodeName_ == 'osType':
            osType_ = child_.text
            osType_ = self.gds_validate_string(osType_, node, 'osType')
            self.osType = osType_
            self.validate_OsTypeEnum(self.osType)    # validate type OsTypeEnum
        elif nodeName_ == 'diskArrayId':
            diskArrayId_ = child_.text
            diskArrayId_ = self.gds_validate_string(diskArrayId_, node, 'diskArrayId')
            self.diskArrayId = diskArrayId_
        elif nodeName_ == 'lunId':
            lunId_ = child_.text
            lunId_ = self.gds_validate_string(lunId_, node, 'lunId')
            self.lunId = lunId_
        elif nodeName_ == 'tags':
            tags_ = child_.text
            tags_ = self.gds_validate_string(tags_, node, 'tags')
            self.tags.append(tags_)
        elif nodeName_ == 'groupId':
            groupId_ = child_.text
            groupId_ = self.gds_validate_string(groupId_, node, 'groupId')
            self.groupId = groupId_
        elif nodeName_ == 'setId':
            setId_ = child_.text
            setId_ = self.gds_validate_string(setId_, node, 'setId')
            self.setId = setId_
        elif nodeName_ == 'isMultiMemberSet':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isMultiMemberSet')
            self.isMultiMemberSet = ival_
        elif nodeName_ == 'setName':
            setName_ = child_.text
            setName_ = self.gds_validate_string(setName_, node, 'setName')
            self.setName = setName_
        elif nodeName_ == 'availableConnectionCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'availableConnectionCount')
            self.availableConnectionCount = ival_
        elif nodeName_ == 'isBootable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isBootable')
            self.isBootable = ival_
        elif nodeName_ == 'inUse':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'inUse')
            self.inUse = ival_
        elif nodeName_ == 'isSinglePath':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isSinglePath')
            self.isSinglePath = ival_
        elif nodeName_ == 'volumeState':
            volumeState_ = child_.text
            volumeState_ = self.gds_validate_string(volumeState_, node, 'volumeState')
            self.volumeState = volumeState_
            self.validate_VolumeStateEnum(self.volumeState)    # validate type VolumeStateEnum
        elif nodeName_ == 'provisioningType':
            provisioningType_ = child_.text
            provisioningType_ = self.gds_validate_string(provisioningType_, node, 'provisioningType')
            self.provisioningType = provisioningType_
            self.validate_StorageProvisioningTypeEnum(self.provisioningType)    # validate type StorageProvisioningTypeEnum
        elif nodeName_ == 'wwnConnections':
            obj_ = WwnConnection.factory()
            obj_.build(child_)
            self.wwnConnections.append(obj_)
        elif nodeName_ == 'isAutoGenerated':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAutoGenerated')
            self.isAutoGenerated = ival_
        elif nodeName_ == 'isManualZoningRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isManualZoningRequired')
            self.isManualZoningRequired = ival_
        super(SanVolume, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = SanVolume.member_data_items_
        if SanVolume.superclass != None:
            member_items.update(SanVolume.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return SanVolume._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = SanVolume()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return SanVolume.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = SanVolume.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class SanVolume


class PhysicalServerProfile(Resource):
    member_data_items_ = {
        'serverId': MemberSpec_('serverId', 'xs:string', 0),
        'subnetIds': MemberSpec_('subnetIds', 'xs:string', 1),
        'sanVolumeIds': MemberSpec_('sanVolumeIds', 'xs:string', 1),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, serverId=None, subnetIds=None, sanVolumeIds=None):
        super(PhysicalServerProfile, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.serverId = serverId
        if subnetIds is None:
            self.subnetIds = []
        else:
            self.subnetIds = subnetIds
        if sanVolumeIds is None:
            self.sanVolumeIds = []
        else:
            self.sanVolumeIds = sanVolumeIds
    def factory(*args_, **kwargs_):
        if PhysicalServerProfile.subclass:
            return PhysicalServerProfile.subclass(*args_, **kwargs_)
        else:
            return PhysicalServerProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serverId(self): return self.serverId
    def set_serverId(self, serverId): self.serverId = serverId
    serverIdProp = property(get_serverId, set_serverId)
    def get_subnetIds(self): return self.subnetIds
    def set_subnetIds(self, subnetIds): self.subnetIds = subnetIds
    def add_subnetIds(self, value): self.subnetIds.append(value)
    def insert_subnetIds(self, index, value): self.subnetIds[index] = value
    subnetIdsProp = property(get_subnetIds, set_subnetIds)
    def get_sanVolumeIds(self): return self.sanVolumeIds
    def set_sanVolumeIds(self, sanVolumeIds): self.sanVolumeIds = sanVolumeIds
    def add_sanVolumeIds(self, value): self.sanVolumeIds.append(value)
    def insert_sanVolumeIds(self, index, value): self.sanVolumeIds[index] = value
    sanVolumeIdsProp = property(get_sanVolumeIds, set_sanVolumeIds)
    def export(self, outfile, level, namespace_='', name_='PhysicalServerProfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalServerProfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhysicalServerProfile'):
        super(PhysicalServerProfile, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalServerProfile')
    def exportChildren(self, outfile, level, namespace_='', name_='PhysicalServerProfile', fromsubclass_=False):
        super(PhysicalServerProfile, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.serverId is not None:
            showIndent(outfile, level)
            outfile.write('<%sserverId>%s</%sserverId>\n' % (namespace_, self.gds_format_string(quote_xml(self.serverId).encode(ExternalEncoding), input_name='serverId'), namespace_))
        for subnetIds_ in self.subnetIds:
            showIndent(outfile, level)
            outfile.write('<%ssubnetIds>%s</%ssubnetIds>\n' % (namespace_, self.gds_format_string(quote_xml(subnetIds_).encode(ExternalEncoding), input_name='subnetIds'), namespace_))
        for sanVolumeIds_ in self.sanVolumeIds:
            showIndent(outfile, level)
            outfile.write('<%ssanVolumeIds>%s</%ssanVolumeIds>\n' % (namespace_, self.gds_format_string(quote_xml(sanVolumeIds_).encode(ExternalEncoding), input_name='sanVolumeIds'), namespace_))
    def hasContent_(self):
        if (
            self.serverId is not None or
            self.subnetIds or
            self.sanVolumeIds or
            super(PhysicalServerProfile, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PhysicalServerProfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PhysicalServerProfile, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PhysicalServerProfile, self).exportLiteralChildren(outfile, level, name_)
        if self.serverId is not None:
            showIndent(outfile, level)
            outfile.write('serverId=%s,\n' % quote_python(self.serverId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('subnetIds=[\n')
        level += 1
        for subnetIds_ in self.subnetIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(subnetIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sanVolumeIds=[\n')
        level += 1
        for sanVolumeIds_ in self.sanVolumeIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(sanVolumeIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PhysicalServerProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'serverId':
            serverId_ = child_.text
            serverId_ = self.gds_validate_string(serverId_, node, 'serverId')
            self.serverId = serverId_
        elif nodeName_ == 'subnetIds':
            subnetIds_ = child_.text
            subnetIds_ = self.gds_validate_string(subnetIds_, node, 'subnetIds')
            self.subnetIds.append(subnetIds_)
        elif nodeName_ == 'sanVolumeIds':
            sanVolumeIds_ = child_.text
            sanVolumeIds_ = self.gds_validate_string(sanVolumeIds_, node, 'sanVolumeIds')
            self.sanVolumeIds.append(sanVolumeIds_)
        super(PhysicalServerProfile, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = PhysicalServerProfile.member_data_items_
        if PhysicalServerProfile.superclass != None:
            member_items.update(PhysicalServerProfile.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return PhysicalServerProfile._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = PhysicalServerProfile()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return PhysicalServerProfile.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = PhysicalServerProfile.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class PhysicalServerProfile


class VmProfile(Resource):
    member_data_items_ = {
        'vmNetAdapters': MemberSpec_('vmNetAdapters', 'VmNetAdapter', 1),
        'vmScsiControllers': MemberSpec_('vmScsiControllers', 'VmScsiController', 1),
        'vmDisks': MemberSpec_('vmDisks', 'VmDisk', 1),
        'vmGenericDevices': MemberSpec_('vmGenericDevices', 'VmGenericDevice', 1),
        'vmGlobalSettings': MemberSpec_('vmGlobalSettings', 'VmGlobalSettings', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, vmNetAdapters=None, vmScsiControllers=None, vmDisks=None, vmGenericDevices=None, vmGlobalSettings=None):
        super(VmProfile, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        if vmNetAdapters is None:
            self.vmNetAdapters = []
        else:
            self.vmNetAdapters = vmNetAdapters
        if vmScsiControllers is None:
            self.vmScsiControllers = []
        else:
            self.vmScsiControllers = vmScsiControllers
        if vmDisks is None:
            self.vmDisks = []
        else:
            self.vmDisks = vmDisks
        if vmGenericDevices is None:
            self.vmGenericDevices = []
        else:
            self.vmGenericDevices = vmGenericDevices
        self.vmGlobalSettings = vmGlobalSettings
    def factory(*args_, **kwargs_):
        if VmProfile.subclass:
            return VmProfile.subclass(*args_, **kwargs_)
        else:
            return VmProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vmNetAdapters(self): return self.vmNetAdapters
    def set_vmNetAdapters(self, vmNetAdapters): self.vmNetAdapters = vmNetAdapters
    def add_vmNetAdapters(self, value): self.vmNetAdapters.append(value)
    def insert_vmNetAdapters(self, index, value): self.vmNetAdapters[index] = value
    vmNetAdaptersProp = property(get_vmNetAdapters, set_vmNetAdapters)
    def get_vmScsiControllers(self): return self.vmScsiControllers
    def set_vmScsiControllers(self, vmScsiControllers): self.vmScsiControllers = vmScsiControllers
    def add_vmScsiControllers(self, value): self.vmScsiControllers.append(value)
    def insert_vmScsiControllers(self, index, value): self.vmScsiControllers[index] = value
    vmScsiControllersProp = property(get_vmScsiControllers, set_vmScsiControllers)
    def get_vmDisks(self): return self.vmDisks
    def set_vmDisks(self, vmDisks): self.vmDisks = vmDisks
    def add_vmDisks(self, value): self.vmDisks.append(value)
    def insert_vmDisks(self, index, value): self.vmDisks[index] = value
    vmDisksProp = property(get_vmDisks, set_vmDisks)
    def get_vmGenericDevices(self): return self.vmGenericDevices
    def set_vmGenericDevices(self, vmGenericDevices): self.vmGenericDevices = vmGenericDevices
    def add_vmGenericDevices(self, value): self.vmGenericDevices.append(value)
    def insert_vmGenericDevices(self, index, value): self.vmGenericDevices[index] = value
    vmGenericDevicesProp = property(get_vmGenericDevices, set_vmGenericDevices)
    def get_vmGlobalSettings(self): return self.vmGlobalSettings
    def set_vmGlobalSettings(self, vmGlobalSettings): self.vmGlobalSettings = vmGlobalSettings
    vmGlobalSettingsProp = property(get_vmGlobalSettings, set_vmGlobalSettings)
    def export(self, outfile, level, namespace_='', name_='VmProfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmProfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmProfile'):
        super(VmProfile, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmProfile')
    def exportChildren(self, outfile, level, namespace_='', name_='VmProfile', fromsubclass_=False):
        super(VmProfile, self).exportChildren(outfile, level, namespace_, name_, True)
        for vmNetAdapters_ in self.vmNetAdapters:
            vmNetAdapters_.export(outfile, level, namespace_, name_='vmNetAdapters')
        for vmScsiControllers_ in self.vmScsiControllers:
            vmScsiControllers_.export(outfile, level, namespace_, name_='vmScsiControllers')
        for vmDisks_ in self.vmDisks:
            vmDisks_.export(outfile, level, namespace_, name_='vmDisks')
        for vmGenericDevices_ in self.vmGenericDevices:
            vmGenericDevices_.export(outfile, level, namespace_, name_='vmGenericDevices')
        if self.vmGlobalSettings is not None:
            self.vmGlobalSettings.export(outfile, level, namespace_, name_='vmGlobalSettings')
    def hasContent_(self):
        if (
            self.vmNetAdapters or
            self.vmScsiControllers or
            self.vmDisks or
            self.vmGenericDevices or
            self.vmGlobalSettings is not None or
            super(VmProfile, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmProfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmProfile, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmProfile, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('vmNetAdapters=[\n')
        level += 1
        for vmNetAdapters_ in self.vmNetAdapters:
            showIndent(outfile, level)
            outfile.write('model_.VmNetAdapter(\n')
            vmNetAdapters_.exportLiteral(outfile, level, name_='VmNetAdapter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmScsiControllers=[\n')
        level += 1
        for vmScsiControllers_ in self.vmScsiControllers:
            showIndent(outfile, level)
            outfile.write('model_.VmScsiController(\n')
            vmScsiControllers_.exportLiteral(outfile, level, name_='VmScsiController')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmDisks=[\n')
        level += 1
        for vmDisks_ in self.vmDisks:
            showIndent(outfile, level)
            outfile.write('model_.VmDisk(\n')
            vmDisks_.exportLiteral(outfile, level, name_='VmDisk')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmGenericDevices=[\n')
        level += 1
        for vmGenericDevices_ in self.vmGenericDevices:
            showIndent(outfile, level)
            outfile.write('model_.VmGenericDevice(\n')
            vmGenericDevices_.exportLiteral(outfile, level, name_='VmGenericDevice')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.vmGlobalSettings is not None:
            showIndent(outfile, level)
            outfile.write('vmGlobalSettings=model_.VmGlobalSettings(\n')
            self.vmGlobalSettings.exportLiteral(outfile, level, name_='vmGlobalSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vmNetAdapters':
            obj_ = VmNetAdapter.factory()
            obj_.build(child_)
            self.vmNetAdapters.append(obj_)
        elif nodeName_ == 'vmScsiControllers':
            obj_ = VmScsiController.factory()
            obj_.build(child_)
            self.vmScsiControllers.append(obj_)
        elif nodeName_ == 'vmDisks':
            obj_ = VmDisk.factory()
            obj_.build(child_)
            self.vmDisks.append(obj_)
        elif nodeName_ == 'vmGenericDevices':
            obj_ = VmGenericDevice.factory()
            obj_.build(child_)
            self.vmGenericDevices.append(obj_)
        elif nodeName_ == 'vmGlobalSettings':
            obj_ = VmGlobalSettings.factory()
            obj_.build(child_)
            self.set_vmGlobalSettings(obj_)
        super(VmProfile, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmProfile.member_data_items_
        if VmProfile.superclass != None:
            member_items.update(VmProfile.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmProfile._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmProfile()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmProfile.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmProfile.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmProfile


class StorageTag(Resource):
    member_data_items_ = {
        'tagText': MemberSpec_('tagText', 'xs:string', 0),
        'spmId': MemberSpec_('spmId', 'xs:string', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, tagText=None, spmId=None):
        super(StorageTag, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.tagText = tagText
        self.spmId = spmId
    def factory(*args_, **kwargs_):
        if StorageTag.subclass:
            return StorageTag.subclass(*args_, **kwargs_)
        else:
            return StorageTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tagText(self): return self.tagText
    def set_tagText(self, tagText): self.tagText = tagText
    tagTextProp = property(get_tagText, set_tagText)
    def get_spmId(self): return self.spmId
    def set_spmId(self, spmId): self.spmId = spmId
    spmIdProp = property(get_spmId, set_spmId)
    def export(self, outfile, level, namespace_='', name_='StorageTag', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StorageTag')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StorageTag'):
        super(StorageTag, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StorageTag')
    def exportChildren(self, outfile, level, namespace_='', name_='StorageTag', fromsubclass_=False):
        super(StorageTag, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.tagText is not None:
            showIndent(outfile, level)
            outfile.write('<%stagText>%s</%stagText>\n' % (namespace_, self.gds_format_string(quote_xml(self.tagText).encode(ExternalEncoding), input_name='tagText'), namespace_))
        if self.spmId is not None:
            showIndent(outfile, level)
            outfile.write('<%sspmId>%s</%sspmId>\n' % (namespace_, self.gds_format_string(quote_xml(self.spmId).encode(ExternalEncoding), input_name='spmId'), namespace_))
    def hasContent_(self):
        if (
            self.tagText is not None or
            self.spmId is not None or
            super(StorageTag, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StorageTag'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StorageTag, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StorageTag, self).exportLiteralChildren(outfile, level, name_)
        if self.tagText is not None:
            showIndent(outfile, level)
            outfile.write('tagText=%s,\n' % quote_python(self.tagText).encode(ExternalEncoding))
        if self.spmId is not None:
            showIndent(outfile, level)
            outfile.write('spmId=%s,\n' % quote_python(self.spmId).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StorageTag, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tagText':
            tagText_ = child_.text
            tagText_ = self.gds_validate_string(tagText_, node, 'tagText')
            self.tagText = tagText_
        elif nodeName_ == 'spmId':
            spmId_ = child_.text
            spmId_ = self.gds_validate_string(spmId_, node, 'spmId')
            self.spmId = spmId_
        super(StorageTag, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = StorageTag.member_data_items_
        if StorageTag.superclass != None:
            member_items.update(StorageTag.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return StorageTag._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = StorageTag()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return StorageTag.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = StorageTag.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class StorageTag


class StorageVolume(Resource):
    member_data_items_ = {
        'size': MemberSpec_('size', 'xs:long', 0),
        'free': MemberSpec_('free', 'xs:long', 0),
        'mountPoints': MemberSpec_('mountPoints', 'HostMountPoint', 1),
        'vmfsVolume': MemberSpec_('vmfsVolume', 'xs:boolean', 0),
        'shared': MemberSpec_('shared', 'xs:boolean', 0),
        'assignedServerCount': MemberSpec_('assignedServerCount', 'xs:int', 0),
        'volumeType': MemberSpec_('volumeType', ['StorageTypeEnum', 'xs:string'], 0),
        'volumeId': MemberSpec_('volumeId', 'xs:string', 0),
        'connectionState': MemberSpec_('connectionState', 'xs:string', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, size=None, free=None, mountPoints=None, vmfsVolume=None, shared=None, assignedServerCount=None, volumeType=None, volumeId=None, connectionState=None):
        super(StorageVolume, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.size = size
        self.free = free
        if mountPoints is None:
            self.mountPoints = []
        else:
            self.mountPoints = mountPoints
        self.vmfsVolume = vmfsVolume
        self.shared = shared
        self.assignedServerCount = assignedServerCount
        self.volumeType = volumeType
        self.volumeId = volumeId
        self.connectionState = connectionState
    def factory(*args_, **kwargs_):
        if StorageVolume.subclass:
            return StorageVolume.subclass(*args_, **kwargs_)
        else:
            return StorageVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    sizeProp = property(get_size, set_size)
    def get_free(self): return self.free
    def set_free(self, free): self.free = free
    freeProp = property(get_free, set_free)
    def get_mountPoints(self): return self.mountPoints
    def set_mountPoints(self, mountPoints): self.mountPoints = mountPoints
    def add_mountPoints(self, value): self.mountPoints.append(value)
    def insert_mountPoints(self, index, value): self.mountPoints[index] = value
    mountPointsProp = property(get_mountPoints, set_mountPoints)
    def get_vmfsVolume(self): return self.vmfsVolume
    def set_vmfsVolume(self, vmfsVolume): self.vmfsVolume = vmfsVolume
    vmfsVolumeProp = property(get_vmfsVolume, set_vmfsVolume)
    def get_shared(self): return self.shared
    def set_shared(self, shared): self.shared = shared
    sharedProp = property(get_shared, set_shared)
    def get_assignedServerCount(self): return self.assignedServerCount
    def set_assignedServerCount(self, assignedServerCount): self.assignedServerCount = assignedServerCount
    assignedServerCountProp = property(get_assignedServerCount, set_assignedServerCount)
    def get_volumeType(self): return self.volumeType
    def set_volumeType(self, volumeType): self.volumeType = volumeType
    volumeTypeProp = property(get_volumeType, set_volumeType)
    def validate_StorageTypeEnum(self, value):
        # Validate type StorageTypeEnum, a restriction on xs:string.
        pass
    def get_volumeId(self): return self.volumeId
    def set_volumeId(self, volumeId): self.volumeId = volumeId
    volumeIdProp = property(get_volumeId, set_volumeId)
    def get_connectionState(self): return self.connectionState
    def set_connectionState(self, connectionState): self.connectionState = connectionState
    connectionStateProp = property(get_connectionState, set_connectionState)
    def export(self, outfile, level, namespace_='', name_='StorageVolume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StorageVolume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StorageVolume'):
        super(StorageVolume, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StorageVolume')
    def exportChildren(self, outfile, level, namespace_='', name_='StorageVolume', fromsubclass_=False):
        super(StorageVolume, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('<%ssize>%s</%ssize>\n' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_))
        if self.free is not None:
            showIndent(outfile, level)
            outfile.write('<%sfree>%s</%sfree>\n' % (namespace_, self.gds_format_integer(self.free, input_name='free'), namespace_))
        for mountPoints_ in self.mountPoints:
            mountPoints_.export(outfile, level, namespace_, name_='mountPoints')
        if self.vmfsVolume is not None:
            showIndent(outfile, level)
            outfile.write('<%svmfsVolume>%s</%svmfsVolume>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.vmfsVolume)), input_name='vmfsVolume'), namespace_))
        if self.shared is not None:
            showIndent(outfile, level)
            outfile.write('<%sshared>%s</%sshared>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.shared)), input_name='shared'), namespace_))
        if self.assignedServerCount is not None:
            showIndent(outfile, level)
            outfile.write('<%sassignedServerCount>%s</%sassignedServerCount>\n' % (namespace_, self.gds_format_integer(self.assignedServerCount, input_name='assignedServerCount'), namespace_))
        if self.volumeType is not None:
            showIndent(outfile, level)
            outfile.write('<%svolumeType>%s</%svolumeType>\n' % (namespace_, self.gds_format_string(quote_xml(self.volumeType).encode(ExternalEncoding), input_name='volumeType'), namespace_))
        if self.volumeId is not None:
            showIndent(outfile, level)
            outfile.write('<%svolumeId>%s</%svolumeId>\n' % (namespace_, self.gds_format_string(quote_xml(self.volumeId).encode(ExternalEncoding), input_name='volumeId'), namespace_))
        if self.connectionState is not None:
            showIndent(outfile, level)
            outfile.write('<%sconnectionState>%s</%sconnectionState>\n' % (namespace_, self.gds_format_string(quote_xml(self.connectionState).encode(ExternalEncoding), input_name='connectionState'), namespace_))
    def hasContent_(self):
        if (
            self.size is not None or
            self.free is not None or
            self.mountPoints or
            self.vmfsVolume is not None or
            self.shared is not None or
            self.assignedServerCount is not None or
            self.volumeType is not None or
            self.volumeId is not None or
            self.connectionState is not None or
            super(StorageVolume, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StorageVolume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StorageVolume, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StorageVolume, self).exportLiteralChildren(outfile, level, name_)
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.free is not None:
            showIndent(outfile, level)
            outfile.write('free=%d,\n' % self.free)
        showIndent(outfile, level)
        outfile.write('mountPoints=[\n')
        level += 1
        for mountPoints_ in self.mountPoints:
            showIndent(outfile, level)
            outfile.write('model_.HostMountPoint(\n')
            mountPoints_.exportLiteral(outfile, level, name_='HostMountPoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.vmfsVolume is not None:
            showIndent(outfile, level)
            outfile.write('vmfsVolume=%s,\n' % self.vmfsVolume)
        if self.shared is not None:
            showIndent(outfile, level)
            outfile.write('shared=%s,\n' % self.shared)
        if self.assignedServerCount is not None:
            showIndent(outfile, level)
            outfile.write('assignedServerCount=%d,\n' % self.assignedServerCount)
        if self.volumeType is not None:
            showIndent(outfile, level)
            outfile.write('volumeType=%s,\n' % quote_python(self.volumeType).encode(ExternalEncoding))
        if self.volumeId is not None:
            showIndent(outfile, level)
            outfile.write('volumeId=%s,\n' % quote_python(self.volumeId).encode(ExternalEncoding))
        if self.connectionState is not None:
            showIndent(outfile, level)
            outfile.write('connectionState=%s,\n' % quote_python(self.connectionState).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StorageVolume, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'free':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'free')
            self.free = ival_
        elif nodeName_ == 'mountPoints':
            obj_ = HostMountPoint.factory()
            obj_.build(child_)
            self.mountPoints.append(obj_)
        elif nodeName_ == 'vmfsVolume':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'vmfsVolume')
            self.vmfsVolume = ival_
        elif nodeName_ == 'shared':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'shared')
            self.shared = ival_
        elif nodeName_ == 'assignedServerCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'assignedServerCount')
            self.assignedServerCount = ival_
        elif nodeName_ == 'volumeType':
            volumeType_ = child_.text
            volumeType_ = self.gds_validate_string(volumeType_, node, 'volumeType')
            self.volumeType = volumeType_
            self.validate_StorageTypeEnum(self.volumeType)    # validate type StorageTypeEnum
        elif nodeName_ == 'volumeId':
            volumeId_ = child_.text
            volumeId_ = self.gds_validate_string(volumeId_, node, 'volumeId')
            self.volumeId = volumeId_
        elif nodeName_ == 'connectionState':
            connectionState_ = child_.text
            connectionState_ = self.gds_validate_string(connectionState_, node, 'connectionState')
            self.connectionState = connectionState_
        super(StorageVolume, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = StorageVolume.member_data_items_
        if StorageVolume.superclass != None:
            member_items.update(StorageVolume.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return StorageVolume._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = StorageVolume()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return StorageVolume.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = StorageVolume.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class StorageVolume


class SanVolumeTemplate(Resource):
    member_data_items_ = {
        'spmId': MemberSpec_('spmId', 'xs:string', 0),
        'description': MemberSpec_('description', 'xs:string', 0),
        'storageTemplateType': MemberSpec_('storageTemplateType', ['StorageTemplateTypeEnum', 'xs:string'], 0),
        'spmTemplateId': MemberSpec_('spmTemplateId', 'xs:string', 0),
        'provisioningType': MemberSpec_('provisioningType', ['StorageProvisioningTypeEnum', 'xs:string'], 0),
        'size': MemberSpec_('size', 'xs:long', 0),
        'raidLevel': MemberSpec_('raidLevel', ['RaidLevelEnum', 'xs:string'], 0),
        'osType': MemberSpec_('osType', ['OsTypeEnum', 'xs:string'], 0),
        'tags': MemberSpec_('tags', 'xs:string', 1),
        'minSize': MemberSpec_('minSize', 'xs:long', 0),
        'maxSize': MemberSpec_('maxSize', 'xs:long', 0),
        'allowedRaidLevels': MemberSpec_('allowedRaidLevels', ['RaidLevelEnum', 'xs:string'], 1),
        'allowedOsTypes': MemberSpec_('allowedOsTypes', ['OsTypeEnum', 'xs:string'], 1),
        'requiredTags': MemberSpec_('requiredTags', 'xs:string', 1),
        'excludeTags': MemberSpec_('excludeTags', 'xs:string', 1),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, spmId=None, description=None, storageTemplateType=None, spmTemplateId=None, provisioningType=None, size=None, raidLevel=None, osType=None, tags=None, minSize=None, maxSize=None, allowedRaidLevels=None, allowedOsTypes=None, requiredTags=None, excludeTags=None):
        super(SanVolumeTemplate, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.spmId = spmId
        self.description = description
        self.storageTemplateType = storageTemplateType
        self.spmTemplateId = spmTemplateId
        self.provisioningType = provisioningType
        self.size = size
        self.raidLevel = raidLevel
        self.osType = osType
        if tags is None:
            self.tags = []
        else:
            self.tags = tags
        self.minSize = minSize
        self.maxSize = maxSize
        if allowedRaidLevels is None:
            self.allowedRaidLevels = []
        else:
            self.allowedRaidLevels = allowedRaidLevels
        if allowedOsTypes is None:
            self.allowedOsTypes = []
        else:
            self.allowedOsTypes = allowedOsTypes
        if requiredTags is None:
            self.requiredTags = []
        else:
            self.requiredTags = requiredTags
        if excludeTags is None:
            self.excludeTags = []
        else:
            self.excludeTags = excludeTags
    def factory(*args_, **kwargs_):
        if SanVolumeTemplate.subclass:
            return SanVolumeTemplate.subclass(*args_, **kwargs_)
        else:
            return SanVolumeTemplate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spmId(self): return self.spmId
    def set_spmId(self, spmId): self.spmId = spmId
    spmIdProp = property(get_spmId, set_spmId)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_storageTemplateType(self): return self.storageTemplateType
    def set_storageTemplateType(self, storageTemplateType): self.storageTemplateType = storageTemplateType
    storageTemplateTypeProp = property(get_storageTemplateType, set_storageTemplateType)
    def validate_StorageTemplateTypeEnum(self, value):
        # Validate type StorageTemplateTypeEnum, a restriction on xs:string.
        pass
    def get_spmTemplateId(self): return self.spmTemplateId
    def set_spmTemplateId(self, spmTemplateId): self.spmTemplateId = spmTemplateId
    spmTemplateIdProp = property(get_spmTemplateId, set_spmTemplateId)
    def get_provisioningType(self): return self.provisioningType
    def set_provisioningType(self, provisioningType): self.provisioningType = provisioningType
    provisioningTypeProp = property(get_provisioningType, set_provisioningType)
    def validate_StorageProvisioningTypeEnum(self, value):
        # Validate type StorageProvisioningTypeEnum, a restriction on xs:string.
        pass
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    sizeProp = property(get_size, set_size)
    def get_raidLevel(self): return self.raidLevel
    def set_raidLevel(self, raidLevel): self.raidLevel = raidLevel
    raidLevelProp = property(get_raidLevel, set_raidLevel)
    def validate_RaidLevelEnum(self, value):
        # Validate type RaidLevelEnum, a restriction on xs:string.
        pass
    def get_osType(self): return self.osType
    def set_osType(self, osType): self.osType = osType
    osTypeProp = property(get_osType, set_osType)
    def validate_OsTypeEnum(self, value):
        # Validate type OsTypeEnum, a restriction on xs:string.
        pass
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags(self, index, value): self.tags[index] = value
    tagsProp = property(get_tags, set_tags)
    def get_minSize(self): return self.minSize
    def set_minSize(self, minSize): self.minSize = minSize
    minSizeProp = property(get_minSize, set_minSize)
    def get_maxSize(self): return self.maxSize
    def set_maxSize(self, maxSize): self.maxSize = maxSize
    maxSizeProp = property(get_maxSize, set_maxSize)
    def get_allowedRaidLevels(self): return self.allowedRaidLevels
    def set_allowedRaidLevels(self, allowedRaidLevels): self.allowedRaidLevels = allowedRaidLevels
    def add_allowedRaidLevels(self, value): self.allowedRaidLevels.append(value)
    def insert_allowedRaidLevels(self, index, value): self.allowedRaidLevels[index] = value
    allowedRaidLevelsProp = property(get_allowedRaidLevels, set_allowedRaidLevels)
    def get_allowedOsTypes(self): return self.allowedOsTypes
    def set_allowedOsTypes(self, allowedOsTypes): self.allowedOsTypes = allowedOsTypes
    def add_allowedOsTypes(self, value): self.allowedOsTypes.append(value)
    def insert_allowedOsTypes(self, index, value): self.allowedOsTypes[index] = value
    allowedOsTypesProp = property(get_allowedOsTypes, set_allowedOsTypes)
    def get_requiredTags(self): return self.requiredTags
    def set_requiredTags(self, requiredTags): self.requiredTags = requiredTags
    def add_requiredTags(self, value): self.requiredTags.append(value)
    def insert_requiredTags(self, index, value): self.requiredTags[index] = value
    requiredTagsProp = property(get_requiredTags, set_requiredTags)
    def get_excludeTags(self): return self.excludeTags
    def set_excludeTags(self, excludeTags): self.excludeTags = excludeTags
    def add_excludeTags(self, value): self.excludeTags.append(value)
    def insert_excludeTags(self, index, value): self.excludeTags[index] = value
    excludeTagsProp = property(get_excludeTags, set_excludeTags)
    def export(self, outfile, level, namespace_='', name_='SanVolumeTemplate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanVolumeTemplate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SanVolumeTemplate'):
        super(SanVolumeTemplate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SanVolumeTemplate')
    def exportChildren(self, outfile, level, namespace_='', name_='SanVolumeTemplate', fromsubclass_=False):
        super(SanVolumeTemplate, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.spmId is not None:
            showIndent(outfile, level)
            outfile.write('<%sspmId>%s</%sspmId>\n' % (namespace_, self.gds_format_string(quote_xml(self.spmId).encode(ExternalEncoding), input_name='spmId'), namespace_))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.storageTemplateType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageTemplateType>%s</%sstorageTemplateType>\n' % (namespace_, self.gds_format_string(quote_xml(self.storageTemplateType).encode(ExternalEncoding), input_name='storageTemplateType'), namespace_))
        if self.spmTemplateId is not None:
            showIndent(outfile, level)
            outfile.write('<%sspmTemplateId>%s</%sspmTemplateId>\n' % (namespace_, self.gds_format_string(quote_xml(self.spmTemplateId).encode(ExternalEncoding), input_name='spmTemplateId'), namespace_))
        if self.provisioningType is not None:
            showIndent(outfile, level)
            outfile.write('<%sprovisioningType>%s</%sprovisioningType>\n' % (namespace_, self.gds_format_string(quote_xml(self.provisioningType).encode(ExternalEncoding), input_name='provisioningType'), namespace_))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('<%ssize>%s</%ssize>\n' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_))
        if self.raidLevel is not None:
            showIndent(outfile, level)
            outfile.write('<%sraidLevel>%s</%sraidLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.raidLevel).encode(ExternalEncoding), input_name='raidLevel'), namespace_))
        if self.osType is not None:
            showIndent(outfile, level)
            outfile.write('<%sosType>%s</%sosType>\n' % (namespace_, self.gds_format_string(quote_xml(self.osType).encode(ExternalEncoding), input_name='osType'), namespace_))
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('<%stags>%s</%stags>\n' % (namespace_, self.gds_format_string(quote_xml(tags_).encode(ExternalEncoding), input_name='tags'), namespace_))
        if self.minSize is not None:
            showIndent(outfile, level)
            outfile.write('<%sminSize>%s</%sminSize>\n' % (namespace_, self.gds_format_integer(self.minSize, input_name='minSize'), namespace_))
        if self.maxSize is not None:
            showIndent(outfile, level)
            outfile.write('<%smaxSize>%s</%smaxSize>\n' % (namespace_, self.gds_format_integer(self.maxSize, input_name='maxSize'), namespace_))
        for allowedRaidLevels_ in self.allowedRaidLevels:
            showIndent(outfile, level)
            outfile.write('<%sallowedRaidLevels>%s</%sallowedRaidLevels>\n' % (namespace_, self.gds_format_string(quote_xml(allowedRaidLevels_).encode(ExternalEncoding), input_name='allowedRaidLevels'), namespace_))
        for allowedOsTypes_ in self.allowedOsTypes:
            showIndent(outfile, level)
            outfile.write('<%sallowedOsTypes>%s</%sallowedOsTypes>\n' % (namespace_, self.gds_format_string(quote_xml(allowedOsTypes_).encode(ExternalEncoding), input_name='allowedOsTypes'), namespace_))
        for requiredTags_ in self.requiredTags:
            showIndent(outfile, level)
            outfile.write('<%srequiredTags>%s</%srequiredTags>\n' % (namespace_, self.gds_format_string(quote_xml(requiredTags_).encode(ExternalEncoding), input_name='requiredTags'), namespace_))
        for excludeTags_ in self.excludeTags:
            showIndent(outfile, level)
            outfile.write('<%sexcludeTags>%s</%sexcludeTags>\n' % (namespace_, self.gds_format_string(quote_xml(excludeTags_).encode(ExternalEncoding), input_name='excludeTags'), namespace_))
    def hasContent_(self):
        if (
            self.spmId is not None or
            self.description is not None or
            self.storageTemplateType is not None or
            self.spmTemplateId is not None or
            self.provisioningType is not None or
            self.size is not None or
            self.raidLevel is not None or
            self.osType is not None or
            self.tags or
            self.minSize is not None or
            self.maxSize is not None or
            self.allowedRaidLevels or
            self.allowedOsTypes or
            self.requiredTags or
            self.excludeTags or
            super(SanVolumeTemplate, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SanVolumeTemplate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SanVolumeTemplate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SanVolumeTemplate, self).exportLiteralChildren(outfile, level, name_)
        if self.spmId is not None:
            showIndent(outfile, level)
            outfile.write('spmId=%s,\n' % quote_python(self.spmId).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.storageTemplateType is not None:
            showIndent(outfile, level)
            outfile.write('storageTemplateType=%s,\n' % quote_python(self.storageTemplateType).encode(ExternalEncoding))
        if self.spmTemplateId is not None:
            showIndent(outfile, level)
            outfile.write('spmTemplateId=%s,\n' % quote_python(self.spmTemplateId).encode(ExternalEncoding))
        if self.provisioningType is not None:
            showIndent(outfile, level)
            outfile.write('provisioningType=%s,\n' % quote_python(self.provisioningType).encode(ExternalEncoding))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.raidLevel is not None:
            showIndent(outfile, level)
            outfile.write('raidLevel=%s,\n' % quote_python(self.raidLevel).encode(ExternalEncoding))
        if self.osType is not None:
            showIndent(outfile, level)
            outfile.write('osType=%s,\n' % quote_python(self.osType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(tags_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.minSize is not None:
            showIndent(outfile, level)
            outfile.write('minSize=%d,\n' % self.minSize)
        if self.maxSize is not None:
            showIndent(outfile, level)
            outfile.write('maxSize=%d,\n' % self.maxSize)
        showIndent(outfile, level)
        outfile.write('allowedRaidLevels=[\n')
        level += 1
        for allowedRaidLevels_ in self.allowedRaidLevels:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(allowedRaidLevels_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('allowedOsTypes=[\n')
        level += 1
        for allowedOsTypes_ in self.allowedOsTypes:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(allowedOsTypes_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('requiredTags=[\n')
        level += 1
        for requiredTags_ in self.requiredTags:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(requiredTags_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('excludeTags=[\n')
        level += 1
        for excludeTags_ in self.excludeTags:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(excludeTags_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SanVolumeTemplate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spmId':
            spmId_ = child_.text
            spmId_ = self.gds_validate_string(spmId_, node, 'spmId')
            self.spmId = spmId_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'storageTemplateType':
            storageTemplateType_ = child_.text
            storageTemplateType_ = self.gds_validate_string(storageTemplateType_, node, 'storageTemplateType')
            self.storageTemplateType = storageTemplateType_
            self.validate_StorageTemplateTypeEnum(self.storageTemplateType)    # validate type StorageTemplateTypeEnum
        elif nodeName_ == 'spmTemplateId':
            spmTemplateId_ = child_.text
            spmTemplateId_ = self.gds_validate_string(spmTemplateId_, node, 'spmTemplateId')
            self.spmTemplateId = spmTemplateId_
        elif nodeName_ == 'provisioningType':
            provisioningType_ = child_.text
            provisioningType_ = self.gds_validate_string(provisioningType_, node, 'provisioningType')
            self.provisioningType = provisioningType_
            self.validate_StorageProvisioningTypeEnum(self.provisioningType)    # validate type StorageProvisioningTypeEnum
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'raidLevel':
            raidLevel_ = child_.text
            raidLevel_ = self.gds_validate_string(raidLevel_, node, 'raidLevel')
            self.raidLevel = raidLevel_
            self.validate_RaidLevelEnum(self.raidLevel)    # validate type RaidLevelEnum
        elif nodeName_ == 'osType':
            osType_ = child_.text
            osType_ = self.gds_validate_string(osType_, node, 'osType')
            self.osType = osType_
            self.validate_OsTypeEnum(self.osType)    # validate type OsTypeEnum
        elif nodeName_ == 'tags':
            tags_ = child_.text
            tags_ = self.gds_validate_string(tags_, node, 'tags')
            self.tags.append(tags_)
        elif nodeName_ == 'minSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'minSize')
            self.minSize = ival_
        elif nodeName_ == 'maxSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maxSize')
            self.maxSize = ival_
        elif nodeName_ == 'allowedRaidLevels':
            allowedRaidLevels_ = child_.text
            allowedRaidLevels_ = self.gds_validate_string(allowedRaidLevels_, node, 'allowedRaidLevels')
            self.allowedRaidLevels.append(allowedRaidLevels_)
            self.validate_RaidLevelEnum(self.allowedRaidLevels)    # validate type RaidLevelEnum
        elif nodeName_ == 'allowedOsTypes':
            allowedOsTypes_ = child_.text
            allowedOsTypes_ = self.gds_validate_string(allowedOsTypes_, node, 'allowedOsTypes')
            self.allowedOsTypes.append(allowedOsTypes_)
            self.validate_OsTypeEnum(self.allowedOsTypes)    # validate type OsTypeEnum
        elif nodeName_ == 'requiredTags':
            requiredTags_ = child_.text
            requiredTags_ = self.gds_validate_string(requiredTags_, node, 'requiredTags')
            self.requiredTags.append(requiredTags_)
        elif nodeName_ == 'excludeTags':
            excludeTags_ = child_.text
            excludeTags_ = self.gds_validate_string(excludeTags_, node, 'excludeTags')
            self.excludeTags.append(excludeTags_)
        super(SanVolumeTemplate, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = SanVolumeTemplate.member_data_items_
        if SanVolumeTemplate.superclass != None:
            member_items.update(SanVolumeTemplate.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return SanVolumeTemplate._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = SanVolumeTemplate()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return SanVolumeTemplate.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = SanVolumeTemplate.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class SanVolumeTemplate


class PortGroup(Resource):
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'xs:string', 0),
        'virtualSwitchId': MemberSpec_('virtualSwitchId', 'xs:string', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, type_=None, virtualSwitchId=None):
        super(PortGroup, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.type_ = type_
        self.virtualSwitchId = virtualSwitchId
    def factory(*args_, **kwargs_):
        if PortGroup.subclass:
            return PortGroup.subclass(*args_, **kwargs_)
        else:
            return PortGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_virtualSwitchId(self): return self.virtualSwitchId
    def set_virtualSwitchId(self, virtualSwitchId): self.virtualSwitchId = virtualSwitchId
    virtualSwitchIdProp = property(get_virtualSwitchId, set_virtualSwitchId)
    def export(self, outfile, level, namespace_='', name_='PortGroup', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortGroup')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortGroup'):
        super(PortGroup, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PortGroup')
    def exportChildren(self, outfile, level, namespace_='', name_='PortGroup', fromsubclass_=False):
        super(PortGroup, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
        if self.virtualSwitchId is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtualSwitchId>%s</%svirtualSwitchId>\n' % (namespace_, self.gds_format_string(quote_xml(self.virtualSwitchId).encode(ExternalEncoding), input_name='virtualSwitchId'), namespace_))
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.virtualSwitchId is not None or
            super(PortGroup, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PortGroup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PortGroup, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PortGroup, self).exportLiteralChildren(outfile, level, name_)
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.virtualSwitchId is not None:
            showIndent(outfile, level)
            outfile.write('virtualSwitchId=%s,\n' % quote_python(self.virtualSwitchId).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PortGroup, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'virtualSwitchId':
            virtualSwitchId_ = child_.text
            virtualSwitchId_ = self.gds_validate_string(virtualSwitchId_, node, 'virtualSwitchId')
            self.virtualSwitchId = virtualSwitchId_
        super(PortGroup, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = PortGroup.member_data_items_
        if PortGroup.superclass != None:
            member_items.update(PortGroup.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return PortGroup._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = PortGroup()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return PortGroup.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = PortGroup.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class PortGroup


class VirtualSwitch(Resource):
    member_data_items_ = {
        'switchType': MemberSpec_('switchType', 'xs:string', 0),
        'networkInterfaces': MemberSpec_('networkInterfaces', 'xs:string', 1),
        'subnetIds': MemberSpec_('subnetIds', 'xs:string', 1),
        'portGroups': MemberSpec_('portGroups', 'PortGroup', 1),
        'connectionState': MemberSpec_('connectionState', 'xs:string', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, switchType=None, networkInterfaces=None, subnetIds=None, portGroups=None, connectionState=None):
        super(VirtualSwitch, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.switchType = switchType
        if networkInterfaces is None:
            self.networkInterfaces = []
        else:
            self.networkInterfaces = networkInterfaces
        if subnetIds is None:
            self.subnetIds = []
        else:
            self.subnetIds = subnetIds
        if portGroups is None:
            self.portGroups = []
        else:
            self.portGroups = portGroups
        self.connectionState = connectionState
    def factory(*args_, **kwargs_):
        if VirtualSwitch.subclass:
            return VirtualSwitch.subclass(*args_, **kwargs_)
        else:
            return VirtualSwitch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_switchType(self): return self.switchType
    def set_switchType(self, switchType): self.switchType = switchType
    switchTypeProp = property(get_switchType, set_switchType)
    def get_networkInterfaces(self): return self.networkInterfaces
    def set_networkInterfaces(self, networkInterfaces): self.networkInterfaces = networkInterfaces
    def add_networkInterfaces(self, value): self.networkInterfaces.append(value)
    def insert_networkInterfaces(self, index, value): self.networkInterfaces[index] = value
    networkInterfacesProp = property(get_networkInterfaces, set_networkInterfaces)
    def get_subnetIds(self): return self.subnetIds
    def set_subnetIds(self, subnetIds): self.subnetIds = subnetIds
    def add_subnetIds(self, value): self.subnetIds.append(value)
    def insert_subnetIds(self, index, value): self.subnetIds[index] = value
    subnetIdsProp = property(get_subnetIds, set_subnetIds)
    def get_portGroups(self): return self.portGroups
    def set_portGroups(self, portGroups): self.portGroups = portGroups
    def add_portGroups(self, value): self.portGroups.append(value)
    def insert_portGroups(self, index, value): self.portGroups[index] = value
    portGroupsProp = property(get_portGroups, set_portGroups)
    def get_connectionState(self): return self.connectionState
    def set_connectionState(self, connectionState): self.connectionState = connectionState
    connectionStateProp = property(get_connectionState, set_connectionState)
    def export(self, outfile, level, namespace_='', name_='VirtualSwitch', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSwitch')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualSwitch'):
        super(VirtualSwitch, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSwitch')
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualSwitch', fromsubclass_=False):
        super(VirtualSwitch, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.switchType is not None:
            showIndent(outfile, level)
            outfile.write('<%sswitchType>%s</%sswitchType>\n' % (namespace_, self.gds_format_string(quote_xml(self.switchType).encode(ExternalEncoding), input_name='switchType'), namespace_))
        for networkInterfaces_ in self.networkInterfaces:
            showIndent(outfile, level)
            outfile.write('<%snetworkInterfaces>%s</%snetworkInterfaces>\n' % (namespace_, self.gds_format_string(quote_xml(networkInterfaces_).encode(ExternalEncoding), input_name='networkInterfaces'), namespace_))
        for subnetIds_ in self.subnetIds:
            showIndent(outfile, level)
            outfile.write('<%ssubnetIds>%s</%ssubnetIds>\n' % (namespace_, self.gds_format_string(quote_xml(subnetIds_).encode(ExternalEncoding), input_name='subnetIds'), namespace_))
        for portGroups_ in self.portGroups:
            portGroups_.export(outfile, level, namespace_, name_='portGroups')
        if self.connectionState is not None:
            showIndent(outfile, level)
            outfile.write('<%sconnectionState>%s</%sconnectionState>\n' % (namespace_, self.gds_format_string(quote_xml(self.connectionState).encode(ExternalEncoding), input_name='connectionState'), namespace_))
    def hasContent_(self):
        if (
            self.switchType is not None or
            self.networkInterfaces or
            self.subnetIds or
            self.portGroups or
            self.connectionState is not None or
            super(VirtualSwitch, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualSwitch'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VirtualSwitch, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VirtualSwitch, self).exportLiteralChildren(outfile, level, name_)
        if self.switchType is not None:
            showIndent(outfile, level)
            outfile.write('switchType=%s,\n' % quote_python(self.switchType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('networkInterfaces=[\n')
        level += 1
        for networkInterfaces_ in self.networkInterfaces:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(networkInterfaces_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('subnetIds=[\n')
        level += 1
        for subnetIds_ in self.subnetIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(subnetIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('portGroups=[\n')
        level += 1
        for portGroups_ in self.portGroups:
            showIndent(outfile, level)
            outfile.write('model_.PortGroup(\n')
            portGroups_.exportLiteral(outfile, level, name_='PortGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.connectionState is not None:
            showIndent(outfile, level)
            outfile.write('connectionState=%s,\n' % quote_python(self.connectionState).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VirtualSwitch, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'switchType':
            switchType_ = child_.text
            switchType_ = self.gds_validate_string(switchType_, node, 'switchType')
            self.switchType = switchType_
        elif nodeName_ == 'networkInterfaces':
            networkInterfaces_ = child_.text
            networkInterfaces_ = self.gds_validate_string(networkInterfaces_, node, 'networkInterfaces')
            self.networkInterfaces.append(networkInterfaces_)
        elif nodeName_ == 'subnetIds':
            subnetIds_ = child_.text
            subnetIds_ = self.gds_validate_string(subnetIds_, node, 'subnetIds')
            self.subnetIds.append(subnetIds_)
        elif nodeName_ == 'portGroups':
            obj_ = PortGroup.factory()
            obj_.build(child_)
            self.portGroups.append(obj_)
        elif nodeName_ == 'connectionState':
            connectionState_ = child_.text
            connectionState_ = self.gds_validate_string(connectionState_, node, 'connectionState')
            self.connectionState = connectionState_
        super(VirtualSwitch, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VirtualSwitch.member_data_items_
        if VirtualSwitch.superclass != None:
            member_items.update(VirtualSwitch.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VirtualSwitch._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VirtualSwitch()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VirtualSwitch.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VirtualSwitch.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VirtualSwitch


class DeployableSoftware(Resource):
    member_data_items_ = {
        'os': MemberSpec_('os', 'OsProfile', 0),
        'location': MemberSpec_('location', 'xs:string', 0),
        'size': MemberSpec_('size', 'xs:long', 0),
        'memorySize': MemberSpec_('memorySize', 'xs:long', 0),
        'processorCount': MemberSpec_('processorCount', 'xs:int', 0),
        'processorArchitecture': MemberSpec_('processorArchitecture', ['ProcessorArchitectureEnum', 'xs:string'], 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, os=None, location=None, size=None, memorySize=None, processorCount=None, processorArchitecture=None, extensiontype_=None):
        super(DeployableSoftware, self).__init__(resourceManagerId, utilization, limits, vendorProperties, extensiontype_, )
        self.os = os
        self.location = location
        self.size = size
        self.memorySize = memorySize
        self.processorCount = processorCount
        self.processorArchitecture = processorArchitecture
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DeployableSoftware.subclass:
            return DeployableSoftware.subclass(*args_, **kwargs_)
        else:
            return DeployableSoftware(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_os(self): return self.os
    def set_os(self, os): self.os = os
    osProp = property(get_os, set_os)
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    locationProp = property(get_location, set_location)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    sizeProp = property(get_size, set_size)
    def get_memorySize(self): return self.memorySize
    def set_memorySize(self, memorySize): self.memorySize = memorySize
    memorySizeProp = property(get_memorySize, set_memorySize)
    def get_processorCount(self): return self.processorCount
    def set_processorCount(self, processorCount): self.processorCount = processorCount
    processorCountProp = property(get_processorCount, set_processorCount)
    def get_processorArchitecture(self): return self.processorArchitecture
    def set_processorArchitecture(self, processorArchitecture): self.processorArchitecture = processorArchitecture
    processorArchitectureProp = property(get_processorArchitecture, set_processorArchitecture)
    def validate_ProcessorArchitectureEnum(self, value):
        # Validate type ProcessorArchitectureEnum, a restriction on xs:string.
        pass
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DeployableSoftware', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeployableSoftware')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeployableSoftware'):
        super(DeployableSoftware, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeployableSoftware')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DeployableSoftware', fromsubclass_=False):
        super(DeployableSoftware, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.os is not None:
            self.os.export(outfile, level, namespace_, name_='os')
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('<%slocation>%s</%slocation>\n' % (namespace_, self.gds_format_string(quote_xml(self.location).encode(ExternalEncoding), input_name='location'), namespace_))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('<%ssize>%s</%ssize>\n' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_))
        if self.memorySize is not None:
            showIndent(outfile, level)
            outfile.write('<%smemorySize>%s</%smemorySize>\n' % (namespace_, self.gds_format_integer(self.memorySize, input_name='memorySize'), namespace_))
        if self.processorCount is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorCount>%s</%sprocessorCount>\n' % (namespace_, self.gds_format_integer(self.processorCount, input_name='processorCount'), namespace_))
        if self.processorArchitecture is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocessorArchitecture>%s</%sprocessorArchitecture>\n' % (namespace_, self.gds_format_string(quote_xml(self.processorArchitecture).encode(ExternalEncoding), input_name='processorArchitecture'), namespace_))
    def hasContent_(self):
        if (
            self.os is not None or
            self.location is not None or
            self.size is not None or
            self.memorySize is not None or
            self.processorCount is not None or
            self.processorArchitecture is not None or
            super(DeployableSoftware, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeployableSoftware'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeployableSoftware, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeployableSoftware, self).exportLiteralChildren(outfile, level, name_)
        if self.os is not None:
            showIndent(outfile, level)
            outfile.write('os=model_.OsProfile(\n')
            self.os.exportLiteral(outfile, level, name_='os')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=%s,\n' % quote_python(self.location).encode(ExternalEncoding))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.memorySize is not None:
            showIndent(outfile, level)
            outfile.write('memorySize=%d,\n' % self.memorySize)
        if self.processorCount is not None:
            showIndent(outfile, level)
            outfile.write('processorCount=%d,\n' % self.processorCount)
        if self.processorArchitecture is not None:
            showIndent(outfile, level)
            outfile.write('processorArchitecture=%s,\n' % quote_python(self.processorArchitecture).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(DeployableSoftware, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'os':
            obj_ = OsProfile.factory()
            obj_.build(child_)
            self.set_os(obj_)
        elif nodeName_ == 'location':
            location_ = child_.text
            location_ = self.gds_validate_string(location_, node, 'location')
            self.location = location_
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'memorySize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memorySize')
            self.memorySize = ival_
        elif nodeName_ == 'processorCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'processorCount')
            self.processorCount = ival_
        elif nodeName_ == 'processorArchitecture':
            processorArchitecture_ = child_.text
            processorArchitecture_ = self.gds_validate_string(processorArchitecture_, node, 'processorArchitecture')
            self.processorArchitecture = processorArchitecture_
            self.validate_ProcessorArchitectureEnum(self.processorArchitecture)    # validate type ProcessorArchitectureEnum
        super(DeployableSoftware, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = DeployableSoftware.member_data_items_
        if DeployableSoftware.superclass != None:
            member_items.update(DeployableSoftware.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return DeployableSoftware._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = DeployableSoftware()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return DeployableSoftware.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = DeployableSoftware.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class DeployableSoftware


class VmTemplate(DeployableSoftware):
    member_data_items_ = {
        'virtualizationType': MemberSpec_('virtualizationType', ['VirtualizationEnum', 'xs:string'], 0),
        'vmNetAdapters': MemberSpec_('vmNetAdapters', 'VmNetAdapter', 1),
        'vmScsiControllers': MemberSpec_('vmScsiControllers', 'VmScsiController', 1),
        'vmDisks': MemberSpec_('vmDisks', 'VmDisk', 1),
        'vmGenericDevices': MemberSpec_('vmGenericDevices', 'VmGenericDevice', 1),
        'vmGlobalSettings': MemberSpec_('vmGlobalSettings', 'VmGlobalSettings', 0),
        'vmHostId': MemberSpec_('vmHostId', 'xs:string', 0),
        'cpuResourceAllocation': MemberSpec_('cpuResourceAllocation', 'ResourceAllocation', 0),
        'memoryResourceAllocation': MemberSpec_('memoryResourceAllocation', 'ResourceAllocation', 0),
        }
    subclass = None
    superclass = DeployableSoftware
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, os=None, location=None, size=None, memorySize=None, processorCount=None, processorArchitecture=None, virtualizationType=None, vmNetAdapters=None, vmScsiControllers=None, vmDisks=None, vmGenericDevices=None, vmGlobalSettings=None, vmHostId=None, cpuResourceAllocation=None, memoryResourceAllocation=None):
        super(VmTemplate, self).__init__(resourceManagerId, utilization, limits, vendorProperties, os, location, size, memorySize, processorCount, processorArchitecture, )
        self.virtualizationType = virtualizationType
        if vmNetAdapters is None:
            self.vmNetAdapters = []
        else:
            self.vmNetAdapters = vmNetAdapters
        if vmScsiControllers is None:
            self.vmScsiControllers = []
        else:
            self.vmScsiControllers = vmScsiControllers
        if vmDisks is None:
            self.vmDisks = []
        else:
            self.vmDisks = vmDisks
        if vmGenericDevices is None:
            self.vmGenericDevices = []
        else:
            self.vmGenericDevices = vmGenericDevices
        self.vmGlobalSettings = vmGlobalSettings
        self.vmHostId = vmHostId
        self.cpuResourceAllocation = cpuResourceAllocation
        self.memoryResourceAllocation = memoryResourceAllocation
    def factory(*args_, **kwargs_):
        if VmTemplate.subclass:
            return VmTemplate.subclass(*args_, **kwargs_)
        else:
            return VmTemplate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtualizationType(self): return self.virtualizationType
    def set_virtualizationType(self, virtualizationType): self.virtualizationType = virtualizationType
    virtualizationTypeProp = property(get_virtualizationType, set_virtualizationType)
    def validate_VirtualizationEnum(self, value):
        # Validate type VirtualizationEnum, a restriction on xs:string.
        pass
    def get_vmNetAdapters(self): return self.vmNetAdapters
    def set_vmNetAdapters(self, vmNetAdapters): self.vmNetAdapters = vmNetAdapters
    def add_vmNetAdapters(self, value): self.vmNetAdapters.append(value)
    def insert_vmNetAdapters(self, index, value): self.vmNetAdapters[index] = value
    vmNetAdaptersProp = property(get_vmNetAdapters, set_vmNetAdapters)
    def get_vmScsiControllers(self): return self.vmScsiControllers
    def set_vmScsiControllers(self, vmScsiControllers): self.vmScsiControllers = vmScsiControllers
    def add_vmScsiControllers(self, value): self.vmScsiControllers.append(value)
    def insert_vmScsiControllers(self, index, value): self.vmScsiControllers[index] = value
    vmScsiControllersProp = property(get_vmScsiControllers, set_vmScsiControllers)
    def get_vmDisks(self): return self.vmDisks
    def set_vmDisks(self, vmDisks): self.vmDisks = vmDisks
    def add_vmDisks(self, value): self.vmDisks.append(value)
    def insert_vmDisks(self, index, value): self.vmDisks[index] = value
    vmDisksProp = property(get_vmDisks, set_vmDisks)
    def get_vmGenericDevices(self): return self.vmGenericDevices
    def set_vmGenericDevices(self, vmGenericDevices): self.vmGenericDevices = vmGenericDevices
    def add_vmGenericDevices(self, value): self.vmGenericDevices.append(value)
    def insert_vmGenericDevices(self, index, value): self.vmGenericDevices[index] = value
    vmGenericDevicesProp = property(get_vmGenericDevices, set_vmGenericDevices)
    def get_vmGlobalSettings(self): return self.vmGlobalSettings
    def set_vmGlobalSettings(self, vmGlobalSettings): self.vmGlobalSettings = vmGlobalSettings
    vmGlobalSettingsProp = property(get_vmGlobalSettings, set_vmGlobalSettings)
    def get_vmHostId(self): return self.vmHostId
    def set_vmHostId(self, vmHostId): self.vmHostId = vmHostId
    vmHostIdProp = property(get_vmHostId, set_vmHostId)
    def get_cpuResourceAllocation(self): return self.cpuResourceAllocation
    def set_cpuResourceAllocation(self, cpuResourceAllocation): self.cpuResourceAllocation = cpuResourceAllocation
    cpuResourceAllocationProp = property(get_cpuResourceAllocation, set_cpuResourceAllocation)
    def get_memoryResourceAllocation(self): return self.memoryResourceAllocation
    def set_memoryResourceAllocation(self, memoryResourceAllocation): self.memoryResourceAllocation = memoryResourceAllocation
    memoryResourceAllocationProp = property(get_memoryResourceAllocation, set_memoryResourceAllocation)
    def export(self, outfile, level, namespace_='', name_='VmTemplate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmTemplate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmTemplate'):
        super(VmTemplate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmTemplate')
    def exportChildren(self, outfile, level, namespace_='', name_='VmTemplate', fromsubclass_=False):
        super(VmTemplate, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtualizationType>%s</%svirtualizationType>\n' % (namespace_, self.gds_format_string(quote_xml(self.virtualizationType).encode(ExternalEncoding), input_name='virtualizationType'), namespace_))
        for vmNetAdapters_ in self.vmNetAdapters:
            vmNetAdapters_.export(outfile, level, namespace_, name_='vmNetAdapters')
        for vmScsiControllers_ in self.vmScsiControllers:
            vmScsiControllers_.export(outfile, level, namespace_, name_='vmScsiControllers')
        for vmDisks_ in self.vmDisks:
            vmDisks_.export(outfile, level, namespace_, name_='vmDisks')
        for vmGenericDevices_ in self.vmGenericDevices:
            vmGenericDevices_.export(outfile, level, namespace_, name_='vmGenericDevices')
        if self.vmGlobalSettings is not None:
            self.vmGlobalSettings.export(outfile, level, namespace_, name_='vmGlobalSettings')
        if self.vmHostId is not None:
            showIndent(outfile, level)
            outfile.write('<%svmHostId>%s</%svmHostId>\n' % (namespace_, self.gds_format_string(quote_xml(self.vmHostId).encode(ExternalEncoding), input_name='vmHostId'), namespace_))
        if self.cpuResourceAllocation is not None:
            self.cpuResourceAllocation.export(outfile, level, namespace_, name_='cpuResourceAllocation')
        if self.memoryResourceAllocation is not None:
            self.memoryResourceAllocation.export(outfile, level, namespace_, name_='memoryResourceAllocation')
    def hasContent_(self):
        if (
            self.virtualizationType is not None or
            self.vmNetAdapters or
            self.vmScsiControllers or
            self.vmDisks or
            self.vmGenericDevices or
            self.vmGlobalSettings is not None or
            self.vmHostId is not None or
            self.cpuResourceAllocation is not None or
            self.memoryResourceAllocation is not None or
            super(VmTemplate, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VmTemplate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmTemplate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmTemplate, self).exportLiteralChildren(outfile, level, name_)
        if self.virtualizationType is not None:
            showIndent(outfile, level)
            outfile.write('virtualizationType=%s,\n' % quote_python(self.virtualizationType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('vmNetAdapters=[\n')
        level += 1
        for vmNetAdapters_ in self.vmNetAdapters:
            showIndent(outfile, level)
            outfile.write('model_.VmNetAdapter(\n')
            vmNetAdapters_.exportLiteral(outfile, level, name_='VmNetAdapter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmScsiControllers=[\n')
        level += 1
        for vmScsiControllers_ in self.vmScsiControllers:
            showIndent(outfile, level)
            outfile.write('model_.VmScsiController(\n')
            vmScsiControllers_.exportLiteral(outfile, level, name_='VmScsiController')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmDisks=[\n')
        level += 1
        for vmDisks_ in self.vmDisks:
            showIndent(outfile, level)
            outfile.write('model_.VmDisk(\n')
            vmDisks_.exportLiteral(outfile, level, name_='VmDisk')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vmGenericDevices=[\n')
        level += 1
        for vmGenericDevices_ in self.vmGenericDevices:
            showIndent(outfile, level)
            outfile.write('model_.VmGenericDevice(\n')
            vmGenericDevices_.exportLiteral(outfile, level, name_='VmGenericDevice')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.vmGlobalSettings is not None:
            showIndent(outfile, level)
            outfile.write('vmGlobalSettings=model_.VmGlobalSettings(\n')
            self.vmGlobalSettings.exportLiteral(outfile, level, name_='vmGlobalSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vmHostId is not None:
            showIndent(outfile, level)
            outfile.write('vmHostId=%s,\n' % quote_python(self.vmHostId).encode(ExternalEncoding))
        if self.cpuResourceAllocation is not None:
            showIndent(outfile, level)
            outfile.write('cpuResourceAllocation=model_.ResourceAllocation(\n')
            self.cpuResourceAllocation.exportLiteral(outfile, level, name_='cpuResourceAllocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.memoryResourceAllocation is not None:
            showIndent(outfile, level)
            outfile.write('memoryResourceAllocation=model_.ResourceAllocation(\n')
            self.memoryResourceAllocation.exportLiteral(outfile, level, name_='memoryResourceAllocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VmTemplate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'virtualizationType':
            virtualizationType_ = child_.text
            virtualizationType_ = self.gds_validate_string(virtualizationType_, node, 'virtualizationType')
            self.virtualizationType = virtualizationType_
            self.validate_VirtualizationEnum(self.virtualizationType)    # validate type VirtualizationEnum
        elif nodeName_ == 'vmNetAdapters':
            obj_ = VmNetAdapter.factory()
            obj_.build(child_)
            self.vmNetAdapters.append(obj_)
        elif nodeName_ == 'vmScsiControllers':
            obj_ = VmScsiController.factory()
            obj_.build(child_)
            self.vmScsiControllers.append(obj_)
        elif nodeName_ == 'vmDisks':
            obj_ = VmDisk.factory()
            obj_.build(child_)
            self.vmDisks.append(obj_)
        elif nodeName_ == 'vmGenericDevices':
            obj_ = VmGenericDevice.factory()
            obj_.build(child_)
            self.vmGenericDevices.append(obj_)
        elif nodeName_ == 'vmGlobalSettings':
            obj_ = VmGlobalSettings.factory()
            obj_.build(child_)
            self.set_vmGlobalSettings(obj_)
        elif nodeName_ == 'vmHostId':
            vmHostId_ = child_.text
            vmHostId_ = self.gds_validate_string(vmHostId_, node, 'vmHostId')
            self.vmHostId = vmHostId_
        elif nodeName_ == 'cpuResourceAllocation':
            obj_ = ResourceAllocation.factory()
            obj_.build(child_)
            self.set_cpuResourceAllocation(obj_)
        elif nodeName_ == 'memoryResourceAllocation':
            obj_ = ResourceAllocation.factory()
            obj_.build(child_)
            self.set_memoryResourceAllocation(obj_)
        super(VmTemplate, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VmTemplate.member_data_items_
        if VmTemplate.superclass != None:
            member_items.update(VmTemplate.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VmTemplate._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VmTemplate()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VmTemplate.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VmTemplate.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VmTemplate


class Image(DeployableSoftware):
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['ImageTypeEnum', 'xs:string'], 0),
        'dsType': MemberSpec_('dsType', ['DeploymentServiceTypeEnum', 'xs:string'], 0),
        }
    subclass = None
    superclass = DeployableSoftware
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, os=None, location=None, size=None, memorySize=None, processorCount=None, processorArchitecture=None, type_=None, dsType=None):
        super(Image, self).__init__(resourceManagerId, utilization, limits, vendorProperties, os, location, size, memorySize, processorCount, processorArchitecture, )
        self.type_ = type_
        self.dsType = dsType
    def factory(*args_, **kwargs_):
        if Image.subclass:
            return Image.subclass(*args_, **kwargs_)
        else:
            return Image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    typeProp = property(get_type, set_type)
    def validate_ImageTypeEnum(self, value):
        # Validate type ImageTypeEnum, a restriction on xs:string.
        pass
    def get_dsType(self): return self.dsType
    def set_dsType(self, dsType): self.dsType = dsType
    dsTypeProp = property(get_dsType, set_dsType)
    def validate_DeploymentServiceTypeEnum(self, value):
        # Validate type DeploymentServiceTypeEnum, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Image', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Image')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Image'):
        super(Image, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Image')
    def exportChildren(self, outfile, level, namespace_='', name_='Image', fromsubclass_=False):
        super(Image, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
        if self.dsType is not None:
            showIndent(outfile, level)
            outfile.write('<%sdsType>%s</%sdsType>\n' % (namespace_, self.gds_format_string(quote_xml(self.dsType).encode(ExternalEncoding), input_name='dsType'), namespace_))
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.dsType is not None or
            super(Image, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Image'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Image, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Image, self).exportLiteralChildren(outfile, level, name_)
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.dsType is not None:
            showIndent(outfile, level)
            outfile.write('dsType=%s,\n' % quote_python(self.dsType).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Image, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            self.validate_ImageTypeEnum(self.type_)    # validate type ImageTypeEnum
        elif nodeName_ == 'dsType':
            dsType_ = child_.text
            dsType_ = self.gds_validate_string(dsType_, node, 'dsType')
            self.dsType = dsType_
            self.validate_DeploymentServiceTypeEnum(self.dsType)    # validate type DeploymentServiceTypeEnum
        super(Image, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = Image.member_data_items_
        if Image.superclass != None:
            member_items.update(Image.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Image._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Image()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Image.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Image.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Image


class CloudImage(DeployableSoftware):
    member_data_items_ = {
        'sourceCapacityPoolIds': MemberSpec_('sourceCapacityPoolIds', 'xs:string', 1),
        }
    subclass = None
    superclass = DeployableSoftware
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, os=None, location=None, size=None, memorySize=None, processorCount=None, processorArchitecture=None, sourceCapacityPoolIds=None):
        super(CloudImage, self).__init__(resourceManagerId, utilization, limits, vendorProperties, os, location, size, memorySize, processorCount, processorArchitecture, )
        if sourceCapacityPoolIds is None:
            self.sourceCapacityPoolIds = []
        else:
            self.sourceCapacityPoolIds = sourceCapacityPoolIds
    def factory(*args_, **kwargs_):
        if CloudImage.subclass:
            return CloudImage.subclass(*args_, **kwargs_)
        else:
            return CloudImage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sourceCapacityPoolIds(self): return self.sourceCapacityPoolIds
    def set_sourceCapacityPoolIds(self, sourceCapacityPoolIds): self.sourceCapacityPoolIds = sourceCapacityPoolIds
    def add_sourceCapacityPoolIds(self, value): self.sourceCapacityPoolIds.append(value)
    def insert_sourceCapacityPoolIds(self, index, value): self.sourceCapacityPoolIds[index] = value
    sourceCapacityPoolIdsProp = property(get_sourceCapacityPoolIds, set_sourceCapacityPoolIds)
    def export(self, outfile, level, namespace_='', name_='CloudImage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CloudImage')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CloudImage'):
        super(CloudImage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CloudImage')
    def exportChildren(self, outfile, level, namespace_='', name_='CloudImage', fromsubclass_=False):
        super(CloudImage, self).exportChildren(outfile, level, namespace_, name_, True)
        for sourceCapacityPoolIds_ in self.sourceCapacityPoolIds:
            showIndent(outfile, level)
            outfile.write('<%ssourceCapacityPoolIds>%s</%ssourceCapacityPoolIds>\n' % (namespace_, self.gds_format_string(quote_xml(sourceCapacityPoolIds_).encode(ExternalEncoding), input_name='sourceCapacityPoolIds'), namespace_))
    def hasContent_(self):
        if (
            self.sourceCapacityPoolIds or
            super(CloudImage, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CloudImage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CloudImage, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CloudImage, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('sourceCapacityPoolIds=[\n')
        level += 1
        for sourceCapacityPoolIds_ in self.sourceCapacityPoolIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(sourceCapacityPoolIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CloudImage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sourceCapacityPoolIds':
            sourceCapacityPoolIds_ = child_.text
            sourceCapacityPoolIds_ = self.gds_validate_string(sourceCapacityPoolIds_, node, 'sourceCapacityPoolIds')
            self.sourceCapacityPoolIds.append(sourceCapacityPoolIds_)
        super(CloudImage, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = CloudImage.member_data_items_
        if CloudImage.superclass != None:
            member_items.update(CloudImage.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return CloudImage._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = CloudImage()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return CloudImage.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = CloudImage.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class CloudImage


class IpAddressRange(Resource):
    member_data_items_ = {
        'startAddress': MemberSpec_('startAddress', 'IpAddress', 0),
        'endAddress': MemberSpec_('endAddress', 'IpAddress', 0),
        'allocationType': MemberSpec_('allocationType', ['IpAllocationTypeEnum', 'xs:string'], 0),
        'addressRangeCount': MemberSpec_('addressRangeCount', 'xs:int', 0),
        'usedIpAddressCount': MemberSpec_('usedIpAddressCount', 'xs:int', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, startAddress=None, endAddress=None, allocationType=None, addressRangeCount=None, usedIpAddressCount=None):
        super(IpAddressRange, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.startAddress = startAddress
        self.endAddress = endAddress
        self.allocationType = allocationType
        self.addressRangeCount = addressRangeCount
        self.usedIpAddressCount = usedIpAddressCount
    def factory(*args_, **kwargs_):
        if IpAddressRange.subclass:
            return IpAddressRange.subclass(*args_, **kwargs_)
        else:
            return IpAddressRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startAddress(self): return self.startAddress
    def set_startAddress(self, startAddress): self.startAddress = startAddress
    startAddressProp = property(get_startAddress, set_startAddress)
    def get_endAddress(self): return self.endAddress
    def set_endAddress(self, endAddress): self.endAddress = endAddress
    endAddressProp = property(get_endAddress, set_endAddress)
    def get_allocationType(self): return self.allocationType
    def set_allocationType(self, allocationType): self.allocationType = allocationType
    allocationTypeProp = property(get_allocationType, set_allocationType)
    def validate_IpAllocationTypeEnum(self, value):
        # Validate type IpAllocationTypeEnum, a restriction on xs:string.
        pass
    def get_addressRangeCount(self): return self.addressRangeCount
    def set_addressRangeCount(self, addressRangeCount): self.addressRangeCount = addressRangeCount
    addressRangeCountProp = property(get_addressRangeCount, set_addressRangeCount)
    def get_usedIpAddressCount(self): return self.usedIpAddressCount
    def set_usedIpAddressCount(self, usedIpAddressCount): self.usedIpAddressCount = usedIpAddressCount
    usedIpAddressCountProp = property(get_usedIpAddressCount, set_usedIpAddressCount)
    def export(self, outfile, level, namespace_='', name_='IpAddressRange', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddressRange')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpAddressRange'):
        super(IpAddressRange, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddressRange')
    def exportChildren(self, outfile, level, namespace_='', name_='IpAddressRange', fromsubclass_=False):
        super(IpAddressRange, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.startAddress is not None:
            self.startAddress.export(outfile, level, namespace_, name_='startAddress')
        if self.endAddress is not None:
            self.endAddress.export(outfile, level, namespace_, name_='endAddress')
        if self.allocationType is not None:
            showIndent(outfile, level)
            outfile.write('<%sallocationType>%s</%sallocationType>\n' % (namespace_, self.gds_format_string(quote_xml(self.allocationType).encode(ExternalEncoding), input_name='allocationType'), namespace_))
        if self.addressRangeCount is not None:
            showIndent(outfile, level)
            outfile.write('<%saddressRangeCount>%s</%saddressRangeCount>\n' % (namespace_, self.gds_format_integer(self.addressRangeCount, input_name='addressRangeCount'), namespace_))
        if self.usedIpAddressCount is not None:
            showIndent(outfile, level)
            outfile.write('<%susedIpAddressCount>%s</%susedIpAddressCount>\n' % (namespace_, self.gds_format_integer(self.usedIpAddressCount, input_name='usedIpAddressCount'), namespace_))
    def hasContent_(self):
        if (
            self.startAddress is not None or
            self.endAddress is not None or
            self.allocationType is not None or
            self.addressRangeCount is not None or
            self.usedIpAddressCount is not None or
            super(IpAddressRange, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IpAddressRange'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpAddressRange, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpAddressRange, self).exportLiteralChildren(outfile, level, name_)
        if self.startAddress is not None:
            showIndent(outfile, level)
            outfile.write('startAddress=model_.IpAddress(\n')
            self.startAddress.exportLiteral(outfile, level, name_='startAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.endAddress is not None:
            showIndent(outfile, level)
            outfile.write('endAddress=model_.IpAddress(\n')
            self.endAddress.exportLiteral(outfile, level, name_='endAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.allocationType is not None:
            showIndent(outfile, level)
            outfile.write('allocationType=%s,\n' % quote_python(self.allocationType).encode(ExternalEncoding))
        if self.addressRangeCount is not None:
            showIndent(outfile, level)
            outfile.write('addressRangeCount=%d,\n' % self.addressRangeCount)
        if self.usedIpAddressCount is not None:
            showIndent(outfile, level)
            outfile.write('usedIpAddressCount=%d,\n' % self.usedIpAddressCount)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(IpAddressRange, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startAddress':
            obj_ = IpAddress.factory()
            obj_.build(child_)
            self.set_startAddress(obj_)
        elif nodeName_ == 'endAddress':
            obj_ = IpAddress.factory()
            obj_.build(child_)
            self.set_endAddress(obj_)
        elif nodeName_ == 'allocationType':
            allocationType_ = child_.text
            allocationType_ = self.gds_validate_string(allocationType_, node, 'allocationType')
            self.allocationType = allocationType_
            self.validate_IpAllocationTypeEnum(self.allocationType)    # validate type IpAllocationTypeEnum
        elif nodeName_ == 'addressRangeCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'addressRangeCount')
            self.addressRangeCount = ival_
        elif nodeName_ == 'usedIpAddressCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'usedIpAddressCount')
            self.usedIpAddressCount = ival_
        super(IpAddressRange, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = IpAddressRange.member_data_items_
        if IpAddressRange.superclass != None:
            member_items.update(IpAddressRange.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return IpAddressRange._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = IpAddressRange()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return IpAddressRange.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = IpAddressRange.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class IpAddressRange


class IpAddress(Resource):
    member_data_items_ = {
        'rangeId': MemberSpec_('rangeId', 'xs:string', 0),
        'address': MemberSpec_('address', 'xs:string', 0),
        'allocationType': MemberSpec_('allocationType', ['IpAllocationTypeEnum', 'xs:string'], 0),
        'inMaintenance': MemberSpec_('inMaintenance', 'xs:boolean', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, rangeId=None, address=None, allocationType=None, inMaintenance=False):
        super(IpAddress, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.rangeId = rangeId
        self.address = address
        self.allocationType = allocationType
        self.inMaintenance = inMaintenance
    def factory(*args_, **kwargs_):
        if IpAddress.subclass:
            return IpAddress.subclass(*args_, **kwargs_)
        else:
            return IpAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rangeId(self): return self.rangeId
    def set_rangeId(self, rangeId): self.rangeId = rangeId
    rangeIdProp = property(get_rangeId, set_rangeId)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    addressProp = property(get_address, set_address)
    def get_allocationType(self): return self.allocationType
    def set_allocationType(self, allocationType): self.allocationType = allocationType
    allocationTypeProp = property(get_allocationType, set_allocationType)
    def validate_IpAllocationTypeEnum(self, value):
        # Validate type IpAllocationTypeEnum, a restriction on xs:string.
        pass
    def get_inMaintenance(self): return self.inMaintenance
    def set_inMaintenance(self, inMaintenance): self.inMaintenance = inMaintenance
    inMaintenanceProp = property(get_inMaintenance, set_inMaintenance)
    def export(self, outfile, level, namespace_='', name_='IpAddress', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddress')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpAddress'):
        super(IpAddress, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddress')
    def exportChildren(self, outfile, level, namespace_='', name_='IpAddress', fromsubclass_=False):
        super(IpAddress, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.rangeId is not None:
            showIndent(outfile, level)
            outfile.write('<%srangeId>%s</%srangeId>\n' % (namespace_, self.gds_format_string(quote_xml(self.rangeId).encode(ExternalEncoding), input_name='rangeId'), namespace_))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('<%saddress>%s</%saddress>\n' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_))
        if self.allocationType is not None:
            showIndent(outfile, level)
            outfile.write('<%sallocationType>%s</%sallocationType>\n' % (namespace_, self.gds_format_string(quote_xml(self.allocationType).encode(ExternalEncoding), input_name='allocationType'), namespace_))
        if self.inMaintenance is not None:
            showIndent(outfile, level)
            outfile.write('<%sinMaintenance>%s</%sinMaintenance>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.inMaintenance)), input_name='inMaintenance'), namespace_))
    def hasContent_(self):
        if (
            self.rangeId is not None or
            self.address is not None or
            self.allocationType is not None or
            self.inMaintenance is not None or
            super(IpAddress, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IpAddress'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpAddress, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpAddress, self).exportLiteralChildren(outfile, level, name_)
        if self.rangeId is not None:
            showIndent(outfile, level)
            outfile.write('rangeId=%s,\n' % quote_python(self.rangeId).encode(ExternalEncoding))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.allocationType is not None:
            showIndent(outfile, level)
            outfile.write('allocationType=%s,\n' % quote_python(self.allocationType).encode(ExternalEncoding))
        if self.inMaintenance is not None:
            showIndent(outfile, level)
            outfile.write('inMaintenance=%s,\n' % self.inMaintenance)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(IpAddress, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rangeId':
            rangeId_ = child_.text
            rangeId_ = self.gds_validate_string(rangeId_, node, 'rangeId')
            self.rangeId = rangeId_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'allocationType':
            allocationType_ = child_.text
            allocationType_ = self.gds_validate_string(allocationType_, node, 'allocationType')
            self.allocationType = allocationType_
            self.validate_IpAllocationTypeEnum(self.allocationType)    # validate type IpAllocationTypeEnum
        elif nodeName_ == 'inMaintenance':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'inMaintenance')
            self.inMaintenance = ival_
        super(IpAddress, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = IpAddress.member_data_items_
        if IpAddress.superclass != None:
            member_items.update(IpAddress.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return IpAddress._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = IpAddress()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return IpAddress.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = IpAddress.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class IpAddress


class VcNetwork(Resource):
    member_data_items_ = {
        'vcDomainId': MemberSpec_('vcDomainId', 'xs:string', 0),
        'vcDomainGroupId': MemberSpec_('vcDomainGroupId', 'xs:string', 0),
        'networkEnabled': MemberSpec_('networkEnabled', 'xs:boolean', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, vcDomainId=None, vcDomainGroupId=None, networkEnabled=None):
        super(VcNetwork, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.vcDomainId = vcDomainId
        self.vcDomainGroupId = vcDomainGroupId
        self.networkEnabled = networkEnabled
    def factory(*args_, **kwargs_):
        if VcNetwork.subclass:
            return VcNetwork.subclass(*args_, **kwargs_)
        else:
            return VcNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vcDomainId(self): return self.vcDomainId
    def set_vcDomainId(self, vcDomainId): self.vcDomainId = vcDomainId
    vcDomainIdProp = property(get_vcDomainId, set_vcDomainId)
    def get_vcDomainGroupId(self): return self.vcDomainGroupId
    def set_vcDomainGroupId(self, vcDomainGroupId): self.vcDomainGroupId = vcDomainGroupId
    vcDomainGroupIdProp = property(get_vcDomainGroupId, set_vcDomainGroupId)
    def get_networkEnabled(self): return self.networkEnabled
    def set_networkEnabled(self, networkEnabled): self.networkEnabled = networkEnabled
    networkEnabledProp = property(get_networkEnabled, set_networkEnabled)
    def export(self, outfile, level, namespace_='', name_='VcNetwork', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VcNetwork')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VcNetwork'):
        super(VcNetwork, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VcNetwork')
    def exportChildren(self, outfile, level, namespace_='', name_='VcNetwork', fromsubclass_=False):
        super(VcNetwork, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.vcDomainId is not None:
            showIndent(outfile, level)
            outfile.write('<%svcDomainId>%s</%svcDomainId>\n' % (namespace_, self.gds_format_string(quote_xml(self.vcDomainId).encode(ExternalEncoding), input_name='vcDomainId'), namespace_))
        if self.vcDomainGroupId is not None:
            showIndent(outfile, level)
            outfile.write('<%svcDomainGroupId>%s</%svcDomainGroupId>\n' % (namespace_, self.gds_format_string(quote_xml(self.vcDomainGroupId).encode(ExternalEncoding), input_name='vcDomainGroupId'), namespace_))
        if self.networkEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%snetworkEnabled>%s</%snetworkEnabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.networkEnabled)), input_name='networkEnabled'), namespace_))
    def hasContent_(self):
        if (
            self.vcDomainId is not None or
            self.vcDomainGroupId is not None or
            self.networkEnabled is not None or
            super(VcNetwork, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VcNetwork'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VcNetwork, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VcNetwork, self).exportLiteralChildren(outfile, level, name_)
        if self.vcDomainId is not None:
            showIndent(outfile, level)
            outfile.write('vcDomainId=%s,\n' % quote_python(self.vcDomainId).encode(ExternalEncoding))
        if self.vcDomainGroupId is not None:
            showIndent(outfile, level)
            outfile.write('vcDomainGroupId=%s,\n' % quote_python(self.vcDomainGroupId).encode(ExternalEncoding))
        if self.networkEnabled is not None:
            showIndent(outfile, level)
            outfile.write('networkEnabled=%s,\n' % self.networkEnabled)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VcNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vcDomainId':
            vcDomainId_ = child_.text
            vcDomainId_ = self.gds_validate_string(vcDomainId_, node, 'vcDomainId')
            self.vcDomainId = vcDomainId_
        elif nodeName_ == 'vcDomainGroupId':
            vcDomainGroupId_ = child_.text
            vcDomainGroupId_ = self.gds_validate_string(vcDomainGroupId_, node, 'vcDomainGroupId')
            self.vcDomainGroupId = vcDomainGroupId_
        elif nodeName_ == 'networkEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'networkEnabled')
            self.networkEnabled = ival_
        super(VcNetwork, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = VcNetwork.member_data_items_
        if VcNetwork.superclass != None:
            member_items.update(VcNetwork.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return VcNetwork._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = VcNetwork()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return VcNetwork.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = VcNetwork.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class VcNetwork


class GroupIdType(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xs:string', 0),
        'networkTypes': MemberSpec_('networkTypes', ['NetworkTypeEnum', 'xs:string'], 1),
        }
    subclass = None
    superclass = None
    def __init__(self, id=None, networkTypes=None):
        self.id = id
        if networkTypes is None:
            self.networkTypes = []
        else:
            self.networkTypes = networkTypes
    def factory(*args_, **kwargs_):
        if GroupIdType.subclass:
            return GroupIdType.subclass(*args_, **kwargs_)
        else:
            return GroupIdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    idProp = property(get_id, set_id)
    def get_networkTypes(self): return self.networkTypes
    def set_networkTypes(self, networkTypes): self.networkTypes = networkTypes
    def add_networkTypes(self, value): self.networkTypes.append(value)
    def insert_networkTypes(self, index, value): self.networkTypes[index] = value
    networkTypesProp = property(get_networkTypes, set_networkTypes)
    def validate_NetworkTypeEnum(self, value):
        # Validate type NetworkTypeEnum, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='GroupIdType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupIdType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupIdType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupIdType', fromsubclass_=False):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('<%sid>%s</%sid>\n' % (namespace_, self.gds_format_string(quote_xml(self.id).encode(ExternalEncoding), input_name='id'), namespace_))
        for networkTypes_ in self.networkTypes:
            showIndent(outfile, level)
            outfile.write('<%snetworkTypes>%s</%snetworkTypes>\n' % (namespace_, self.gds_format_string(quote_xml(networkTypes_).encode(ExternalEncoding), input_name='networkTypes'), namespace_))
    def hasContent_(self):
        if (
            self.id is not None or
            self.networkTypes
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupIdType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('networkTypes=[\n')
        level += 1
        for networkTypes_ in self.networkTypes:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(networkTypes_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'networkTypes':
            networkTypes_ = child_.text
            networkTypes_ = self.gds_validate_string(networkTypes_, node, 'networkTypes')
            self.networkTypes.append(networkTypes_)
            self.validate_NetworkTypeEnum(self.networkTypes)    # validate type NetworkTypeEnum
    @classmethod
    def get_all_members(cls):
        member_items = GroupIdType.member_data_items_
        if GroupIdType.superclass != None:
            member_items.update(GroupIdType.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return GroupIdType._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = GroupIdType()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return GroupIdType.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = GroupIdType.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class GroupIdType


class Subnet(Resource):
    member_data_items_ = {
        'description': MemberSpec_('description', 'xs:string', 0),
        'networkAddress': MemberSpec_('networkAddress', 'xs:string', 0),
        'networkMask': MemberSpec_('networkMask', 'xs:string', 0),
        'networkSources': MemberSpec_('networkSources', ['NetworkSourceEnum', 'xs:string'], 1),
        'ipType': MemberSpec_('ipType', ['IpTypeEnum', 'xs:string'], 0),
        'isPublic': MemberSpec_('isPublic', 'xs:boolean', 0),
        'isShareable': MemberSpec_('isShareable', 'xs:boolean', 0),
        'dnsDomain': MemberSpec_('dnsDomain', 'xs:string', 0),
        'dnsServers': MemberSpec_('dnsServers', 'xs:string', 1),
        'dnsSearchSuffixes': MemberSpec_('dnsSearchSuffixes', 'xs:string', 1),
        'defaultGateways': MemberSpec_('defaultGateways', 'xs:string', 1),
        'msDomainType': MemberSpec_('msDomainType', ['MsDomainTypeEnum', 'xs:string'], 0),
        'msDomainName': MemberSpec_('msDomainName', 'xs:string', 0),
        'winsServers': MemberSpec_('winsServers', 'xs:string', 1),
        'ntpDateServers': MemberSpec_('ntpDateServers', 'xs:string', 1),
        'vlanId': MemberSpec_('vlanId', 'xs:string', 0),
        'isBootNetwork': MemberSpec_('isBootNetwork', 'xs:boolean', 0),
        'deploymentServices': MemberSpec_('deploymentServices', 'xs:string', 1),
        'groupIdTypes': MemberSpec_('groupIdTypes', 'GroupIdType', 1),
        'parentIds': MemberSpec_('parentIds', 'xs:string', 1),
        'childIds': MemberSpec_('childIds', 'xs:string', 1),
        'isTrunk': MemberSpec_('isTrunk', 'xs:boolean', 0),
        'redundancyPeerIds': MemberSpec_('redundancyPeerIds', 'xs:string', 1),
        'redundancyMasterId': MemberSpec_('redundancyMasterId', 'xs:string', 0),
        'isNativeVlan': MemberSpec_('isNativeVlan', 'xs:boolean', 0),
        'resourceTags': MemberSpec_('resourceTags', 'ResourceTag', 1),
        'ipAddressRanges': MemberSpec_('ipAddressRanges', 'IpAddressRange', 1),
        'usedIpAddresses': MemberSpec_('usedIpAddresses', 'IpAddress', 1),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, description=None, networkAddress=None, networkMask=None, networkSources=None, ipType=None, isPublic=None, isShareable=None, dnsDomain=None, dnsServers=None, dnsSearchSuffixes=None, defaultGateways=None, msDomainType=None, msDomainName=None, winsServers=None, ntpDateServers=None, vlanId=None, isBootNetwork=None, deploymentServices=None, groupIdTypes=None, parentIds=None, childIds=None, isTrunk=None, redundancyPeerIds=None, redundancyMasterId=None, isNativeVlan=None, resourceTags=None, ipAddressRanges=None, usedIpAddresses=None):
        super(Subnet, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.description = description
        self.networkAddress = networkAddress
        self.networkMask = networkMask
        if networkSources is None:
            self.networkSources = []
        else:
            self.networkSources = networkSources
        self.ipType = ipType
        self.isPublic = isPublic
        self.isShareable = isShareable
        self.dnsDomain = dnsDomain
        if dnsServers is None:
            self.dnsServers = []
        else:
            self.dnsServers = dnsServers
        if dnsSearchSuffixes is None:
            self.dnsSearchSuffixes = []
        else:
            self.dnsSearchSuffixes = dnsSearchSuffixes
        if defaultGateways is None:
            self.defaultGateways = []
        else:
            self.defaultGateways = defaultGateways
        self.msDomainType = msDomainType
        self.msDomainName = msDomainName
        if winsServers is None:
            self.winsServers = []
        else:
            self.winsServers = winsServers
        if ntpDateServers is None:
            self.ntpDateServers = []
        else:
            self.ntpDateServers = ntpDateServers
        self.vlanId = vlanId
        self.isBootNetwork = isBootNetwork
        if deploymentServices is None:
            self.deploymentServices = []
        else:
            self.deploymentServices = deploymentServices
        if groupIdTypes is None:
            self.groupIdTypes = []
        else:
            self.groupIdTypes = groupIdTypes
        if parentIds is None:
            self.parentIds = []
        else:
            self.parentIds = parentIds
        if childIds is None:
            self.childIds = []
        else:
            self.childIds = childIds
        self.isTrunk = isTrunk
        if redundancyPeerIds is None:
            self.redundancyPeerIds = []
        else:
            self.redundancyPeerIds = redundancyPeerIds
        self.redundancyMasterId = redundancyMasterId
        self.isNativeVlan = isNativeVlan
        if resourceTags is None:
            self.resourceTags = []
        else:
            self.resourceTags = resourceTags
        if ipAddressRanges is None:
            self.ipAddressRanges = []
        else:
            self.ipAddressRanges = ipAddressRanges
        if usedIpAddresses is None:
            self.usedIpAddresses = []
        else:
            self.usedIpAddresses = usedIpAddresses
    def factory(*args_, **kwargs_):
        if Subnet.subclass:
            return Subnet.subclass(*args_, **kwargs_)
        else:
            return Subnet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_networkAddress(self): return self.networkAddress
    def set_networkAddress(self, networkAddress): self.networkAddress = networkAddress
    networkAddressProp = property(get_networkAddress, set_networkAddress)
    def get_networkMask(self): return self.networkMask
    def set_networkMask(self, networkMask): self.networkMask = networkMask
    networkMaskProp = property(get_networkMask, set_networkMask)
    def get_networkSources(self): return self.networkSources
    def set_networkSources(self, networkSources): self.networkSources = networkSources
    def add_networkSources(self, value): self.networkSources.append(value)
    def insert_networkSources(self, index, value): self.networkSources[index] = value
    networkSourcesProp = property(get_networkSources, set_networkSources)
    def validate_NetworkSourceEnum(self, value):
        # Validate type NetworkSourceEnum, a restriction on xs:string.
        pass
    def get_ipType(self): return self.ipType
    def set_ipType(self, ipType): self.ipType = ipType
    ipTypeProp = property(get_ipType, set_ipType)
    def validate_IpTypeEnum(self, value):
        # Validate type IpTypeEnum, a restriction on xs:string.
        pass
    def get_isPublic(self): return self.isPublic
    def set_isPublic(self, isPublic): self.isPublic = isPublic
    isPublicProp = property(get_isPublic, set_isPublic)
    def get_isShareable(self): return self.isShareable
    def set_isShareable(self, isShareable): self.isShareable = isShareable
    isShareableProp = property(get_isShareable, set_isShareable)
    def get_dnsDomain(self): return self.dnsDomain
    def set_dnsDomain(self, dnsDomain): self.dnsDomain = dnsDomain
    dnsDomainProp = property(get_dnsDomain, set_dnsDomain)
    def get_dnsServers(self): return self.dnsServers
    def set_dnsServers(self, dnsServers): self.dnsServers = dnsServers
    def add_dnsServers(self, value): self.dnsServers.append(value)
    def insert_dnsServers(self, index, value): self.dnsServers[index] = value
    dnsServersProp = property(get_dnsServers, set_dnsServers)
    def get_dnsSearchSuffixes(self): return self.dnsSearchSuffixes
    def set_dnsSearchSuffixes(self, dnsSearchSuffixes): self.dnsSearchSuffixes = dnsSearchSuffixes
    def add_dnsSearchSuffixes(self, value): self.dnsSearchSuffixes.append(value)
    def insert_dnsSearchSuffixes(self, index, value): self.dnsSearchSuffixes[index] = value
    dnsSearchSuffixesProp = property(get_dnsSearchSuffixes, set_dnsSearchSuffixes)
    def get_defaultGateways(self): return self.defaultGateways
    def set_defaultGateways(self, defaultGateways): self.defaultGateways = defaultGateways
    def add_defaultGateways(self, value): self.defaultGateways.append(value)
    def insert_defaultGateways(self, index, value): self.defaultGateways[index] = value
    defaultGatewaysProp = property(get_defaultGateways, set_defaultGateways)
    def get_msDomainType(self): return self.msDomainType
    def set_msDomainType(self, msDomainType): self.msDomainType = msDomainType
    msDomainTypeProp = property(get_msDomainType, set_msDomainType)
    def validate_MsDomainTypeEnum(self, value):
        # Validate type MsDomainTypeEnum, a restriction on xs:string.
        pass
    def get_msDomainName(self): return self.msDomainName
    def set_msDomainName(self, msDomainName): self.msDomainName = msDomainName
    msDomainNameProp = property(get_msDomainName, set_msDomainName)
    def get_winsServers(self): return self.winsServers
    def set_winsServers(self, winsServers): self.winsServers = winsServers
    def add_winsServers(self, value): self.winsServers.append(value)
    def insert_winsServers(self, index, value): self.winsServers[index] = value
    winsServersProp = property(get_winsServers, set_winsServers)
    def get_ntpDateServers(self): return self.ntpDateServers
    def set_ntpDateServers(self, ntpDateServers): self.ntpDateServers = ntpDateServers
    def add_ntpDateServers(self, value): self.ntpDateServers.append(value)
    def insert_ntpDateServers(self, index, value): self.ntpDateServers[index] = value
    ntpDateServersProp = property(get_ntpDateServers, set_ntpDateServers)
    def get_vlanId(self): return self.vlanId
    def set_vlanId(self, vlanId): self.vlanId = vlanId
    vlanIdProp = property(get_vlanId, set_vlanId)
    def get_isBootNetwork(self): return self.isBootNetwork
    def set_isBootNetwork(self, isBootNetwork): self.isBootNetwork = isBootNetwork
    isBootNetworkProp = property(get_isBootNetwork, set_isBootNetwork)
    def get_deploymentServices(self): return self.deploymentServices
    def set_deploymentServices(self, deploymentServices): self.deploymentServices = deploymentServices
    def add_deploymentServices(self, value): self.deploymentServices.append(value)
    def insert_deploymentServices(self, index, value): self.deploymentServices[index] = value
    deploymentServicesProp = property(get_deploymentServices, set_deploymentServices)
    def get_groupIdTypes(self): return self.groupIdTypes
    def set_groupIdTypes(self, groupIdTypes): self.groupIdTypes = groupIdTypes
    def add_groupIdTypes(self, value): self.groupIdTypes.append(value)
    def insert_groupIdTypes(self, index, value): self.groupIdTypes[index] = value
    groupIdTypesProp = property(get_groupIdTypes, set_groupIdTypes)
    def get_parentIds(self): return self.parentIds
    def set_parentIds(self, parentIds): self.parentIds = parentIds
    def add_parentIds(self, value): self.parentIds.append(value)
    def insert_parentIds(self, index, value): self.parentIds[index] = value
    parentIdsProp = property(get_parentIds, set_parentIds)
    def get_childIds(self): return self.childIds
    def set_childIds(self, childIds): self.childIds = childIds
    def add_childIds(self, value): self.childIds.append(value)
    def insert_childIds(self, index, value): self.childIds[index] = value
    childIdsProp = property(get_childIds, set_childIds)
    def get_isTrunk(self): return self.isTrunk
    def set_isTrunk(self, isTrunk): self.isTrunk = isTrunk
    isTrunkProp = property(get_isTrunk, set_isTrunk)
    def get_redundancyPeerIds(self): return self.redundancyPeerIds
    def set_redundancyPeerIds(self, redundancyPeerIds): self.redundancyPeerIds = redundancyPeerIds
    def add_redundancyPeerIds(self, value): self.redundancyPeerIds.append(value)
    def insert_redundancyPeerIds(self, index, value): self.redundancyPeerIds[index] = value
    redundancyPeerIdsProp = property(get_redundancyPeerIds, set_redundancyPeerIds)
    def get_redundancyMasterId(self): return self.redundancyMasterId
    def set_redundancyMasterId(self, redundancyMasterId): self.redundancyMasterId = redundancyMasterId
    redundancyMasterIdProp = property(get_redundancyMasterId, set_redundancyMasterId)
    def get_isNativeVlan(self): return self.isNativeVlan
    def set_isNativeVlan(self, isNativeVlan): self.isNativeVlan = isNativeVlan
    isNativeVlanProp = property(get_isNativeVlan, set_isNativeVlan)
    def get_resourceTags(self): return self.resourceTags
    def set_resourceTags(self, resourceTags): self.resourceTags = resourceTags
    def add_resourceTags(self, value): self.resourceTags.append(value)
    def insert_resourceTags(self, index, value): self.resourceTags[index] = value
    resourceTagsProp = property(get_resourceTags, set_resourceTags)
    def get_ipAddressRanges(self): return self.ipAddressRanges
    def set_ipAddressRanges(self, ipAddressRanges): self.ipAddressRanges = ipAddressRanges
    def add_ipAddressRanges(self, value): self.ipAddressRanges.append(value)
    def insert_ipAddressRanges(self, index, value): self.ipAddressRanges[index] = value
    ipAddressRangesProp = property(get_ipAddressRanges, set_ipAddressRanges)
    def get_usedIpAddresses(self): return self.usedIpAddresses
    def set_usedIpAddresses(self, usedIpAddresses): self.usedIpAddresses = usedIpAddresses
    def add_usedIpAddresses(self, value): self.usedIpAddresses.append(value)
    def insert_usedIpAddresses(self, index, value): self.usedIpAddresses[index] = value
    usedIpAddressesProp = property(get_usedIpAddresses, set_usedIpAddresses)
    def export(self, outfile, level, namespace_='', name_='Subnet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Subnet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Subnet'):
        super(Subnet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Subnet')
    def exportChildren(self, outfile, level, namespace_='', name_='Subnet', fromsubclass_=False):
        super(Subnet, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.networkAddress is not None:
            showIndent(outfile, level)
            outfile.write('<%snetworkAddress>%s</%snetworkAddress>\n' % (namespace_, self.gds_format_string(quote_xml(self.networkAddress).encode(ExternalEncoding), input_name='networkAddress'), namespace_))
        if self.networkMask is not None:
            showIndent(outfile, level)
            outfile.write('<%snetworkMask>%s</%snetworkMask>\n' % (namespace_, self.gds_format_string(quote_xml(self.networkMask).encode(ExternalEncoding), input_name='networkMask'), namespace_))
        for networkSources_ in self.networkSources:
            showIndent(outfile, level)
            outfile.write('<%snetworkSources>%s</%snetworkSources>\n' % (namespace_, self.gds_format_string(quote_xml(networkSources_).encode(ExternalEncoding), input_name='networkSources'), namespace_))
        if self.ipType is not None:
            showIndent(outfile, level)
            outfile.write('<%sipType>%s</%sipType>\n' % (namespace_, self.gds_format_string(quote_xml(self.ipType).encode(ExternalEncoding), input_name='ipType'), namespace_))
        if self.isPublic is not None:
            showIndent(outfile, level)
            outfile.write('<%sisPublic>%s</%sisPublic>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isPublic)), input_name='isPublic'), namespace_))
        if self.isShareable is not None:
            showIndent(outfile, level)
            outfile.write('<%sisShareable>%s</%sisShareable>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isShareable)), input_name='isShareable'), namespace_))
        if self.dnsDomain is not None:
            showIndent(outfile, level)
            outfile.write('<%sdnsDomain>%s</%sdnsDomain>\n' % (namespace_, self.gds_format_string(quote_xml(self.dnsDomain).encode(ExternalEncoding), input_name='dnsDomain'), namespace_))
        for dnsServers_ in self.dnsServers:
            showIndent(outfile, level)
            outfile.write('<%sdnsServers>%s</%sdnsServers>\n' % (namespace_, self.gds_format_string(quote_xml(dnsServers_).encode(ExternalEncoding), input_name='dnsServers'), namespace_))
        for dnsSearchSuffixes_ in self.dnsSearchSuffixes:
            showIndent(outfile, level)
            outfile.write('<%sdnsSearchSuffixes>%s</%sdnsSearchSuffixes>\n' % (namespace_, self.gds_format_string(quote_xml(dnsSearchSuffixes_).encode(ExternalEncoding), input_name='dnsSearchSuffixes'), namespace_))
        for defaultGateways_ in self.defaultGateways:
            showIndent(outfile, level)
            outfile.write('<%sdefaultGateways>%s</%sdefaultGateways>\n' % (namespace_, self.gds_format_string(quote_xml(defaultGateways_).encode(ExternalEncoding), input_name='defaultGateways'), namespace_))
        if self.msDomainType is not None:
            showIndent(outfile, level)
            outfile.write('<%smsDomainType>%s</%smsDomainType>\n' % (namespace_, self.gds_format_string(quote_xml(self.msDomainType).encode(ExternalEncoding), input_name='msDomainType'), namespace_))
        if self.msDomainName is not None:
            showIndent(outfile, level)
            outfile.write('<%smsDomainName>%s</%smsDomainName>\n' % (namespace_, self.gds_format_string(quote_xml(self.msDomainName).encode(ExternalEncoding), input_name='msDomainName'), namespace_))
        for winsServers_ in self.winsServers:
            showIndent(outfile, level)
            outfile.write('<%swinsServers>%s</%swinsServers>\n' % (namespace_, self.gds_format_string(quote_xml(winsServers_).encode(ExternalEncoding), input_name='winsServers'), namespace_))
        for ntpDateServers_ in self.ntpDateServers:
            showIndent(outfile, level)
            outfile.write('<%sntpDateServers>%s</%sntpDateServers>\n' % (namespace_, self.gds_format_string(quote_xml(ntpDateServers_).encode(ExternalEncoding), input_name='ntpDateServers'), namespace_))
        if self.vlanId is not None:
            showIndent(outfile, level)
            outfile.write('<%svlanId>%s</%svlanId>\n' % (namespace_, self.gds_format_string(quote_xml(self.vlanId).encode(ExternalEncoding), input_name='vlanId'), namespace_))
        if self.isBootNetwork is not None:
            showIndent(outfile, level)
            outfile.write('<%sisBootNetwork>%s</%sisBootNetwork>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isBootNetwork)), input_name='isBootNetwork'), namespace_))
        for deploymentServices_ in self.deploymentServices:
            showIndent(outfile, level)
            outfile.write('<%sdeploymentServices>%s</%sdeploymentServices>\n' % (namespace_, self.gds_format_string(quote_xml(deploymentServices_).encode(ExternalEncoding), input_name='deploymentServices'), namespace_))
        for groupIdTypes_ in self.groupIdTypes:
            groupIdTypes_.export(outfile, level, namespace_, name_='groupIdTypes')
        for parentIds_ in self.parentIds:
            showIndent(outfile, level)
            outfile.write('<%sparentIds>%s</%sparentIds>\n' % (namespace_, self.gds_format_string(quote_xml(parentIds_).encode(ExternalEncoding), input_name='parentIds'), namespace_))
        for childIds_ in self.childIds:
            showIndent(outfile, level)
            outfile.write('<%schildIds>%s</%schildIds>\n' % (namespace_, self.gds_format_string(quote_xml(childIds_).encode(ExternalEncoding), input_name='childIds'), namespace_))
        if self.isTrunk is not None:
            showIndent(outfile, level)
            outfile.write('<%sisTrunk>%s</%sisTrunk>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isTrunk)), input_name='isTrunk'), namespace_))
        for redundancyPeerIds_ in self.redundancyPeerIds:
            showIndent(outfile, level)
            outfile.write('<%sredundancyPeerIds>%s</%sredundancyPeerIds>\n' % (namespace_, self.gds_format_string(quote_xml(redundancyPeerIds_).encode(ExternalEncoding), input_name='redundancyPeerIds'), namespace_))
        if self.redundancyMasterId is not None:
            showIndent(outfile, level)
            outfile.write('<%sredundancyMasterId>%s</%sredundancyMasterId>\n' % (namespace_, self.gds_format_string(quote_xml(self.redundancyMasterId).encode(ExternalEncoding), input_name='redundancyMasterId'), namespace_))
        if self.isNativeVlan is not None:
            showIndent(outfile, level)
            outfile.write('<%sisNativeVlan>%s</%sisNativeVlan>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.isNativeVlan)), input_name='isNativeVlan'), namespace_))
        for resourceTags_ in self.resourceTags:
            resourceTags_.export(outfile, level, namespace_, name_='resourceTags')
        for ipAddressRanges_ in self.ipAddressRanges:
            ipAddressRanges_.export(outfile, level, namespace_, name_='ipAddressRanges')
        for usedIpAddresses_ in self.usedIpAddresses:
            usedIpAddresses_.export(outfile, level, namespace_, name_='usedIpAddresses')
    def hasContent_(self):
        if (
            self.description is not None or
            self.networkAddress is not None or
            self.networkMask is not None or
            self.networkSources or
            self.ipType is not None or
            self.isPublic is not None or
            self.isShareable is not None or
            self.dnsDomain is not None or
            self.dnsServers or
            self.dnsSearchSuffixes or
            self.defaultGateways or
            self.msDomainType is not None or
            self.msDomainName is not None or
            self.winsServers or
            self.ntpDateServers or
            self.vlanId is not None or
            self.isBootNetwork is not None or
            self.deploymentServices or
            self.groupIdTypes or
            self.parentIds or
            self.childIds or
            self.isTrunk is not None or
            self.redundancyPeerIds or
            self.redundancyMasterId is not None or
            self.isNativeVlan is not None or
            self.resourceTags or
            self.ipAddressRanges or
            self.usedIpAddresses or
            super(Subnet, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Subnet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Subnet, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Subnet, self).exportLiteralChildren(outfile, level, name_)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.networkAddress is not None:
            showIndent(outfile, level)
            outfile.write('networkAddress=%s,\n' % quote_python(self.networkAddress).encode(ExternalEncoding))
        if self.networkMask is not None:
            showIndent(outfile, level)
            outfile.write('networkMask=%s,\n' % quote_python(self.networkMask).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('networkSources=[\n')
        level += 1
        for networkSources_ in self.networkSources:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(networkSources_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ipType is not None:
            showIndent(outfile, level)
            outfile.write('ipType=%s,\n' % quote_python(self.ipType).encode(ExternalEncoding))
        if self.isPublic is not None:
            showIndent(outfile, level)
            outfile.write('isPublic=%s,\n' % self.isPublic)
        if self.isShareable is not None:
            showIndent(outfile, level)
            outfile.write('isShareable=%s,\n' % self.isShareable)
        if self.dnsDomain is not None:
            showIndent(outfile, level)
            outfile.write('dnsDomain=%s,\n' % quote_python(self.dnsDomain).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('dnsServers=[\n')
        level += 1
        for dnsServers_ in self.dnsServers:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(dnsServers_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('dnsSearchSuffixes=[\n')
        level += 1
        for dnsSearchSuffixes_ in self.dnsSearchSuffixes:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(dnsSearchSuffixes_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('defaultGateways=[\n')
        level += 1
        for defaultGateways_ in self.defaultGateways:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(defaultGateways_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.msDomainType is not None:
            showIndent(outfile, level)
            outfile.write('msDomainType=%s,\n' % quote_python(self.msDomainType).encode(ExternalEncoding))
        if self.msDomainName is not None:
            showIndent(outfile, level)
            outfile.write('msDomainName=%s,\n' % quote_python(self.msDomainName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('winsServers=[\n')
        level += 1
        for winsServers_ in self.winsServers:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(winsServers_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ntpDateServers=[\n')
        level += 1
        for ntpDateServers_ in self.ntpDateServers:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ntpDateServers_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.vlanId is not None:
            showIndent(outfile, level)
            outfile.write('vlanId=%s,\n' % quote_python(self.vlanId).encode(ExternalEncoding))
        if self.isBootNetwork is not None:
            showIndent(outfile, level)
            outfile.write('isBootNetwork=%s,\n' % self.isBootNetwork)
        showIndent(outfile, level)
        outfile.write('deploymentServices=[\n')
        level += 1
        for deploymentServices_ in self.deploymentServices:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(deploymentServices_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('groupIdTypes=[\n')
        level += 1
        for groupIdTypes_ in self.groupIdTypes:
            showIndent(outfile, level)
            outfile.write('model_.GroupIdType(\n')
            groupIdTypes_.exportLiteral(outfile, level, name_='GroupIdType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('parentIds=[\n')
        level += 1
        for parentIds_ in self.parentIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(parentIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('childIds=[\n')
        level += 1
        for childIds_ in self.childIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(childIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.isTrunk is not None:
            showIndent(outfile, level)
            outfile.write('isTrunk=%s,\n' % self.isTrunk)
        showIndent(outfile, level)
        outfile.write('redundancyPeerIds=[\n')
        level += 1
        for redundancyPeerIds_ in self.redundancyPeerIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(redundancyPeerIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.redundancyMasterId is not None:
            showIndent(outfile, level)
            outfile.write('redundancyMasterId=%s,\n' % quote_python(self.redundancyMasterId).encode(ExternalEncoding))
        if self.isNativeVlan is not None:
            showIndent(outfile, level)
            outfile.write('isNativeVlan=%s,\n' % self.isNativeVlan)
        showIndent(outfile, level)
        outfile.write('resourceTags=[\n')
        level += 1
        for resourceTags_ in self.resourceTags:
            showIndent(outfile, level)
            outfile.write('model_.ResourceTag(\n')
            resourceTags_.exportLiteral(outfile, level, name_='ResourceTag')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ipAddressRanges=[\n')
        level += 1
        for ipAddressRanges_ in self.ipAddressRanges:
            showIndent(outfile, level)
            outfile.write('model_.IpAddressRange(\n')
            ipAddressRanges_.exportLiteral(outfile, level, name_='IpAddressRange')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('usedIpAddresses=[\n')
        level += 1
        for usedIpAddresses_ in self.usedIpAddresses:
            showIndent(outfile, level)
            outfile.write('model_.IpAddress(\n')
            usedIpAddresses_.exportLiteral(outfile, level, name_='IpAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Subnet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'networkAddress':
            networkAddress_ = child_.text
            networkAddress_ = self.gds_validate_string(networkAddress_, node, 'networkAddress')
            self.networkAddress = networkAddress_
        elif nodeName_ == 'networkMask':
            networkMask_ = child_.text
            networkMask_ = self.gds_validate_string(networkMask_, node, 'networkMask')
            self.networkMask = networkMask_
        elif nodeName_ == 'networkSources':
            networkSources_ = child_.text
            networkSources_ = self.gds_validate_string(networkSources_, node, 'networkSources')
            self.networkSources.append(networkSources_)
            self.validate_NetworkSourceEnum(self.networkSources)    # validate type NetworkSourceEnum
        elif nodeName_ == 'ipType':
            ipType_ = child_.text
            ipType_ = self.gds_validate_string(ipType_, node, 'ipType')
            self.ipType = ipType_
            self.validate_IpTypeEnum(self.ipType)    # validate type IpTypeEnum
        elif nodeName_ == 'isPublic':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPublic')
            self.isPublic = ival_
        elif nodeName_ == 'isShareable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isShareable')
            self.isShareable = ival_
        elif nodeName_ == 'dnsDomain':
            dnsDomain_ = child_.text
            dnsDomain_ = self.gds_validate_string(dnsDomain_, node, 'dnsDomain')
            self.dnsDomain = dnsDomain_
        elif nodeName_ == 'dnsServers':
            dnsServers_ = child_.text
            dnsServers_ = self.gds_validate_string(dnsServers_, node, 'dnsServers')
            self.dnsServers.append(dnsServers_)
        elif nodeName_ == 'dnsSearchSuffixes':
            dnsSearchSuffixes_ = child_.text
            dnsSearchSuffixes_ = self.gds_validate_string(dnsSearchSuffixes_, node, 'dnsSearchSuffixes')
            self.dnsSearchSuffixes.append(dnsSearchSuffixes_)
        elif nodeName_ == 'defaultGateways':
            defaultGateways_ = child_.text
            defaultGateways_ = self.gds_validate_string(defaultGateways_, node, 'defaultGateways')
            self.defaultGateways.append(defaultGateways_)
        elif nodeName_ == 'msDomainType':
            msDomainType_ = child_.text
            msDomainType_ = self.gds_validate_string(msDomainType_, node, 'msDomainType')
            self.msDomainType = msDomainType_
            self.validate_MsDomainTypeEnum(self.msDomainType)    # validate type MsDomainTypeEnum
        elif nodeName_ == 'msDomainName':
            msDomainName_ = child_.text
            msDomainName_ = self.gds_validate_string(msDomainName_, node, 'msDomainName')
            self.msDomainName = msDomainName_
        elif nodeName_ == 'winsServers':
            winsServers_ = child_.text
            winsServers_ = self.gds_validate_string(winsServers_, node, 'winsServers')
            self.winsServers.append(winsServers_)
        elif nodeName_ == 'ntpDateServers':
            ntpDateServers_ = child_.text
            ntpDateServers_ = self.gds_validate_string(ntpDateServers_, node, 'ntpDateServers')
            self.ntpDateServers.append(ntpDateServers_)
        elif nodeName_ == 'vlanId':
            vlanId_ = child_.text
            vlanId_ = self.gds_validate_string(vlanId_, node, 'vlanId')
            self.vlanId = vlanId_
        elif nodeName_ == 'isBootNetwork':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isBootNetwork')
            self.isBootNetwork = ival_
        elif nodeName_ == 'deploymentServices':
            deploymentServices_ = child_.text
            deploymentServices_ = self.gds_validate_string(deploymentServices_, node, 'deploymentServices')
            self.deploymentServices.append(deploymentServices_)
        elif nodeName_ == 'groupIdTypes':
            obj_ = GroupIdType.factory()
            obj_.build(child_)
            self.groupIdTypes.append(obj_)
        elif nodeName_ == 'parentIds':
            parentIds_ = child_.text
            parentIds_ = self.gds_validate_string(parentIds_, node, 'parentIds')
            self.parentIds.append(parentIds_)
        elif nodeName_ == 'childIds':
            childIds_ = child_.text
            childIds_ = self.gds_validate_string(childIds_, node, 'childIds')
            self.childIds.append(childIds_)
        elif nodeName_ == 'isTrunk':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isTrunk')
            self.isTrunk = ival_
        elif nodeName_ == 'redundancyPeerIds':
            redundancyPeerIds_ = child_.text
            redundancyPeerIds_ = self.gds_validate_string(redundancyPeerIds_, node, 'redundancyPeerIds')
            self.redundancyPeerIds.append(redundancyPeerIds_)
        elif nodeName_ == 'redundancyMasterId':
            redundancyMasterId_ = child_.text
            redundancyMasterId_ = self.gds_validate_string(redundancyMasterId_, node, 'redundancyMasterId')
            self.redundancyMasterId = redundancyMasterId_
        elif nodeName_ == 'isNativeVlan':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isNativeVlan')
            self.isNativeVlan = ival_
        elif nodeName_ == 'resourceTags':
            obj_ = ResourceTag.factory()
            obj_.build(child_)
            self.resourceTags.append(obj_)
        elif nodeName_ == 'ipAddressRanges':
            obj_ = IpAddressRange.factory()
            obj_.build(child_)
            self.ipAddressRanges.append(obj_)
        elif nodeName_ == 'usedIpAddresses':
            obj_ = IpAddress.factory()
            obj_.build(child_)
            self.usedIpAddresses.append(obj_)
        super(Subnet, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = Subnet.member_data_items_
        if Subnet.superclass != None:
            member_items.update(Subnet.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Subnet._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Subnet()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Subnet.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Subnet.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Subnet


class LoadBalancer(Resource):
    member_data_items_ = {
        'model': MemberSpec_('model', 'xs:string', 0),
        'version': MemberSpec_('version', 'xs:string', 0),
        'subnetIds': MemberSpec_('subnetIds', 'xs:string', 1),
        'managementAddress': MemberSpec_('managementAddress', 'xs:string', 0),
        'managementPort': MemberSpec_('managementPort', 'xs:int', 0),
        'managementUserName': MemberSpec_('managementUserName', 'xs:string', 0),
        'managementPasswordId': MemberSpec_('managementPasswordId', 'xs:string', 0),
        'managementCertificateId': MemberSpec_('managementCertificateId', 'xs:string', 0),
        'isHaSupported': MemberSpec_('isHaSupported', ['YesNoTriple', 'xs:string'], 0),
        'isSslSupported': MemberSpec_('isSslSupported', ['YesNoTriple', 'xs:string'], 0),
        'tags': MemberSpec_('tags', 'xs:string', 1),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, model=None, version=None, subnetIds=None, managementAddress=None, managementPort=None, managementUserName=None, managementPasswordId=None, managementCertificateId=None, isHaSupported=None, isSslSupported=None, tags=None):
        super(LoadBalancer, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        self.model = model
        self.version = version
        if subnetIds is None:
            self.subnetIds = []
        else:
            self.subnetIds = subnetIds
        self.managementAddress = managementAddress
        self.managementPort = managementPort
        self.managementUserName = managementUserName
        self.managementPasswordId = managementPasswordId
        self.managementCertificateId = managementCertificateId
        self.isHaSupported = isHaSupported
        self.isSslSupported = isSslSupported
        if tags is None:
            self.tags = []
        else:
            self.tags = tags
    def factory(*args_, **kwargs_):
        if LoadBalancer.subclass:
            return LoadBalancer.subclass(*args_, **kwargs_)
        else:
            return LoadBalancer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_model(self): return self.model
    def set_model(self, model): self.model = model
    modelProp = property(get_model, set_model)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    versionProp = property(get_version, set_version)
    def get_subnetIds(self): return self.subnetIds
    def set_subnetIds(self, subnetIds): self.subnetIds = subnetIds
    def add_subnetIds(self, value): self.subnetIds.append(value)
    def insert_subnetIds(self, index, value): self.subnetIds[index] = value
    subnetIdsProp = property(get_subnetIds, set_subnetIds)
    def get_managementAddress(self): return self.managementAddress
    def set_managementAddress(self, managementAddress): self.managementAddress = managementAddress
    managementAddressProp = property(get_managementAddress, set_managementAddress)
    def get_managementPort(self): return self.managementPort
    def set_managementPort(self, managementPort): self.managementPort = managementPort
    managementPortProp = property(get_managementPort, set_managementPort)
    def get_managementUserName(self): return self.managementUserName
    def set_managementUserName(self, managementUserName): self.managementUserName = managementUserName
    managementUserNameProp = property(get_managementUserName, set_managementUserName)
    def get_managementPasswordId(self): return self.managementPasswordId
    def set_managementPasswordId(self, managementPasswordId): self.managementPasswordId = managementPasswordId
    managementPasswordIdProp = property(get_managementPasswordId, set_managementPasswordId)
    def get_managementCertificateId(self): return self.managementCertificateId
    def set_managementCertificateId(self, managementCertificateId): self.managementCertificateId = managementCertificateId
    managementCertificateIdProp = property(get_managementCertificateId, set_managementCertificateId)
    def get_isHaSupported(self): return self.isHaSupported
    def set_isHaSupported(self, isHaSupported): self.isHaSupported = isHaSupported
    isHaSupportedProp = property(get_isHaSupported, set_isHaSupported)
    def validate_YesNoTriple(self, value):
        # Validate type YesNoTriple, a restriction on xs:string.
        pass
    def get_isSslSupported(self): return self.isSslSupported
    def set_isSslSupported(self, isSslSupported): self.isSslSupported = isSslSupported
    isSslSupportedProp = property(get_isSslSupported, set_isSslSupported)
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags(self, index, value): self.tags[index] = value
    tagsProp = property(get_tags, set_tags)
    def export(self, outfile, level, namespace_='', name_='LoadBalancer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadBalancer'):
        super(LoadBalancer, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancer')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadBalancer', fromsubclass_=False):
        super(LoadBalancer, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.model is not None:
            showIndent(outfile, level)
            outfile.write('<%smodel>%s</%smodel>\n' % (namespace_, self.gds_format_string(quote_xml(self.model).encode(ExternalEncoding), input_name='model'), namespace_))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('<%sversion>%s</%sversion>\n' % (namespace_, self.gds_format_string(quote_xml(self.version).encode(ExternalEncoding), input_name='version'), namespace_))
        for subnetIds_ in self.subnetIds:
            showIndent(outfile, level)
            outfile.write('<%ssubnetIds>%s</%ssubnetIds>\n' % (namespace_, self.gds_format_string(quote_xml(subnetIds_).encode(ExternalEncoding), input_name='subnetIds'), namespace_))
        if self.managementAddress is not None:
            showIndent(outfile, level)
            outfile.write('<%smanagementAddress>%s</%smanagementAddress>\n' % (namespace_, self.gds_format_string(quote_xml(self.managementAddress).encode(ExternalEncoding), input_name='managementAddress'), namespace_))
        if self.managementPort is not None:
            showIndent(outfile, level)
            outfile.write('<%smanagementPort>%s</%smanagementPort>\n' % (namespace_, self.gds_format_integer(self.managementPort, input_name='managementPort'), namespace_))
        if self.managementUserName is not None:
            showIndent(outfile, level)
            outfile.write('<%smanagementUserName>%s</%smanagementUserName>\n' % (namespace_, self.gds_format_string(quote_xml(self.managementUserName).encode(ExternalEncoding), input_name='managementUserName'), namespace_))
        if self.managementPasswordId is not None:
            showIndent(outfile, level)
            outfile.write('<%smanagementPasswordId>%s</%smanagementPasswordId>\n' % (namespace_, self.gds_format_string(quote_xml(self.managementPasswordId).encode(ExternalEncoding), input_name='managementPasswordId'), namespace_))
        if self.managementCertificateId is not None:
            showIndent(outfile, level)
            outfile.write('<%smanagementCertificateId>%s</%smanagementCertificateId>\n' % (namespace_, self.gds_format_string(quote_xml(self.managementCertificateId).encode(ExternalEncoding), input_name='managementCertificateId'), namespace_))
        if self.isHaSupported is not None:
            showIndent(outfile, level)
            outfile.write('<%sisHaSupported>%s</%sisHaSupported>\n' % (namespace_, self.gds_format_string(quote_xml(self.isHaSupported).encode(ExternalEncoding), input_name='isHaSupported'), namespace_))
        if self.isSslSupported is not None:
            showIndent(outfile, level)
            outfile.write('<%sisSslSupported>%s</%sisSslSupported>\n' % (namespace_, self.gds_format_string(quote_xml(self.isSslSupported).encode(ExternalEncoding), input_name='isSslSupported'), namespace_))
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('<%stags>%s</%stags>\n' % (namespace_, self.gds_format_string(quote_xml(tags_).encode(ExternalEncoding), input_name='tags'), namespace_))
    def hasContent_(self):
        if (
            self.model is not None or
            self.version is not None or
            self.subnetIds or
            self.managementAddress is not None or
            self.managementPort is not None or
            self.managementUserName is not None or
            self.managementPasswordId is not None or
            self.managementCertificateId is not None or
            self.isHaSupported is not None or
            self.isSslSupported is not None or
            self.tags or
            super(LoadBalancer, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LoadBalancer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadBalancer, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadBalancer, self).exportLiteralChildren(outfile, level, name_)
        if self.model is not None:
            showIndent(outfile, level)
            outfile.write('model=%s,\n' % quote_python(self.model).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%s,\n' % quote_python(self.version).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('subnetIds=[\n')
        level += 1
        for subnetIds_ in self.subnetIds:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(subnetIds_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.managementAddress is not None:
            showIndent(outfile, level)
            outfile.write('managementAddress=%s,\n' % quote_python(self.managementAddress).encode(ExternalEncoding))
        if self.managementPort is not None:
            showIndent(outfile, level)
            outfile.write('managementPort=%d,\n' % self.managementPort)
        if self.managementUserName is not None:
            showIndent(outfile, level)
            outfile.write('managementUserName=%s,\n' % quote_python(self.managementUserName).encode(ExternalEncoding))
        if self.managementPasswordId is not None:
            showIndent(outfile, level)
            outfile.write('managementPasswordId=%s,\n' % quote_python(self.managementPasswordId).encode(ExternalEncoding))
        if self.managementCertificateId is not None:
            showIndent(outfile, level)
            outfile.write('managementCertificateId=%s,\n' % quote_python(self.managementCertificateId).encode(ExternalEncoding))
        if self.isHaSupported is not None:
            showIndent(outfile, level)
            outfile.write('isHaSupported=%s,\n' % quote_python(self.isHaSupported).encode(ExternalEncoding))
        if self.isSslSupported is not None:
            showIndent(outfile, level)
            outfile.write('isSslSupported=%s,\n' % quote_python(self.isSslSupported).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(tags_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadBalancer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'model':
            model_ = child_.text
            model_ = self.gds_validate_string(model_, node, 'model')
            self.model = model_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'subnetIds':
            subnetIds_ = child_.text
            subnetIds_ = self.gds_validate_string(subnetIds_, node, 'subnetIds')
            self.subnetIds.append(subnetIds_)
        elif nodeName_ == 'managementAddress':
            managementAddress_ = child_.text
            managementAddress_ = self.gds_validate_string(managementAddress_, node, 'managementAddress')
            self.managementAddress = managementAddress_
        elif nodeName_ == 'managementPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'managementPort')
            self.managementPort = ival_
        elif nodeName_ == 'managementUserName':
            managementUserName_ = child_.text
            managementUserName_ = self.gds_validate_string(managementUserName_, node, 'managementUserName')
            self.managementUserName = managementUserName_
        elif nodeName_ == 'managementPasswordId':
            managementPasswordId_ = child_.text
            managementPasswordId_ = self.gds_validate_string(managementPasswordId_, node, 'managementPasswordId')
            self.managementPasswordId = managementPasswordId_
        elif nodeName_ == 'managementCertificateId':
            managementCertificateId_ = child_.text
            managementCertificateId_ = self.gds_validate_string(managementCertificateId_, node, 'managementCertificateId')
            self.managementCertificateId = managementCertificateId_
        elif nodeName_ == 'isHaSupported':
            isHaSupported_ = child_.text
            isHaSupported_ = self.gds_validate_string(isHaSupported_, node, 'isHaSupported')
            self.isHaSupported = isHaSupported_
            self.validate_YesNoTriple(self.isHaSupported)    # validate type YesNoTriple
        elif nodeName_ == 'isSslSupported':
            isSslSupported_ = child_.text
            isSslSupported_ = self.gds_validate_string(isSslSupported_, node, 'isSslSupported')
            self.isSslSupported = isSslSupported_
            self.validate_YesNoTriple(self.isSslSupported)    # validate type YesNoTriple
        elif nodeName_ == 'tags':
            tags_ = child_.text
            tags_ = self.gds_validate_string(tags_, node, 'tags')
            self.tags.append(tags_)
        super(LoadBalancer, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = LoadBalancer.member_data_items_
        if LoadBalancer.superclass != None:
            member_items.update(LoadBalancer.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return LoadBalancer._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = LoadBalancer()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return LoadBalancer.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = LoadBalancer.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class LoadBalancer


class Firewall(Resource):
    member_data_items_ = {
        'rules': MemberSpec_('rules', 'FirewallRule', 1),
        'groupName': MemberSpec_('groupName', 'xs:string', 0),
        'groupId': MemberSpec_('groupId', 'xs:string', 0),
        'capacityPoolId': MemberSpec_('capacityPoolId', 'xs:string', 0),
        }
    subclass = None
    superclass = Resource
    def __init__(self, resourceManagerId=None, utilization=None, limits=None, vendorProperties=None, rules=None, groupName=None, groupId=None, capacityPoolId=None):
        super(Firewall, self).__init__(resourceManagerId, utilization, limits, vendorProperties, )
        if rules is None:
            self.rules = []
        else:
            self.rules = rules
        self.groupName = groupName
        self.groupId = groupId
        self.capacityPoolId = capacityPoolId
    def factory(*args_, **kwargs_):
        if Firewall.subclass:
            return Firewall.subclass(*args_, **kwargs_)
        else:
            return Firewall(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rules(self): return self.rules
    def set_rules(self, rules): self.rules = rules
    def add_rules(self, value): self.rules.append(value)
    def insert_rules(self, index, value): self.rules[index] = value
    rulesProp = property(get_rules, set_rules)
    def get_groupName(self): return self.groupName
    def set_groupName(self, groupName): self.groupName = groupName
    groupNameProp = property(get_groupName, set_groupName)
    def get_groupId(self): return self.groupId
    def set_groupId(self, groupId): self.groupId = groupId
    groupIdProp = property(get_groupId, set_groupId)
    def get_capacityPoolId(self): return self.capacityPoolId
    def set_capacityPoolId(self, capacityPoolId): self.capacityPoolId = capacityPoolId
    capacityPoolIdProp = property(get_capacityPoolId, set_capacityPoolId)
    def export(self, outfile, level, namespace_='', name_='Firewall', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Firewall')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Firewall'):
        super(Firewall, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Firewall')
    def exportChildren(self, outfile, level, namespace_='', name_='Firewall', fromsubclass_=False):
        super(Firewall, self).exportChildren(outfile, level, namespace_, name_, True)
        for rules_ in self.rules:
            rules_.export(outfile, level, namespace_, name_='rules')
        if self.groupName is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroupName>%s</%sgroupName>\n' % (namespace_, self.gds_format_string(quote_xml(self.groupName).encode(ExternalEncoding), input_name='groupName'), namespace_))
        if self.groupId is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroupId>%s</%sgroupId>\n' % (namespace_, self.gds_format_string(quote_xml(self.groupId).encode(ExternalEncoding), input_name='groupId'), namespace_))
        if self.capacityPoolId is not None:
            showIndent(outfile, level)
            outfile.write('<%scapacityPoolId>%s</%scapacityPoolId>\n' % (namespace_, self.gds_format_string(quote_xml(self.capacityPoolId).encode(ExternalEncoding), input_name='capacityPoolId'), namespace_))
    def hasContent_(self):
        if (
            self.rules or
            self.groupName is not None or
            self.groupId is not None or
            self.capacityPoolId is not None or
            super(Firewall, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Firewall'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Firewall, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Firewall, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('rules=[\n')
        level += 1
        for rules_ in self.rules:
            showIndent(outfile, level)
            outfile.write('model_.FirewallRule(\n')
            rules_.exportLiteral(outfile, level, name_='FirewallRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.groupName is not None:
            showIndent(outfile, level)
            outfile.write('groupName=%s,\n' % quote_python(self.groupName).encode(ExternalEncoding))
        if self.groupId is not None:
            showIndent(outfile, level)
            outfile.write('groupId=%s,\n' % quote_python(self.groupId).encode(ExternalEncoding))
        if self.capacityPoolId is not None:
            showIndent(outfile, level)
            outfile.write('capacityPoolId=%s,\n' % quote_python(self.capacityPoolId).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Firewall, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rules':
            obj_ = FirewallRule.factory()
            obj_.build(child_)
            self.rules.append(obj_)
        elif nodeName_ == 'groupName':
            groupName_ = child_.text
            groupName_ = self.gds_validate_string(groupName_, node, 'groupName')
            self.groupName = groupName_
        elif nodeName_ == 'groupId':
            groupId_ = child_.text
            groupId_ = self.gds_validate_string(groupId_, node, 'groupId')
            self.groupId = groupId_
        elif nodeName_ == 'capacityPoolId':
            capacityPoolId_ = child_.text
            capacityPoolId_ = self.gds_validate_string(capacityPoolId_, node, 'capacityPoolId')
            self.capacityPoolId = capacityPoolId_
        super(Firewall, self).buildChildren(child_, node, nodeName_, True)
    @classmethod
    def get_all_members(cls):
        member_items = Firewall.member_data_items_
        if Firewall.superclass != None:
            member_items.update(Firewall.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return Firewall._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = Firewall()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return Firewall.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = Firewall.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class Firewall


class FirewallRule(GeneratedsSuper):
    member_data_items_ = {
        'protocolType': MemberSpec_('protocolType', ['PacketProtocolEnum', 'xs:string'], 0),
        'portStart': MemberSpec_('portStart', 'xs:int', 0),
        'portEnd': MemberSpec_('portEnd', 'xs:int', 0),
        'icmpType': MemberSpec_('icmpType', 'xs:int', 0),
        'icmpCode': MemberSpec_('icmpCode', 'xs:int', 0),
        'ipRanges': MemberSpec_('ipRanges', 'IpAddressRange', 1),
        }
    subclass = None
    superclass = None
    def __init__(self, protocolType=None, portStart=None, portEnd=None, icmpType=None, icmpCode=None, ipRanges=None):
        self.protocolType = protocolType
        self.portStart = portStart
        self.portEnd = portEnd
        self.icmpType = icmpType
        self.icmpCode = icmpCode
        if ipRanges is None:
            self.ipRanges = []
        else:
            self.ipRanges = ipRanges
    def factory(*args_, **kwargs_):
        if FirewallRule.subclass:
            return FirewallRule.subclass(*args_, **kwargs_)
        else:
            return FirewallRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocolType(self): return self.protocolType
    def set_protocolType(self, protocolType): self.protocolType = protocolType
    protocolTypeProp = property(get_protocolType, set_protocolType)
    def validate_PacketProtocolEnum(self, value):
        # Validate type PacketProtocolEnum, a restriction on xs:string.
        pass
    def get_portStart(self): return self.portStart
    def set_portStart(self, portStart): self.portStart = portStart
    portStartProp = property(get_portStart, set_portStart)
    def get_portEnd(self): return self.portEnd
    def set_portEnd(self, portEnd): self.portEnd = portEnd
    portEndProp = property(get_portEnd, set_portEnd)
    def get_icmpType(self): return self.icmpType
    def set_icmpType(self, icmpType): self.icmpType = icmpType
    icmpTypeProp = property(get_icmpType, set_icmpType)
    def get_icmpCode(self): return self.icmpCode
    def set_icmpCode(self, icmpCode): self.icmpCode = icmpCode
    icmpCodeProp = property(get_icmpCode, set_icmpCode)
    def get_ipRanges(self): return self.ipRanges
    def set_ipRanges(self, ipRanges): self.ipRanges = ipRanges
    def add_ipRanges(self, value): self.ipRanges.append(value)
    def insert_ipRanges(self, index, value): self.ipRanges[index] = value
    ipRangesProp = property(get_ipRanges, set_ipRanges)
    def export(self, outfile, level, namespace_='', name_='FirewallRule', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallRule')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallRule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallRule', fromsubclass_=False):
        if self.protocolType is not None:
            showIndent(outfile, level)
            outfile.write('<%sprotocolType>%s</%sprotocolType>\n' % (namespace_, self.gds_format_string(quote_xml(self.protocolType).encode(ExternalEncoding), input_name='protocolType'), namespace_))
        if self.portStart is not None:
            showIndent(outfile, level)
            outfile.write('<%sportStart>%s</%sportStart>\n' % (namespace_, self.gds_format_integer(self.portStart, input_name='portStart'), namespace_))
        if self.portEnd is not None:
            showIndent(outfile, level)
            outfile.write('<%sportEnd>%s</%sportEnd>\n' % (namespace_, self.gds_format_integer(self.portEnd, input_name='portEnd'), namespace_))
        if self.icmpType is not None:
            showIndent(outfile, level)
            outfile.write('<%sicmpType>%s</%sicmpType>\n' % (namespace_, self.gds_format_integer(self.icmpType, input_name='icmpType'), namespace_))
        if self.icmpCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sicmpCode>%s</%sicmpCode>\n' % (namespace_, self.gds_format_integer(self.icmpCode, input_name='icmpCode'), namespace_))
        for ipRanges_ in self.ipRanges:
            ipRanges_.export(outfile, level, namespace_, name_='ipRanges')
    def hasContent_(self):
        if (
            self.protocolType is not None or
            self.portStart is not None or
            self.portEnd is not None or
            self.icmpType is not None or
            self.icmpCode is not None or
            self.ipRanges
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FirewallRule'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocolType is not None:
            showIndent(outfile, level)
            outfile.write('protocolType=%s,\n' % quote_python(self.protocolType).encode(ExternalEncoding))
        if self.portStart is not None:
            showIndent(outfile, level)
            outfile.write('portStart=%d,\n' % self.portStart)
        if self.portEnd is not None:
            showIndent(outfile, level)
            outfile.write('portEnd=%d,\n' % self.portEnd)
        if self.icmpType is not None:
            showIndent(outfile, level)
            outfile.write('icmpType=%d,\n' % self.icmpType)
        if self.icmpCode is not None:
            showIndent(outfile, level)
            outfile.write('icmpCode=%d,\n' % self.icmpCode)
        showIndent(outfile, level)
        outfile.write('ipRanges=[\n')
        level += 1
        for ipRanges_ in self.ipRanges:
            showIndent(outfile, level)
            outfile.write('model_.IpAddressRange(\n')
            ipRanges_.exportLiteral(outfile, level, name_='IpAddressRange')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocolType':
            protocolType_ = child_.text
            protocolType_ = self.gds_validate_string(protocolType_, node, 'protocolType')
            self.protocolType = protocolType_
            self.validate_PacketProtocolEnum(self.protocolType)    # validate type PacketProtocolEnum
        elif nodeName_ == 'portStart':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'portStart')
            self.portStart = ival_
        elif nodeName_ == 'portEnd':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'portEnd')
            self.portEnd = ival_
        elif nodeName_ == 'icmpType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'icmpType')
            self.icmpType = ival_
        elif nodeName_ == 'icmpCode':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'icmpCode')
            self.icmpCode = ival_
        elif nodeName_ == 'ipRanges':
            obj_ = IpAddressRange.factory()
            obj_.build(child_)
            self.ipRanges.append(obj_)
    @classmethod
    def get_all_members(cls):
        member_items = FirewallRule.member_data_items_
        if FirewallRule.superclass != None:
            member_items.update(FirewallRule.superclass.get_all_members())
        return member_items
    def export_to_dictionary(self):
        return FirewallRule._export_to_dictionary(self)
    @classmethod
    def _export_to_dictionary(cls, value):
        resource_model_module_name = cls.__module__
        value_module_name = value.__class__.__module__
        if value_module_name == resource_model_module_name:
            # This is a resource model object
            member_specs = value.get_all_members()
            exported = {}
            for member_name in member_specs:
                member_getter = getattr(value, '_'.join(('get', member_name)))
                member_value = member_getter()
                member_spec = member_specs.get(member_name)
                if member_spec.get_container() == 1:
                    exported[member_name] = []
                    for iter_value in member_value:
                        if member_value is not None:
                            exported[member_name].                            append(cls._export_to_dictionary(iter_value))
                        else:
                            exported[member_name].append(None)
                else:
                    exported[member_name] =                     cls._export_to_dictionary(member_value)
            return exported
        else:
            return value
    @classmethod
    def build_from_dictionary(cls, dict):
        if dict is None:
            return None
        model = FirewallRule()
        member_specs = cls.get_all_members()
        for member_name in dict.keys():
            member_spec = member_specs.get(member_name)
            type_name = member_spec.get_data_type()
            try:
                __import__(cls.__module__)
                attribute_class = getattr(sys.modules[cls.__module__],
                                          type_name)
            except (ValueError, AttributeError):
                attribute_class = None
            built_value = None
            if attribute_class:
                # An attribute which in itself is resource model
                if member_spec.get_container() == 1:
                    values = dict[member_name]
                    if values is not None:
                        built_value = []
                        for value in values:
                            built_value.append(attribute_class.                            build_from_dictionary(value))
                else:
                    built_value = attribute_class.                    build_from_dictionary(dict[member_name])
            else:
                built_value = dict[member_name]
            member_setter = getattr(model, '_'.join(('set', member_name)))
            member_setter(built_value)
        return model
    def export_to_json(self):
        import json
        return json.dumps(self.export_to_dictionary(), indent=2)
    @classmethod
    def build_from_json(cls,json_str):
        import json
        return FirewallRule.build_from_dictionary(json.loads(json_str))
    from sqlalchemy import orm
    @orm.reconstructor
    def init_loader(self):
        from sqlalchemy import orm
        objMapper = orm.object_mapper(self)
        containedKeys = self.__dict__
        requiredkeys = FirewallRule.get_all_members()
        self.extensiontype_ = None
        for requiredkey in requiredkeys:
            mappedProp = None
            try:
                mappedProp = objMapper.get_property(requiredkey)
            except Exception:
                mappedProp = None
            if not mappedProp :
                if not containedKeys.has_key(requiredkey):
                    if requiredkeys[requiredkey].get_container() == 1:
                        setattr(self, requiredkey, [])
                    else:
                        setattr(self, requiredkey, None)
# end class FirewallRule


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Entity'
        rootClass = Entity
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Entity'
        rootClass = Entity
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Entity",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Entity'
        rootClass = Entity
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from healthnmonResourceModel import *\n\n')
    sys.stdout.write('import healthnmonResourceModel as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CloudCapacityPool",
    "CloudImage",
    "ComputeCluster",
    "ComputeServer",
    "Cost",
    "DeployableSoftware",
    "DiskArray",
    "Entity",
    "Error",
    "Event",
    "ExtensibleRaidLevel",
    "Firewall",
    "FirewallRule",
    "GroupIdType",
    "HostMountPoint",
    "Image",
    "IpAddress",
    "IpAddressRange",
    "IpProfile",
    "LoadBalancer",
    "MessageParameter",
    "OsProfile",
    "PhysicalServer",
    "PhysicalServerProfile",
    "PortGroup",
    "Property",
    "RdmDiskProfile",
    "Resource",
    "ResourceAllocation",
    "ResourceCapacityPool",
    "ResourceLimit",
    "ResourceTag",
    "ResourceUtilization",
    "SanVolume",
    "SanVolumeTemplate",
    "StorageTag",
    "StorageVolume",
    "Subnet",
    "VcNetwork",
    "VendorProperties",
    "VirtualSwitch",
    "Vm",
    "VmCapabilities",
    "VmCapacityPool",
    "VmCluster",
    "VmClusterCapabilities",
    "VmDisk",
    "VmGenericDevice",
    "VmGlobalSettings",
    "VmHost",
    "VmNetAdapter",
    "VmProfile",
    "VmScsiController",
    "VmTemplate",
    "WwnConnection"
    ]
